# 堆和栈的区别
1. 区别
    1. 存放的数据不同
        * 堆用于存放复杂数据结构，如对象、数组、函数等；此类数据结构大小未知，需要动态分配内存，并通过指针进行访问。创建数据时，会在堆上分配对应的内存，同时在栈上保存指向堆内存的指针或引用；
        * 栈则用于存储简答、直接的数据类型以及指向堆内存的引用。栈上的数据具有明确的生命周期，通常随着函数调用的结束而销毁。
    2. 空间大小及管理方式不同
        * 堆存放大小不一的对象，容量一般大于栈。堆内存分配和回收相对复杂，通常由垃圾回收机制自动管理，确保不再使用的内存被释放回操作系统。
        * 栈空间较小且严格受限，因为它必须快速进行内存分配和回收。栈内存分配在编译期间静态确定，或由运行时环境在函数调用和返回时自动完成，速度快开销小。
    3. 效率和性能
        * 堆操作通常涉及内存分配和垃圾回收，涉及复杂查找、标记、清理过程。相比栈操作有一定开销。在大型项目中，如果堆内存管理不当，可能导致内存碎片、内存泄露等问题，影响性能；
        * 栈操作通常是原子性的，速度快，堆处理器缓存友好，适合频繁操作。
2. 垃圾回收
    1. 回收目标
        1. 堆上数据是垃圾回收的主要目标，GC追踪堆内存的对象，识别对象是否可达，不可达对象被视为垃圾，可以被回收释放；
        2. 栈上述在函数执行完毕后自动释放，无需垃圾回收介入。只要函数调用栈展开，相关栈内的局部变量自动被销毁，占用内存得到回收。
    2. 回收策略和算法
        1. 堆的垃圾回收通常采用多种算法结合的方式，如Scavenge算法、标记-清楚-整理或增量标记算法。这些算法旨在高效、准确识别回收无用对象，减少回收过程中堆程序执行的影响。
        2. 栈回收策略，遵循“后进先出”原则。函数返回时，对应的栈帧被移除，其中的局部变量及其引用一同消失，内存立即得到回收。无需复杂算法、仅需简单的栈指针调整即可完成。

# 虚拟DOM本身是什么？虚拟DOM主要做了什么？如何理解虚拟DOM？

1. 虚拟DOM本质上是js对象。它以数据结构的形式准确模拟了DOM节点及其属性、样式、事件监听器等信息。这个对象并非浏览器真实DOM，而是开发者在内存中构建的一个与之对应的数据模型；虚拟DOM通常包含如下属性：
    1. tag：元素标签名
    2. props：对象，存储节点的各种属性
    3. children：数组或其他子节点，代表节点的嵌套内容
    4. 其他属性：如key、ref、slot等
2. 虚拟DOM核心功能在于实现高效、可控的UI更新。
    1. 简化视图层更新逻辑：开发人员通过声明式代码描述期望的界面状态，框架自动将描述转为虚拟DOM，使得开发人员无需直接操作DOM，降低手动管理DOM更新的复杂度。
    2. 批量计算DOM变更：应用状态改变时，框架重新渲染组件树，生成新的虚拟DOM。框架使用diff算法比较新旧虚拟DOM树差异，在内存中执行，速度快且不影响页面渲染
    3. 最小化实际DOM操作：基于diff算法结果，明确添加、删除、更新节点，将操作最小化到实际DOM节点。避免每次状态变更全量更新DOM，提升性能。
    4. 跨平台兼容性：虚拟DOM作为中间层，使得一份代码可以在多个平台运行，如浏览器、小程序、Native应用等。
3. 虚拟DOM的设计目的和工作原理：
    1. 性能优化：解决了传统直接操作DOM的性能瓶颈问题。直接操作DOM的代价高，虚拟DOM通过diff算法计算差异并在内存中执行，只在必要时更新实际DOM，提升UI更新效率；
    2. 分离关注点：虚拟DOM使开发人员专注于描述界面状态（数据驱动），而非具体的DOM操作细节。抽象层有助于提升代码的可维护性和复用性，符合现代前端工程实践中提倡的“关注点分离”原则；
    3. 简化跨平台开发：虚拟DOM作为一种通用数据结构，充当不同平台之间的桥梁。开发者只需要编写一次针对虚拟DOM的代码，框架可以将其转为适应不同环境的实际视图层操作。

# 响应式布局有几种方式？
1. 流式布局：通过使用百分比单位而不是固定像素值来定义元素的宽度，使得布局可以根据浏览器窗口或容器宽度进行伸缩。
2. 媒体查询：CSS3的特性，允许设备根据特定条件应用不同的样式。通过@media语句定义视口阈值，调整布局；
3. 响应式布局框架：Bootstrap、Foundation等提供现成的网格系统、预设断点、可响应式组件工具类，帮助开发者快速实现响应式布局。
4. 自适应布局：通过检测设备屏幕尺寸并切换到预先设计好的一套或多套布局样式。在特定断点处会发生明显的布局结构调整，如多栏变单栏、改变导航菜单样式等。
5. 移动优先布局：一种设计理念，强调首先为小屏幕或移动设备设计和开发界面，然后再逐步增强和扩展适应更大屏幕。这种方式鼓励简洁、高效的内容呈现，随后使用媒体查询为大屏幕设备添加额外的样式或功能。
6. flexbox布局：弹性盒子是CSS3引入的一种现代布局模式，用于解决复杂、灵活的布局需求而设计。
7. Grid布局：网格布局，是一种二维布局系统，提供强大的控制能力来定义网格容器及其内部项的位置或尺寸。Grid允许开发者轻松创建复杂的网格布局，包括响应式的多列布局，以及根据屏幕尺寸动态调整网格模板和间距。

# Vue的keep-alive组件如何实现，实际缓存的是什么？
1. Vue的keep-alive组件用来实现组件级别的缓存，防止在路由切换或条件渲染时，不必要的组件实例被销毁和重建，从而提高性能并保留组件的状态。
2. 实现要点
    1. 抽象组件和缓存对象
        * keep-alive是一个抽象组件（abstract：true），这意味着它自身不会渲染DOM元素，而是作为一个包装器来包裹其他组件。在组件的生命周期钩子中，特别是created阶段，它会创建一个缓存对象（如this.cache），用来存储被缓存的组件实例。
    2. 匹配规则
        * keep-alive组件提供了两个props：include和exclude，他们接受字符串或正则表达式做为值。当包裹的组件失活或激活时，keep-alive会检查组件的name属性是否与规则匹配，只有当组件名即在include里又不在exclude里，组件才会被缓存；
    3. 组件的生命周期管理
        * 当包裹在keep-alive内的组件进入视图时，如果满足缓存条件，keep-alive不会让组件经历正常的生命钩子，而是将其放入缓存中，并暂停更新。
        * 组件离开视图但被缓存，不会触发unmounted钩子，而是进入休眠状态，等待下次被唤醒。
        * 组件再次进入视图从缓存中取出，它会跳过created和mounted钩子，直接进入activated钩子，此时组件状态得以恢复，且可以在此钩子中执行必要的更新逻辑；
3. 实际缓存内容
    1. 组件实例
        * 最核心的是缓存了完整的组件实例对象，包括其所有数据属性、方法、绑定的事件处理器以及内部状态。意味着组件再次被激活时，其内部状态得以保存，无需重新初始化。
    2. DOM树
        * 缓存的组件实例关联的DOM树也会被保存在内存中，但不会渲染到页面上。组件激活时，直接复用这部分DOM，避免重新解析模板和创建DOM节点的过程。
    3. vue组件上下文
        * 缓存的组件实例还包含了其作用域内的插槽内容、子组件树、provide/inject关系等上下文信息。这些上下文在组件重新激活时保持不变，保证组件间通信和依赖关系的正确性。
    4. vue响应式依赖
        * 由于组件实例及其数据依旧存在，相关的vue反应式依赖仍然存在。当外部状态变化导致依赖更新时，被缓存的组件能够正确响应这些变化。


# vue组件中data为函数并返回对象，new Vue()时，data可以为对象
1. 组件的data必须是函数
    1. 复用性和数据隔离
        * 在vue应用中，组件是可以复用的模块，每个组件实例应当拥有自己的独立数据状态，互不影响。如果data为字面量，那么所有组件实例将会共享同一个对象，导致数据状态混乱。将data设计为函数，可以确保每个组件曾经是调用函数，返回新的数据对象，从而实现数据隔离；
    2. 实例间的独立性
        * 组件被多次使用时，每个实例需要有自己的数据副本。使用函数返回对象的方式，每次创建组件实例时都会生成一个新的数据对象实例，确保组件实例间的数据互相独立。
    3. 原型继承与观察者
        * vue使用数据响应式系统检测数据变化并自动更新视图。为了实现这一点，vue会在组件实例化时遍历data对象所有属性，对其进行依赖收集和数据劫持。如果data为字面量对象，那么直接修改其原型链会影响所有组件实例。作为函数返回的对象，原型链不会被意外修改，确保了数据响应系统的稳定运行。
2. 根实例（new Vue）的data可以是对象
    1. 单一实例
        * 根实例是应用中唯一的顶级vue实例，不存在复用情况。因此不需要像组件那样严格保证数据隔离。直接使用对象作为data属性不会引发数据共享的问题；
    2. 简化初始化
        * 应用入口点，根实例的配置通常简单直接，没有组件那样复杂性和复用需求。允许使用data对象，简化初始代码，更符合直觉；
    3. 历史沿革和向后兼容
        * vue早期版本允许根实例的data可以是对象或函数。最佳实践使用函数保持一致性。为了向后兼容和简化迁移，vue允许根实例使用对象作为data

# BFC是什么？触发BFC的条件是什么？有哪些应用场景？
1. BFC（Block Formatting Context）块级上下文，是CSS布局中一个重要概念，它规定了一组规则，决定了其内部元素如何定位、如何与外界元素互相作用。一个元素处于BFC时，它的布局和浮动行为受到一下规则约束：
    * 外部元素与内部元素边界不会重叠；
    * 包含浮动元素：BFC包含内部产生的浮动元素，使父元素高度正确计算，避免“高度”坍塌问题；
    * 阻止文字环绕：BFC中的浮动元素不会导致其后的非浮动元素围绕在周围，除非后者自己创建了BFC并选择这样做；
    * 内部块级元素垂直方向上的布局：BFC中的块级元素按照常规流从顶部到底部一次排列；

2. 触发BFC的条件
    * 根元素（html）文档根天然的BFC；
    * 浮动元素：float不为none；
    * 绝对定位元素：position为absolute或fixed；
    * display设置为特定值：
        * inline-block
        * table-cell
        * table-caption
        * flex
        * grid
    * overflow不为visible；
    * column-count或column-span特殊值：对于多列布局，当column-count设置大于1或column-span设置为all时，也会创建BFC

3. 应用场景：
    * 清除内部浮动：当父元素内部包含浮动元素，导致父元素高度坍塌，可以通过触发父元素BFC包含浮动元素，确保父元素高度计算正确，包围住所有子元素
    * 阻止外边距折叠：希望相邻元素之间外边距不发生折叠，可以创建独立的BFC，以避免外边距叠加
    * 实现两列布局：利用BFC特性，实现一侧浮动、一侧自适应的两列布局；
    * 多列布局中的分栏：使用多列时，通过触发BFC控制各栏之间的独立性，包括防止边距折叠，处理高度计算等
    * 布局隔离：利用BFC可以隔离不同区域的布局计算，防止互相干扰，确保布局稳定性；

# vue中子父组件生命周期钩子函数的执行顺序
1. 创建和挂载阶段
    * 父组件
        * beforeCreate
        * created
        * beforeMount
        * （template渲染、render函数执行）
        * 子组件
            * beforeCreate
            * created
            * beforeMount
        * 子组件的vnode插入到dom中
        * 子组件
            * mounted
        * 父：mounted
2. 更新阶段
    * 父组件
        * beforeUpdate
        * （template渲染、render函数重新执行）
        * 子组件
            * beforeUpdate
            * （template渲染、render函数重新执行）
        * 子组件
            * updated
        * 父：updated
3. 卸载阶段
    * beforeUnmount
    * 子组件
        * beforeUnmount
        * 子组件的vnode从dom中移除
        * unmounted
    * 父：unmounted

4. 注意事项
    * 同步执行：生命周期钩子函数时同步执行的，即执行完一个钩子函数，才会执行下一个钩子函数；但设计异步操作时，虽然钩子函数本身同步，但内部的异步任务可能在后续的钩子函数执行完毕才执行。
    * 异步组件：对于异步组件（懒加载组件），其生命周期钩子的执行稍有延迟，直到组件被解析、加载完成后才会触发相应的生命周期钩子。
    * 深度嵌套：如果有深层次嵌套子组件，生命周期钩子的执行顺序遵循上述规律，即先执行最外层父组件的相应钩子，然后逐级深入到子组件，再从最深的子组件逐级返回父组件
    * 条件渲染：如果使用v-if/v-show控制子组件的渲染，对应的生命周期钩子仅在条件满足时才会执行，否则这些钩子函数不会触发。

# Tree-Shaking的工作原理
Tree-Shaking是一种优化技术，用于去除js应用程序中未被实际引用的死代码，从而减少最终打包文件的大小，提升加载速度和资源利用率。关键步骤如下：
1. 静态模块解析：
    * Tree-shaking主要是使用es模块规范的项目，因为esm具有静态导出和导入的特点，编译时可以判断模块间的依赖关系；
    * 编译工具在构建过程中会对源代码进行静态分析，构建依赖图，在这个过程中，工具会追踪每个模块的导入和导出声明，确定哪些模块、函数、变量被其他模块明确引用；
2. 死代码检测：
    * 在依赖图构建完成后，编译工具会分析哪些模块成员未被任何导入者直接或间接使用。未被引用的代码称为“死代码”。因为他们在运行时不会对程序产生任何影响；
    * 工具通过静态分析源代码的控制流和数据流，确保没有潜在的动态引用模块成员及其依赖。同时考虑副作用，即那些未被直接引用但可能改变了全局状态或执行了某些操作的代码片段；
3. 代码消除：
    * 发现死代码后，编译工具在生成最终打包文件时，会剔除这些未被引用的模块成员及其依赖。实际上，这意味着不会将这些死代码对应的AST节点纳入最终的输出代码中；
    * 对于具有副作用的模块。如果确认其没有任何导出被使用，也可能整个模块都被排除。但对于仅有副作用而无导出的模块，如果不特别配置，通常会被保留以确保副作用被执行。
4. 压缩优化
    * 在剔除死代码后，编译工具通常会进行进一步压缩和优化，如删除冗余空白、短路表达式优化、变量名混淆等，进一步减小文件大小；


# js继承的理解
js中继承主要涉及如何让一个对象（子类或派生类）获得另一个对象（父类或基类）的属性和方法。由于js是一种基于原型的语言，其继承机制主要依托原型链和构造函数来实现。以下是几种常见的js继承原理和方法：
1. 原型链继承
    * 原理：每个js对象都有一个__proto__属性，它指向创建该对象的构造函数的prototype属性。当试图访问一个对象的属性或方法时，如果该对象本身没有定义，js会沿着原型链向上查找直到null
    * 通过将子类的原型（prototype）设置为父类的一个实例，时子类的实例能够通过原型链访问到父类的属性和方法；
    ```js
    function Parent() {
        this.parentProperty = "parentValue";
    }

    Parent.prototype.parentMethod = function() {
        console.log("parentMethod");
    }

    function Child() {
        this.childProperty = "childValue";
    }
    Child.prototype = new Parent();
    Child.prototype.childMethod = function() {
        console.log("childMethod");
    }
    let childInstance = new Child();
    childInstance.parentProperty;
    childInstalce.parentMethod();
    childInstance.childMethod();
    ```
2. 构造函数继承
    * 原理：通过在子类的构造函数内部调用父类的构造函数，将父类的属性和方法复制到子类实例上。
    * 实现：通过call或apply方法调用父类构造函数，传递子类实例作为this上下文；
    ```js
    function Parent(name) {
        this.name = name;
        this.parentProperty = "parentValue";
    }
    function Child(name, age) {
        Parent.call(this, name);
        this.age = age;
    }
    let childInstance = new Child("John", 30);
    childInstance.name;
    childInstance.parentProperty;
    ```
3. 组合继承（原型链+构造函数）
    * 原理：结合原型链继承和构造函数继承的优点，即避免了原型链继承中父类属性在所有实例中共享问题，又避免构造函数继承中方法重复定义的问题。
    * 实现：在子类构造函数内部调用父类构造函数（构造函数继承），同时将父类的原型赋值给子类的原型（原型链继承）
    ```js
    function Parent(name) {
        this.name = name;
        this.parentProperty = "parentValue";
    }

    Parent.prototype.parentMethod = function() {
        console.log("parentMethod");
    }

    function Child(name, age) {
        Parent.call(this, name);
        this.age = age;
    }

    Child.prototype = Object.create(Parent.prototype);
    Child.prototype.constructor = Child;
    Child.prototype.childMethod = function() {
        console.log("childMethod");
    }
    let childInstance = new Child("John", 30);
    childInstance.name;
    childInstance.parentProperty;
    childInstance.parentMethod();
    childInstance.childMethod();
    ```
4. Class + Extend关键字
    * 原理：ES6引入了class关键字，通过class关键字可以更清晰地描述继承关系，同时支持私有属性和方法。
    ```js
    class Animal {
        constructor(name) {
            this.name = name;
        }

        speak() {
            console.log(`${this.name} makes a noise.`);
        }
    }

    class Dog extends Animal {
        constructor(name, breed) {
            super(name);
            this.breed = breed;
        }
        bark() {
            console.log(`${this.name} barks.`);
        }
    }
    let myDog = new Dog("Buddy", "Labrador");
    myDog.speak();
    myDog.bark();
    ```
    * extend实际上只是原型链继承的封装，底层仍原型链系统

# 10个资源放在1一个域名下加载和十个域名下加载的，区别在哪？

1. 浏览器并发限制：
    * 单域名：现代浏览器对同一个域名下的并行请求数量有限制，通常为6-8个，超过的请求会被排队等待，可能导致页面加载速度变慢，尤其是对于包含大量静态资源的网页，这种限制可能会称为性能瓶颈；
    * 多域名：通过将资源分散到多个域名下，可以绕过浏览器并发限制，每个域名可以独立发起多个并行请求，从而加快整体资源的下载速度。这种方法适用于大型网站或高流量应用，他们需要快速加载大量资源提升用户体验；
