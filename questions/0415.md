# vue的自定义指令
1. 定义：vue提供的，允许开发者创建自己特殊行为扩展标准HTML元素的功能，以满足特定应用需求。自定义指令可以用于封装底层的DOM操作逻辑，使其在多个组件或整个项目中得以复用。Vue自定义指令通常以v-前缀开始，与内置指令保持一致。
2. 创建自定义指令
    * 全局自定义指令：在项目的入口文件中，通过vue.directive方法，注册一个全局指令；
    ```js
    Vue.directive('my-directive', {
      bind: (el, binding,, vnode) {},
      inserted: (el, binding,, vnode) {},
      update: (el, binding,, vnode) {},
      componentUpdated: (el, binding,, vnode) {},
      unbind: (el, binding,, vnode) {}
    })
    ```
    * 局部自定义指令：在单个组件的选项中定义
    ```js
    export default {
      directives: {
        'my-directive': {
          bind: (el, binding,, vnode) {},
          inserted: (el, binding,, vnode) {},
          update: (el, binding,, vnode) {},
          componentUpdated: (el, binding,, vnode) {},
          unbind: (el, binding,, vnode) {}
        }
      }
    }
    ```
3. 自定义指令钩子函数
    1. bind: 调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
    2. inserted：元素被插入到父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。
    3. update：所在组件的VNode更新时调用，但元素本身可能并未改变。常用于更新依赖于VNode数据的DOM属性或样式；
    4. componentUpdated：指令所在组件的VNode及其子组件的VNode更新时调用。
    5. unbind：调用一次，指令于元素解绑时调用。在此清理指令添加的所有事件监听器和数据绑定。
  
4. 常见的自定义指令示例
    1. 焦点管理：创建一个v-focus指令，当绑定元素渲染完毕时，自定获取焦点；
    2. 文本选择：实现v-select-text指令，使文本输入框或文本区域的内容在加载时即被选中；
    3. 拖拽功能：通过v-draggable指令，为元素添加拖拉交互，处理拖动开始、移动、结束等事件；
    4. 图片懒加载：创建v-lazy-image指令，根据元素进入视口时触发图片加载，优化页面性能；
    5. 表单验证：实现v-validate指令，结合自定义规则验证对表单字段进行实时验证并显示错误提示；
    6. 滚动监听：实验v-scroll-watch指令监听元素滚动事件，触发相应行为，如无限滚动、滚动定位等。
    7. 元素尺寸调整：创建v-resize指令监听元素滚动事件，触发相应的行为，如无限滚动加载，滚动定位导航等；
    8. 复制文本：实现v-copy-text指令，用户点击元素时将指定文本复制到剪切板；

# 图片预加载的理解？
1. 目的
    * 提升加载速度：预加载可以减少后续页面渲染或交互时的等待时间，使内容快速呈现在用户眼前，提升页面的响应速度和整体流畅度；
    * 防止内容空白或闪烁：对于关键的视觉元素，预加载可以避免因图片加载延迟导致的暂时性内容空白或布局跳跃，提供更连贯的视觉体验。
    * 留住用户注意力：快速加载更可能留住用户注意力，降低因加载时间过长导致的用户流失率；
2. 实现原理
    * 利用浏览器缓存机制：预加载本质上是利用浏览器的缓存机制，通过提前发起HTTP请求获取图片资源，并将其存储在浏览器缓存中。后续使用图片时，可以直接从缓存中读取，无需再次发起网络请求。
    * 异步加载：预加载通常是异步进行的，不会阻塞页面渲染。通过Image对象设置src属性，监听onload事件判断加载完成；
3. 技术实现方式
    * HTML link标签：在head部分使用link ref=preload标签，指定as=image属性来预加载图片。这种方法利用浏览器原生支持的预加载功能，有助于指示浏览器优先加载指定资源。
4. 策略与注意事项
    * 按需预加载：并非所有图片都需要预加载，应根据业务和图片的重要性选择性预加载；
    * 资源优先级：合理安排预加载的顺序，优先加载关键资源；
    * 响应式设计：考虑不同设备和屏幕尺寸下的图片需求，加载不同分辨率图片；
    * 加载进度反馈：对于大型或多图的预加载，可以配合加载进度条或提示信息，让用户了解加载进程，提升感知速度；


# 使用AudioContext播放音频的步骤？
1. 创建AudioContext实例
```js
const context = new AudioContext();
```
2. 从context创建AudioBufferSource实例
```js
const source = context.createBufferSource();
```
3. 关联source和context
```js
source.connect(context.destination);
```
4. 从buffer解析音频数据
```js
const audiodata = context.decodeAudioData(audioBuffer);
```
5. 绑定音频数据
```js
source.buffer = audiodata;
```
6. 播放音频
```js
source.start(0);
```

# 实时音频数据收集的步骤？
1. 创建音频上下文
```js
const audioContext = new AudioContext({
  sampleRate: 16000
});
```
2. 创建媒体流资源
```js
const source = audioContext.createMediaStreamSource(stream);
```
3. 创建采样点
```js
const scriptProcessor = audioContext.createScriptProcessor(4000, 1, 1); // 4000/16000=0.25s
```
4. 媒体源链接采样点
```js
source.connect(scriptProcessor);
scriptProcessor.connect(audioContext.destination);
```
5. 监听采样点进程函数
```js
scriptProcessor.onaudioprocess = (e) => {
  // 获取采样的pcm数据
  const pcmData = e.inputBuffer.getChannelData(0);
  // 数据转换为Float32Array
  const intData = new Float32Array(pcmData.length);
  for (let i = 0; i < pcmData.length; i++) {
    intData[i] = pcmData[i];
  }
  // 获取buffer
  const buffer = intData.buffer;
  // 传递给回调函数进行处理
  callback(buffer);
}
```

# 浏览器的渲染过程？
1. 接收和解析HTML
    * 请求服务器 -> 获取HTML
    * 渲染引起接收HTML文本流，启动HTML解析器对其进行解析
    * HTML解析器按照HTML规范从上到下，从左到右读取字符流，构建DOM树。DOM树是一个基于内存的树状结构，表示文档的元素及其嵌套关系，每个节点代表一个HTML元素。
2. 解析CSS
    * 渲染引起同时解析HTML中对CSS的引用；
    * 使用CSS解析器将CSS文本解析问CSSOM（CSS Object Model）树，表示了CSS规则及其对应的样式属性；
    * CSSOM树构建过程中，遵循CSS的层叠和集成机制，计算出每个元素的最终样式；
3. 构建渲染树
    * DOM树和CSSOM树构建完毕后，渲染引擎将它们合并为渲染树。渲染树只包含可见元素；
    * 渲染树构建完成后，遍历DOM树节点，为每个节点找到对应的CSSOM节点，组成带有内容和样式的渲染对象；
4. 布局
    * 由渲染树，计算每个节点在浏览器视口内的确切几何为何和尺寸，这个过程称为布局或重排；
    * 布局算法根据渲染树节点的盒模型、定位方式以及CSS FlexBox或Grid布局规则，计算出每个节点的坐标和大小；
5. 绘制
    * 布局完成，渲染引擎进入绘制阶段。按照渲染树的节点顺序，使用GPU或CPU将节点内容绘制到内存中的位图上。
    * 绘制过程可能涉及多个绘制层，如复杂的动画、3D变换、遮罩、混合模式等元素会被提升到单独的合成层，以便独立渲染和高效合成。
6. 合成和显示
    * 对于多图层场景，浏览器使用compositor线程，将各图层合成在一起，形成最终的可视画面；
    * 合成操作利用硬件加速，将图层作为纹理上传到GPU，然后通过图形管道进行混合、裁剪、透明度处理等操作；
    * 最后，合成好的帧被发送到浏览器窗口进行显示；
7. 响应用户交互于重绘/重排
    * 用户与网页交互，可能导致DOM或CSSO发生变化，进而触发部分或全部渲染过程的重新执行；
    * 重绘指元素外观改变但不影响布局时，只需要更新绘制操作；
    * 重排指元素几何属性或布局环境变化，需要重新计算布局并可能引发后续的绘制。

# reft的源码实现概括
1. createRef工厂函数
    * 定义一个名为createRef的工厂函数，用于创建响应式引用对象
    * 函数接受一个初始值作为参数
2. 包装值
    * 基本类型：直接保存为ref对象的value属性
    * 引用类型：使用reactive将其转为响应式对象，然后保存为ref对象的value属性
    * ref实例：已经是ref实例，直接返回，避免重复包装
3. 响应式对象构造
    * 创建一个响应式对象（RefImpl类的实例），该对象包含以下属性和方法：
        * __v_ifRef: 标记为true，表示时Ref实例
        * __rawValue: 保存未经包装的原始值
        * _value: 保存包装后的值
        * get value(): 返回_value，在访问时触发依赖收集
        * set value(newValue)：设置_value为newValue，触发值的变更的派发更新；
4. 依赖收集
    * 在value属性的get访问器中，调用vue内部的依赖收集API，将当前活跃的副作用与ref关联起来
5. 派发更新
    * 在value属性的set访问器中，当值发生变化时，调用vue内部的派发更新api，通知所有依赖于这个ref的副作用函数进行更新；
6. 解包（Unwrapping）
    * vue的模板编译阶段，编译器识别并处理ref变量，确保模板表达式可以直接使用ref变量，如同普通变量一样。这是通过编译器插件实现的。
7. unref和toRef辅助函数
    * unref函数用于从ref实例中提取原始值，主要用于在需要非ref值的场景下使用；
    * toRef函数用于将一个响应式对象的一个属性转为ref实例，便于在需要ref值的场景下使用。

# reactive源码实现概括
1. reactive工厂函数
    * 定义名为reactive的工厂函数，用于创建响应式对象
    * 函数接受一个待转换的普通对象作为参数
2. 对象代理
    * 使用Proxy API创建一个代理对象，目标对象为传入的普通对象；
    * 代理对象用于拦截原始对象的所有操作（读取、设置、删除等），并在此基础上添加响应式逻辑；
3. 响应式状态管理
    * 为每个响应式对象维护一个内部状态，用于标记对象的响应式状态、跟踪操作类型、触发更新操作类型等；
4. 依赖收集
    * 在代理对象的get拦截器中，当对象访问属性时，调用内部Vue的依赖收集API，将当前活跃的副作用与访问的属性关联起来；
5. 派发更新
    * 在代理对象的set、deleteProperty等拦截器中，当修改或删除对象属性时，调用vue内部的派发更新api，通过所有依赖这个属性的副作用函数进行更新；
6. 深度响应式
    * 当对象为嵌套对象时，递归将其转为响应式对象；
    * 对于数组，还需要额外处理数组索引的读写、数组长度变化、数组方法的拦截与重写以保持响应式
7. 副作用调度
    * 触发更新时，不是立即执行所有依赖的副作用函数，而是将更新任务加入到一个全局的调度队列中；
    * 调度队列会按照一定策略异步执行这些更新任务，以提高更新效率避免过度同步更新导致的性能问题；
8. readonly和shallowReactive辅助函数
    * readonly用于创建只读属性的响应时对象，对对象的修改操作会抛出错误；
    * shallowReactive函数用于创建浅层响应式对象，仅对对象的第一层属性进行响应式处理，内部嵌套对象的属性变化不会触发响应式系统的更新。


# 301，302，304，307各自的意义
1. 301
    * 意义：永久重定向；这个状态码告知了客户端，旧的URL不再有效，搜索引起和其他自动化工具也会更新索引指向新的URL；
    * 应用场景：网站改版、域名更换、URL规范、目录结构调整等情况，需要将旧URL永久重定向到新的URL；
2. 302
    * 意义：临时重定向；旧URL仍然有效，只是当前URL访问被临时导向另一个URL上。客户端应当继续使用原有URL进行后续请求，除非接收到明确指示；
    * 应用场景：临时性页面跳转，多语言版本切换，A/Btest，根据用户地理位置或设备类型多态提供内容的场景中。
3. 304
    * 意义：协商缓存；当客户端发送带有if-modified-since或if-none-match请求头GET请求时，若服务器判断所请求的资源自指定时间以来未发生变更（或Etag未变），则返回304状态码，此时服务器不返回资源内容，仅告知客户端可以继续使用基本缓存副本；
    * 应用场景：客户端缓存管理，减少不必要传输，提高响应速度。当浏览器或其他客户端已有缓存资源且服务器资源是否更新时，服务器通过304响应告诉客户端无需重新下载，继续使用缓存；
4. 307
    * 类似302，强调在重定向过程中请求必须保持原始方法不变；与302的主要区别在于，307要求无论原始请求是什么方法（POST、PUT），重定向都必须使用相同的方法向新的URL发出；
    * 应用场景：在需要保持请求方法不变的情况下进行临时重定向，以遵守HTTP标准关于重定向行为的规定。

# 浏览器有哪些进程，渲染进程有哪些线程？
1. 浏览器主进程
    * 负责浏览器界面的显示、用户交互、网络请求管理、文件访问等；
    * 控制和协调其他所有进程，如创建和销毁渲染进程、与操作系统交互等；
    * 处理浏览器标签页、地址栏、书签、扩展等UI相关的任务；
2. 渲染进程
    * 每个浏览器标签页通常对应的一个独立渲染进程、用于解析和渲染网页内容；
    * 负责指向HTML、CSS和JS代码，构建和维护DOM树，以及最终的渲染树。
    * 指向布局、绘制、合成等操作，将网页内容呈现在屏幕上；
    * 处理网页的交互事件和多媒体播放等；
3. GPU进程
    * 用于图形处理器通信，进行高效的图形计算和渲染；
    * 主要负责硬件加速和图形渲染、视频解码等工作，尤其是在进行复杂的2D/3D图形渲染，动画和webgl内容时；
4. 网络进程
    * 负责处理所有浏览器进程的网络请求，如DNS查询、TCP了解、HTTPS握手、数据收发等；
    * 实现资源共享，避免同一站点的多个标签页重复建立网络连接；
5. 插件进程
    * 对于使用NPAPI或PPAPI的插件，每个插件实例通常在一个单独的进程中运行，确保插件崩溃不会影响主进程或渲染进程；
6. 服务进程（Service Worker进程）
    * 用于承载服务工作者脚本，支持离线缓存、后台数据同步、推送通知等功能；
    * 服务进程时独立于渲染进程的，可以在没有页面活动的情况下持续进行；

