# web-interview

## HTML
  1. doctype的作用：声明文档类型，告诉浏览器使用什么文档标准解析文档。
  2. 怪异模式和标准模式  
    1. 怪异模式：盒模型为width+margin  
    2. 标准模式：盒模型为width+margin+padding+border
  3. href和src的区别：  
    1. href指超文本引用，并行下载但不阻塞页面解析  
    2. src指资源，浏览器遇到src时，会暂停页面解析直到资源下载或执行完毕
  4. SVG和Canvas的区别：  
    1. SVG以xml格式定义图像的可伸缩矢量图形；  
    2. Canvas通过JS绘制2D图形；
## CSS
  1. 清除浮动的方法  
    1. 额外标签法  
    2. 父级元素BFC法  
    3. 使用after伪类
    4. 使用before和after双伪类

## JavaScript
1. Promise解决的问题：传统异步编程中的回调地狱问题；promise是基于观察者模式实现的，即收集依赖 -> 触发通知 -> 依赖执行 的模式。
2. 关于继承？
  * 原型链继承：直接让子类的原型对象指向父类实例。
      * 缺点：(1)所有子类实例的原型均指向同一个父类实例对象，对某个子类实例对象的父类引用类型变量的修改会导致所有子类实例受到影响；(2)创建子类实例无法向父类实例构造传参，即缺少super功能；  
  * 构造函数继承：子构造函数中执行父构造函数并绑定子构造函数this对象，将父类的成员属性绑定在子类this上，能避免所有子类实例贡献同一个原型实例且能够向构造函数传参；
      * 缺点：(1)继承不到父类原型上的方法和属性。
  * 组合式继承：同时使用原型链集合和构造函数继承。
      * 缺点：(1)创建子类实例执行两次的构造函数，并且子类实例存在两份原型对象的变量和函数定义；
  * 寄生式组合继承：在组合式继承中将子类原型对象指向父类的原型，解决了两次构造函数的问题；
      * 缺点：(1)对子类原型的操作会影响父类原型，因此需要对父类原型做一次浅拷贝。
3. for...of 和 for...in的区别？  
  （1）for...of遍历中获取的是值，且可以随时break跳出；    
  （2）for...in遍历中获取的是键，但无法随时break跳出；  
4. 设计模式：  
    1. 单例模式：一个类只能存在一个实例对象，如vuex的store
    2. 工厂模式：对创建对象的逻辑进行封装的操作，如$(selector)
    3. 观察者模式：对象的修改会自动通知依赖对象，如vue的双向数据绑定  
    4. 装饰器模式：对类进行封装，动态扩展类的功能，如ES7装饰器
    5. 适配器模式：兼容新旧接口，对类的包装，如封装就API
    6. 代理模式：控制对象的访问方式，如ES6的Proxy
5. Number(null) = 0 ; Number(undefined) = NAN;
6. 事件流指从页面中接收事件的顺序，按照  捕获 -> 目标 -> 冒泡 的阶段进行；
7. typeof 和 instanceof 的区别：(1)typeof用于检测变量类型，基本类型中除null以外均显示对应的数据类型，引用类型除了函数类型显示function意外，其余都显示object类型；(2)instanceof用于检测某个构造函数的原型对象在不在某对象的原型链上。
8. 构造函数：任意一个普通函数用于创建一个对象时，他就可称为构造函数或构造器；（ps：函数是一等公民）
9. 闭包  
    1. 作用域规则：内部函数总可以访问其外部函数中声明的变量；
    2. 定义：当通过调用一个外部函数返回一个函数后，即使外部函数已经执行结束，但内部函数引用外部函数的变量依然保存，这些变量的合集称之为闭包；即A中存在函数B，函数B引用A中的变量，B称为A的闭包；
    3. 好处：缓存变量不被回收，以及实现柯里化；
    4. 坏处：(1)内存消耗问题，闭包的变量无法被回收；(2)性能问题，由于闭包的作用域优先级高于外部，所以需要多查找一个作用域链层次，一定程度上影响查找速度；
10. this永远指向最后调用它的对象；
    1. 普通函数中this指向执行上下文
    2. 箭头函数中this实现定义时上下文
    3. JS的严格模式下，默认执行一个函数时，其内部的执行上下文中this值为undefined
11. 异步的演进：callback -> promise ->  generator -> async/await
12. Promise的执行过程
    1. Promise是对象是一个构造函数，用来生成promise实例
    2. new Promise传入一个函数，该函数有两个参数resolve和reject
    3. resolve将“未完成”变成“成功” pending -> fulfilled
    4. reject 将“未完成”变成“失败” pending -> rejected
    5. 未执行resolve或reject前状态为pending
    6. promise实例中的状态一经改变不能再更改
13. 复制：复制基本数据类型时是拷贝值，复制引用复杂数据类型时是拷贝地址；
    1. 浅拷贝（Object.assign、数组的API如concat、slice等）
    2. 深拷贝（JSON.parse(JSON.stringify)、$.extend(true,obj)，_.cloneDeepWith(obj)
14. call、apply、bind的区别？
    1. call改变函数的指向，第一参数为改变的指向对象，后续为传参；
    2. apply前者同call，后者传参未数组；
    3. bind改变this的作用域后返回新的函数，不会立即执行；
15. 防抖：频繁触发的情况下，只在任务触发间隔超过设定的事件范围才执行；
    1. 设置定时器；
    2. 返回闭包；
    3. 如果反复进来，则清除定时器，重设执行函数
16. 节流：指定时间间隔内只执行一次任务；
    1. 设置标记；
    2. 返回闭包，更改标记；
    3. 若重复进入则跳过；
    4. 若执行完成则清楚标记；
17. JSONP原理：利用script的src没有跨域限制实现跨域。
    1. 前端定义解析函数：jsonpCallback = function () {}
    2. 通过params形式包装script标签请求参数并声明执行函数，如cb=jsonpCallback
    3. 后端获取声明的执行函数并带上参数和调用方式返回给前端
    4. 前端在script标签返回资源时执行jsonpCallback回调获取数据  
    优缺点：[优点]兼容性好，[缺点]只允许使用GET方法
18. CORS原理：允许浏览器向服务端发送请求，前提是浏览器支持且服务端同意跨域请求（服务端请求头中需设置Accept-Contorl-Allow-Origin）


## 浏览器
### Event Loop (事件循环机制)
  1. 单线程：同一时间内只能做一件事。（若使用多线程，当多个线程对dom进行操作时，以哪个线程为准将称为问题，因此使用单线程）单线程的存在意味着任务执行队列的存在，任务排队执行。
  2. 任务的分类  
    1. 同步任务：主线程上排队执行的任务，只有前一个执行完成，才执行后一个任务；  
    2. 异步任务：不进入主线程执行，而进入“任务队列”中的任务，只有主线程空闲后，“任务队列”通知主线程某个异步任务可以执行，该任务才会进入主线执行；  
    3. 微任务：Promise.then/catch/finally、Object.observe(监听标准对象的变化)、process.nextTick(仅在node中)  
    4. 宏任务：所有非微任务都归为宏任务，如script、setTimeout、setInterval等。
  3. 事件循环：  
    1. 同步任务在主线程上执行，形成执行栈；  
    2. 在主线程外开辟一个“任务队列”，当异步任务有结果后，在“任务队列”中放置事件  
    3. 一旦主线程完成，就向“任务队列”中取出放置的事件，执行对应的回调函数（异步任务）  
    4. 异步任务放入主线程后，重复循环3    
    总结：主线程从“任务队列”中读取事件，不断循环的运行机制。  
    主线程运行时，产生堆和栈，栈中调用各种API在“任务队列”中放入各种事件，主线程完成，读取"任务队列"，依次执行事件对应的回调函数。
  4. Javascript runtime：指JS的执行环境。js执行时创建主线程和调用栈，所有任务都会放入调用栈等待主线程执行。
  5. 事件循环（解释2）：  
    1. 主线程从上而下一次执行；  
    2. 同步任务放入主线执行；  
    3. 异步任务放入Event Table，当结果返回，对回调函数进行注册并放入Event Queue；  
    4. 主线程空闲后，从任务队列中读取任务，放入主线程执行；  
    5. 放入主线程的任务从1开始循环
  6. 跨域问题（只存在于客户端）：指请求URL的协议、域名、端口三者任意一个不与当前页面的URL相同的去请求；有效的解决方法有：(1)JSONP;(2)CORS;(3)代理服务器;(4)解除浏览器限制;
   
### 渲染机制
  1. 渲染过程？  
    1. HTML和CSS经过解析，分别形成DOM树和CSS规则树；  
    2. DOM树和CSSOM树合并成渲染树；  
    3. 根据渲染树形成布局渲染树；  
    4. 根据布局渲染树，调用GPU进行绘制，显示在屏幕上。
  2. 如何减少回流：(1)使用class代替style；(2)监听resize和scroll等会引起回流的事件是进行防抖和节流；(3)使用visibility代替display（前者只重绘，后者会回流）；(4)批量修改dom元素时应脱离文档流进行操作；

### 缓存策略  
  1. 强缓存：不需要向服务器进行请求（在f12控制台中显示为memory cache或disk cache）  
  2. 协商缓存：需要向服务器询问是否过期，请求头中携带if-modify-since，若过期则返回200，否则返回304(Not Modify)

### 前端存储
  1. cookie：HTTP请求时会自动携带在请求头中，兼容性好，大小只有4kb
  2. localStorage：持久性存储，关闭页面依旧存在，以键值对的形式存储，大小5MB
  3. sessionStorage：会话期存储，关闭页面后销毁，以键值对的形式存储，大小5MB，不同选项卡之间不互通

### 从输入URL到页面呈现发生了声明？
执行顺序：DNS解析 -> TCP链接 -> 发送HTTP请求 -> 服务端响应数据 -> 浏览器解析渲染页面
1. DNS解析过程：通过网络查找哪台服务器有所需要资源的过程。执行过程：(输入baidu.com)查询域名 -> 客户端缓存(按顺序分别是浏览器缓存、系统缓存、路由器缓存) -> 访问互联网服务提供商DNS服务器(若存在缓存则直接返回) -> 本地资源根服务器 -> 本地咨询.com顶级域名服务器 -> 本地咨询baidu.com主域名服务器 -> 本地服务通知用户IP并进行缓存
2. TCP连接：建立客户端与服务端的连接（3次握手） -> 传输数据 -> 断开客户端与服务端的连接（4次挥手）
3. HTTP请求：构建HTTP请求报文，并通过TCP协议发送到服务器指定端口；
4. 服务器响应：服务器处理请求完毕后，返回HTTP响应报文；
5. 浏览器渲染解析页面：解析HTML生成DOM树 -> 解析CSS生成CSS规则树 -> 将DOM树与CSS规则树结合生成渲染树 -> 从根节点开始计算每一个元素的大小和位置得到渲染树的布局渲染树 -> 遍历渲染树，调用UI渲染引擎绘制渲染树呈现页面；

## Vue
  1. vue的生命周期定义？  
  vue实例从创建到销毁的整个过程，就是生命周期；即vue实例从开始创建、初始化数据、编译模板、挂载DOM -> 渲染、更新->渲染、销毁的一系列过程，称之为vue的生命周期。
  2. vue生命周期的作用？  
  vue在它的生命周期过程中有多个事件钩子函数，可以让我们更好地控制vue实例整个生命周期过程中的处理逻辑。
  3. vue生命周期公共有几个阶段极其对应的钩子函数？  
  8个阶段，分别是：  
  创建前（beforeCreate）：在实例初始化之前，el和data未初始化，此时this无法使用，data、methods、watcher等无法使用  
  创建后（created）：完成data的初始化，el未初始化，此时可以使用vue实例中的数据以及各种方法，但无法对dom节点进行操作  
  挂载前（beforeMount）：完成el的初始化（此时el是虚拟dom）  
  挂载后（mounted）：完成dom节点的挂载，可在这里发起后端请求，拿回数据配合路由钩子等进行业务处理  
  更新前（beforeUpdate）：在view层数据变化前触发，而不是data中数据改变前触发  
  更新后（updated）：在view层数据变化之后  
  销毁前（beforeDestroy）：可在此处进行确认是否删除实例（组件）操作，仍可以使用this、data和各种方法    
  销毁后（destroyed）：当前组件（实例）已销毁，相关内容皆无法使用  
  4. vue第一次加载页面会触发哪几个钩子函数？  
  第一次加载一定会触发beforeCreated、created、beforeMount、mounted
  5. DOM渲染在哪个周期完成？  
  DOM渲染在mounted中挂载到页面上，此时可以获取到dom元素
  6. v-show和v-if的区别？  
  v-show是css切换，v-if包含完成的创建和销毁过程  
  使用频繁使用v-show，较少改变使用v-if  
  v-if是条件渲染，当值为false时不会渲染，即页面不存在该dom元素(及其子元素)  
  v-show不管是true还是false，dom元素都存在，只是css的display在none和block间切换  
  7. MVVM  
  M - model，代表数据模型，可以在model中处理数据业务逻辑  
  V - view，代表视图，负责将数据模型在UI中显示出来  
  VM - viewmodel，负责监听模型数据的改变以及控制视图行为、处理用户交互，即同步view和model的对象  
  8. computed和watch的差别  
  computed是计算属性：（1）可以缓存，只有当它依赖的属性值改变后，下一次获取computed值时重新获取值并缓存起来；（2）无法进行异步操作；（3）适用于计算比较消耗性能的场景，（4）若为函数，则默认使用get方法，若为配置对象，属性支持get和set方法，当数据变化时使用set方法，当获取数据是使用get方法  
  watch起到观察的作用：（1）无缓存，页面渲染时值不变也会执行；（2）可以执行异步操作；（3）监听函数由两个参数；（4）监听数据必为data或props中的属性。  
  9. vue的两个核心？  
  数据驱动：Object.defineProperty和存储器属性getter和setter，可称为基于依赖收集的观测机制，核心是VM，保证数据和视图的一致性；  
  组件系统
  10. vue单页面的优缺点？  
  缺点：  
    * 不支持低版本浏览器，最低支持IE9；  
    * 不利于seo的优化；（需通过服务端渲染）；  
    * 第一次加载首页耗时长；  
    * 不可以使用浏览器的导航按钮，需要自行实现前进、后退；  
  优点：  
    * 无刷新体验，提升用户体验；  
    * 不再以页面为单位进行开发，更多采用组件化思想，代码结构和组织方式更为规范化，便于修改和调整；  
    * api共享，同一套后端程序代码不用修改就可以用于web、手机、平板等多端；  
    * 用户体验好、快，内容的改变不需要加载整个页面；
  11. MVC和MVVM的区别？  
  MVC：MVC中各部分通信时单向的，View指令发送到Controller中处理业务逻辑，在由Controller通知Model改变状态，Model最后将数据发送到view，用户得到反馈；MVC中关注的时M的不变，但时View依赖M；  
  MVVM：各部分的通信是双向的，采用双向数据绑定的模式，View变动，自动反映在Model上，反之亦然；MVVM在概念上是真正将视图与数据逻辑分离的模式。
  12. Vue的双向数据绑定原理？  
  Vue的双向数据绑定是通过数据劫持结合发布订阅模式实现的，即数据和视图同步更新；Vue双向数据绑定的核心是Object.defineProperty()中劫持属性中的getter和setter方法，在数据变动时，发布消息给订阅者，订阅者触发相应的监听回调。
  13. Vue-Router的实现原理？  
  （1）hash模式：基于浏览器的hash变化不会重新加载页面以及浏览器暴露了hashchange监听事件，每次hash变化都会增加历史纪录；  
  （2）history模式：HTML5增加了新的操作API：pushState和replaceState可以对浏览器历史记录栈进行修改，该方法可以修改浏览器历史记录栈，当前的URL改变浏览器不会立即发送请求。
  14. diff算法：用来计算虚拟dom中被改变的部分，然后针对该部分进行原生dom操作，而不用重新渲染整个页面的算法。

## Webpack
  1. webpack的作用  
  （1）依赖管理：方便引用第三方模块、让模块更容易服用，避免全局注入冲突、避免重复加载或加载不需要的模块。  
  （2）合并代码：将分散的模块集中打包成大文件，减少HTTP的请求链接数，配合UglifyJS可以减少、优化代码的体积。  
  （3）管理插件：统一处理引入的插件，babel编译ES6文件，eslint可以检查编译期的错误。  
  总结：webpack的作用是处理依赖、模块化、打包压缩文件、管理插件
  2. webpack的工作过程  
  （1）解析配置参数，合并命令行和webpack.config.js文件的配置信息，输出最终的配置信息；  
  （2）注册配置中的插件，让插件监听webpack构建生命周期中的事件节点，做出相应的反应；  
  （3）解析配置文件中的entry入口文件，找出每个文件依赖的文件，递归执行；  
  （4）在递归文件的过程中，根据文件类型和配置文件中的loader找出对应的loader对文件进行转换；  
  （5）递归结束后得到文件最终的结果，根据entry配置生产代码chunk；  
  （6）输出chunk到文件系统。

## HTTP协议
  1. 常见的HTTP状态码  
    1. 200：客户端请求服务端正常响应  
    2. 301：永久重定向，请求网页永久移动到新位置  
    3. 302：临时重定向，请求网页临时移动到新位置  
    4. 304：未修改，自上次请求后网页内容未进行过修改  
    5. 400：客户端请求错误，服务端无法解析语法，常见于客户端传参错误  
    6. 401：未授权，客户端请求需HTTP认证信息，常见于客户端未登录鉴权  
    7. 404：未找到资源，客户端请求资源在服务器上不存在  
    8. 500：服务器内部错误  
    9. 502：网关错误
  2. GET和POST的区别？（核心区别时GET请求是幂等的，而POST不是）使用上的区别见如下：  
    1. GET请求参数放在URL上，而POST放在请求体里；  
    2. GET请求参数有大小限制，而POST趋于无限大；  
    3. POST相比GET安全，因为GET请求信息直接显示在URL上，而POST在请求体里；  
    4. GET请求可以缓存，而POST不能
  3. HTTP和HTTPS的区别？  
    1. HTTP默认使用80端口，而HTTPS默认使用443端口；  
    2. 使用HTTPS需要申请证书；  
    3. HTTP是超文本传输协议，明文传输，而HTTPS是结果SSL加密协议后传输，更加安全；  
    4. HTTPS比HTTP慢，因为HTTP建立链接仅需要TCP三次握手的三个包，而HTTPS还需要SSL握手的九个包；

## 性能优化
  1. 解决资源并发加载浏览器数量限制问题(一般是5-10个)：使用不同的域名请求资源，如静态资源、图片资源等进行域名分离；
  2. 图片懒加载原理：当图像不在可是区域内时，不对img赋值

## 前端安全
  1. CSRF（跨站请求伪造）：是一种挟制用户在当前浏览器已登录网站上执行非本意的操作的攻击方式；  
    * 抵御方式：(1)增加token验证机制，请求服务端返回token，只有请求中同时携带token和cookie方为合法的请求；(2)验证referer：通过验证请求同中的来源站点（但目前的绝大多数请求都可以进行伪造）；(3)对cookie设置SameSite标识，可以让cookie不随着跨域请求发出（但有浏览器的兼容问题）
  2. XSS（跨站脚本攻击）：利用网站的开发漏洞，注入恶意代码到网页中，使用户加载并执行恶意代码程序。  
    * 抵御方式：(1)输入检查（对内容中的script、iframe等转义或过滤）；(2)设置httponly防止js获取cookie；(3)开启CSP，即白名单，阻止白名单以外的资源加载和运行；