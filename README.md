# web-interview

## HTML

## CSS

## JavaScript
  1. Promise解决的问题：传统异步编程中的回调地狱问题；promise是基于观察者模式实现的，即收集依赖 -> 触发通知 -> 依赖执行 的模式。
  2. 关于继承？
    * 原型链继承：直接让子类的原型对象指向父类实例。
      * 缺点：(1)所有子类实例的原型均指向同一个父类实例对象，对某个子类实例对象的父类引用类型变量的修改会导致所有子类实例受到影响；(2)创建子类实例无法向父类实例构造传参，即缺少super功能；
    * 构造函数继承：子构造函数中执行父构造函数并绑定子构造函数this对象，将父类的成员属性绑定在子类this上，能避免所有子类实例贡献同一个原型实例且能够向构造函数传参；
      * 缺点：(1)继承不到父类原型上的方法和属性。
    * 组合式继承：同时使用原型链集合和构造函数继承。
      * 缺点：(1)创建子类实例执行两次的构造函数，并且子类实例存在两份原型对象的变量和函数定义；
    * 寄生式组合继承：在组合式继承中将子类原型对象指向父类的原型，解决了两次构造函数的问题；
      * 缺点：(1)对子类原型的操作会影响父类原型，因此需要对父类原型做一次浅拷贝。
  3. for...of 和 for...in的区别？  
  （1）for...of遍历中获取的是值，且可以随时break跳出；    
  （2）for...in遍历中获取的是键，但无法随时break跳出；  

## 浏览器
### Event Loop (事件循环机制)
  1. 单线程：同一时间内只能做一件事。（若使用多线程，当多个线程对dom进行操作时，以哪个线程为准将称为问题，因此使用单线程）单线程的存在意味着任务执行队列的存在，任务排队执行。
  2. 任务的分类
    * 同步任务：主线程上排队执行的任务，只有前一个执行完成，才执行后一个任务；
    * 异步任务：不进入主线程执行，而进入“任务队列”中的任务，只有主线程空闲后，“任务队列”通知主线程某个异步任务可以执行，该任务才会进入主线执行；
    * 微任务：Promise.then/catch/finally、Object.observe(监听标准对象的变化)、process.nextTick(仅在node中)
    * 宏任务：所有非微任务都归为宏任务，如script、setTimeout、setInterval等。
  3. 事件循环：
    1. 同步任务在主线程上执行，形成执行栈；
    2. 在主线程外开辟一个“任务队列”，当异步任务有结果后，在“任务队列”中放置事件
    3. 一旦主线程完成，就向“任务队列”中取出放置的事件，执行对应的回调函数（异步任务）
    4. 异步任务放入主线程后，重复循环3  
    总结：主线程从“任务队列”中读取事件，不断循环的运行机制。  
    主线程运行时，产生堆和栈，栈中调用各种API在“任务队列”中放入各种事件，主线程完成，读取"任务队列"，依次执行事件对应的回调函数。

## Vue
  1. vue的生命周期定义？  
  vue实例从创建到销毁的整个过程，就是生命周期；即vue实例从开始创建、初始化数据、编译模板、挂载DOM -> 渲染、更新->渲染、销毁的一系列过程，称之为vue的生命周期。
  2. vue生命周期的作用？  
  vue在它的生命周期过程中有多个事件钩子函数，可以让我们更好地控制vue实例整个生命周期过程中的处理逻辑。
  3. vue生命周期公共有几个阶段极其对应的钩子函数？  
  8个阶段，分别是：  
  创建前（beforeCreate）：在实例初始化之前，el和data未初始化，此时this无法使用，data、methods、watcher等无法使用  
  创建后（created）：完成data的初始化，el未初始化，此时可以使用vue实例中的数据以及各种方法，但无法对dom节点进行操作  
  挂载前（beforeMount）：完成el的初始化（此时el是虚拟dom）  
  挂载后（mounted）：完成dom节点的挂载，可在这里发起后端请求，拿回数据配合路由钩子等进行业务处理  
  更新前（beforeUpdate）：在view层数据变化前触发，而不是data中数据改变前触发  
  更新后（updated）：在view层数据变化之后  
  销毁前（beforeDestroy）：可在此处进行确认是否删除实例（组件）操作，仍可以使用this、data和各种方法    
  销毁后（destroyed）：当前组件（实例）已销毁，相关内容皆无法使用  
  4. vue第一次加载页面会触发哪几个钩子函数？  
  第一次加载一定会触发beforeCreated、created、beforeMount、mounted
  5. DOM渲染在哪个周期完成？  
  DOM渲染在mounted中挂载到页面上，此时可以获取到dom元素
  6. v-show和v-if的区别？  
  v-show是css切换，v-if包含完成的创建和销毁过程  
  使用频繁使用v-show，较少改变使用v-if  
  v-if是条件渲染，当值为false时不会渲染，即页面不存在该dom元素(及其子元素)  
  v-show不管是true还是false，dom元素都存在，只是css的display在none和block间切换  
  7. MVVM  
  M - model，代表数据模型，可以在model中处理数据业务逻辑  
  V - view，代表视图，负责将数据模型在UI中显示出来  
  VM - viewmodel，负责监听模型数据的改变以及控制视图行为、处理用户交互，即同步view和model的对象  
  8. computed和watch的差别  
  computed是计算属性：（1）可以缓存，只有当它依赖的属性值改变后，下一次获取computed值时重新获取值并缓存起来；（2）无法进行异步操作；（3）适用于计算比较消耗性能的场景，（4）若为函数，则默认使用get方法，若为配置对象，属性支持get和set方法，当数据变化时使用set方法，当获取数据是使用get方法  
  watch起到观察的作用：（1）无缓存，页面渲染时值不变也会执行；（2）可以执行异步操作；（3）监听函数由两个参数；（4）监听数据必为data或props中的属性。  
  9. vue的两个核心？  
  数据驱动：Object.defineProperty和存储器属性getter和setter，可称为基于依赖收集的观测机制，核心是VM，保证数据和视图的一致性；  
  组件系统
  10. vue单页面的优缺点？  
  缺点：  
    * 不支持低版本浏览器，最低支持IE9；
    * 不利于seo的优化；（需通过服务端渲染）；
    * 第一次加载首页耗时长；
    * 不可以使用浏览器的导航按钮，需要自行实现前进、后退；
  优点：  
    * 无刷新体验，提升用户体验；
    * 不再以页面为单位进行开发，更多采用组件化思想，代码结构和组织方式更为规范化，便于修改和调整；
    * api共享，同一套后端程序代码不用修改就可以用于web、手机、平板等多端；
    * 用户体验好、快，内容的改变不需要加载整个页面；
  11. MVC和MVVM的区别？  
  MVC：MVC中各部分通信时单向的，View指令发送到Controller中处理业务逻辑，在由Controller通知Model改变状态，Model最后将数据发送到view，用户得到反馈；MVC中关注的时M的不变，但时View依赖M；  
  MVVM：各部分的通信是双向的，采用双向数据绑定的模式，View变动，自动反映在Model上，反之亦然；MVVM在概念上是真正将视图与数据逻辑分离的模式。
  12. Vue的双向数据绑定原理？  
  Vue的双向数据绑定是通过数据劫持结合发布订阅模式实现的，即数据和视图同步更新；Vue双向数据绑定的核心是Object.defineProperty()中劫持属性中的getter和setter方法，在数据变动时，发布消息给订阅者，订阅者触发相应的监听回调。
  13. Vue-Router的实现原理？  
  （1）hash模式：基于浏览器的hash变化不会重新加载页面以及浏览器暴露了hashchange监听事件，每次hash变化都会增加历史纪录；  
  （2）history模式：HTML5增加了新的操作API：pushState和replaceState可以对浏览器历史记录栈进行修改，该方法可以修改浏览器历史记录栈，当前的URL改变浏览器不会立即发送请求。
  14. 
## Webpack
  1. webpack的作用  
  （1）依赖管理：方便引用第三方模块、让模块更容易服用，避免全局注入冲突、避免重复加载或加载不需要的模块。  
  （2）合并代码：将分散的模块集中打包成大文件，减少HTTP的请求链接数，配合UglifyJS可以减少、优化代码的体积。  
  （3）管理插件：统一处理引入的插件，babel编译ES6文件，eslint可以检查编译期的错误。  
  总结：webpack的作用是处理依赖、模块化、打包压缩文件、管理插件
  2. webpack的工作过程  
  （1）解析配置参数，合并命令行和webpack.config.js文件的配置信息，输出最终的配置信息；  
  （2）注册配置中的插件，让插件监听webpack构建生命周期中的事件节点，做出相应的反应；  
  （3）解析配置文件中的entry入口文件，找出每个文件依赖的文件，递归执行；  
  （4）在递归文件的过程中，根据文件类型和配置文件中的loader找出对应的loader对文件进行转换；  
  （5）递归结束后得到文件最终的结果，根据entry配置生产代码chunk；  
  （6）输出chunk到文件系统。

## HTTP协议

## 性能优化
  1. 解决资源并发加载浏览器数量限制问题(一般是5-10个)：使用不同的域名请求资源，如静态资源、图片资源等进行域名分离；


