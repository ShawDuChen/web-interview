# web-interview

## HTML
  1. doctype的作用：声明文档类型，告诉浏览器使用什么文档标准解析文档。
  2. 怪异模式和标准模式  
    1. 怪异模式：盒模型为width+margin  
    2. 标准模式：盒模型为width+margin+padding+border
  3. href和src的区别：  
    1. href指超文本引用，并行下载但不阻塞页面解析  
    2. src指资源，浏览器遇到src时，会暂停页面解析直到资源下载或执行完毕
  4. SVG和Canvas的区别：  
    1. SVG以xml格式定义图像的可伸缩矢量图形；  
    2. Canvas通过JS绘制2D图形；
## CSS
  1. 清除浮动的方法  
    1. 额外标签法  
    2. 父级元素BFC法  
    3. 使用after伪类
    4. 使用before和after双伪类

## JavaScript
1. Promise解决的问题：传统异步编程中的回调地狱问题；promise是基于观察者模式实现的，即收集依赖 -> 触发通知 -> 依赖执行 的模式。
2. 关于继承？
  * 原型链继承：直接让子类的原型对象指向父类实例。
      * 缺点：(1)所有子类实例的原型均指向同一个父类实例对象，对某个子类实例对象的父类引用类型变量的修改会导致所有子类实例受到影响；(2)创建子类实例无法向父类实例构造传参，即缺少super功能；  
  * 构造函数继承：子构造函数中执行父构造函数并绑定子构造函数this对象，将父类的成员属性绑定在子类this上，能避免所有子类实例贡献同一个原型实例且能够向构造函数传参；
      * 缺点：(1)继承不到父类原型上的方法和属性。
  * 组合式继承：同时使用原型链集合和构造函数继承。
      * 缺点：(1)创建子类实例执行两次的构造函数，并且子类实例存在两份原型对象的变量和函数定义；
  * 寄生式组合继承：在组合式继承中将子类原型对象指向父类的原型，解决了两次构造函数的问题；
      * 缺点：(1)对子类原型的操作会影响父类原型，因此需要对父类原型做一次浅拷贝。
3. for...of 和 for...in的区别？  
  （1）for...of遍历中获取的是值，且可以随时break跳出；    
  （2）for...in遍历中获取的是键，但无法随时break跳出；  
4. 设计模式：  
    1. 单例模式：一个类只能存在一个实例对象，如vuex的store
    2. 工厂模式：对创建对象的逻辑进行封装的操作，如$(selector)
    3. 观察者模式：对象的修改会自动通知依赖对象，如vue的双向数据绑定  
    4. 装饰器模式：对类进行封装，动态扩展类的功能，如ES7装饰器
    5. 适配器模式：兼容新旧接口，对类的包装，如封装就API
    6. 代理模式：控制对象的访问方式，如ES6的Proxy
5. Number(null) = 0 ; Number(undefined) = NAN;
6. 事件流指从页面中接收事件的顺序，按照  捕获 -> 目标 -> 冒泡 的阶段进行；
7. typeof 和 instanceof 的区别：(1)typeof用于检测变量类型，基本类型中除null以外均显示对应的数据类型，引用类型除了函数类型显示function意外，其余都显示object类型；(2)instanceof用于检测某个构造函数的原型对象在不在某对象的原型链上。
8. 构造函数：任意一个普通函数用于创建一个对象时，他就可称为构造函数或构造器；（ps：函数是一等公民）
9. 闭包  
    1. 作用域规则：内部函数总可以访问其外部函数中声明的变量；
    2. 定义：当通过调用一个外部函数返回一个函数后，即使外部函数已经执行结束，但内部函数引用外部函数的变量依然保存，这些变量的合集称之为闭包；即A中存在函数B，函数B引用A中的变量，B称为A的闭包；
    3. 好处：缓存变量不被回收，以及实现柯里化；
    4. 坏处：(1)内存消耗问题，闭包的变量无法被回收；(2)性能问题，由于闭包的作用域优先级高于外部，所以需要多查找一个作用域链层次，一定程度上影响查找速度；
10. this永远指向最后调用它的对象；
    1. 普通函数中this指向执行上下文
    2. 箭头函数中this实现定义时上下文
    3. JS的严格模式下，默认执行一个函数时，其内部的执行上下文中this值为undefined
11. 异步的演进：callback -> promise ->  generator -> async/await
12. Promise的执行过程
    1. Promise是对象是一个构造函数，用来生成promise实例
    2. new Promise传入一个函数，该函数有两个参数resolve和reject
    3. resolve将“未完成”变成“成功” pending -> fulfilled
    4. reject 将“未完成”变成“失败” pending -> rejected
    5. 未执行resolve或reject前状态为pending
    6. promise实例中的状态一经改变不能再更改
13. 复制：复制基本数据类型时是拷贝值，复制引用复杂数据类型时是拷贝地址；
    1. 浅拷贝（Object.assign、数组的API如concat、slice等）
    2. 深拷贝（JSON.parse(JSON.stringify)、$.extend(true,obj)，_.cloneDeepWith(obj)
14. call、apply、bind的区别？
    1. call改变函数的指向，第一参数为改变的指向对象，后续为传参；
    2. apply前者同call，后者传参未数组；
    3. bind改变this的作用域后返回新的函数，不会立即执行；
15. 防抖：频繁触发的情况下，只在任务触发间隔超过设定的事件范围才执行；
    1. 设置定时器；
    2. 返回闭包；
    3. 如果反复进来，则清除定时器，重设执行函数
16. 节流：指定时间间隔内只执行一次任务；
    1. 设置标记；
    2. 返回闭包，更改标记；
    3. 若重复进入则跳过；
    4. 若执行完成则清楚标记；
17. JSONP原理：利用script的src没有跨域限制实现跨域。
    1. 前端定义解析函数：jsonpCallback = function () {}
    2. 通过params形式包装script标签请求参数并声明执行函数，如cb=jsonpCallback
    3. 后端获取声明的执行函数并带上参数和调用方式返回给前端
    4. 前端在script标签返回资源时执行jsonpCallback回调获取数据  
    优缺点：[优点]兼容性好，[缺点]只允许使用GET方法
18. CORS原理：允许浏览器向服务端发送请求，前提是浏览器支持且服务端同意跨域请求（服务端请求头中需设置Accept-Contorl-Allow-Origin）


## 浏览器
### Event Loop (事件循环机制)
  1. 单线程：同一时间内只能做一件事。（若使用多线程，当多个线程对dom进行操作时，以哪个线程为准将称为问题，因此使用单线程）单线程的存在意味着任务执行队列的存在，任务排队执行。
  2. 任务的分类  
    1. 同步任务：主线程上排队执行的任务，只有前一个执行完成，才执行后一个任务；  
    2. 异步任务：不进入主线程执行，而进入“任务队列”中的任务，只有主线程空闲后，“任务队列”通知主线程某个异步任务可以执行，该任务才会进入主线执行；  
    3. 微任务：Promise.then/catch/finally、Object.observe(监听标准对象的变化)、process.nextTick(仅在node中)  
    4. 宏任务：所有非微任务都归为宏任务，如script、setTimeout、setInterval等。
  3. 事件循环：  
    1. 同步任务在主线程上执行，形成执行栈；  
    2. 在主线程外开辟一个“任务队列”，当异步任务有结果后，在“任务队列”中放置事件  
    3. 一旦主线程完成，就向“任务队列”中取出放置的事件，执行对应的回调函数（异步任务）  
    4. 异步任务放入主线程后，重复循环3    
    总结：主线程从“任务队列”中读取事件，不断循环的运行机制。  
    主线程运行时，产生堆和栈，栈中调用各种API在“任务队列”中放入各种事件，主线程完成，读取"任务队列"，依次执行事件对应的回调函数。
  4. Javascript runtime：指JS的执行环境。js执行时创建主线程和调用栈，所有任务都会放入调用栈等待主线程执行。
  5. 事件循环（解释2）：  
    1. 主线程从上而下一次执行；  
    2. 同步任务放入主线执行；  
    3. 异步任务放入Event Table，当结果返回，对回调函数进行注册并放入Event Queue；  
    4. 主线程空闲后，从任务队列中读取任务，放入主线程执行；  
    5. 放入主线程的任务从1开始循环
  6. 跨域问题（只存在于客户端）：指请求URL的协议、域名、端口三者任意一个不与当前页面的URL相同的去请求；有效的解决方法有：(1)JSONP;(2)CORS;(3)代理服务器;(4)解除浏览器限制;
   
### 渲染机制
  1. 渲染过程？  
    1. HTML和CSS经过解析，分别形成DOM树和CSS规则树；  
    2. DOM树和CSSOM树合并成渲染树；  
    3. 根据渲染树形成布局渲染树；  
    4. 根据布局渲染树，调用GPU进行绘制，显示在屏幕上。
  2. 如何减少回流：(1)使用class代替style；(2)监听resize和scroll等会引起回流的事件是进行防抖和节流；(3)使用visibility代替display（前者只重绘，后者会回流）；(4)批量修改dom元素时应脱离文档流进行操作；
  3. 回流必定发生重绘，重绘不一定引发回流；

### 缓存策略  
  1. 强缓存：不需要向服务器进行请求（在f12控制台中显示为memory cache或disk cache）  
  2. 协商缓存：需要向服务器询问是否过期，请求头中携带if-modify-since，若过期则返回200，否则返回304(Not Modify)

### 前端存储
  1. cookie：HTTP请求时会自动携带在请求头中，兼容性好，大小只有4kb
  2. localStorage：持久性存储，关闭页面依旧存在，以键值对的形式存储，大小5MB
  3. sessionStorage：会话期存储，关闭页面后销毁，以键值对的形式存储，大小5MB，不同选项卡之间不互通

### 从输入URL到页面呈现发生了声明？
执行顺序：DNS解析 -> TCP链接 -> 发送HTTP请求 -> 服务端响应数据 -> 浏览器解析渲染页面
1. DNS解析过程：通过网络查找哪台服务器有所需要资源的过程。执行过程：(输入baidu.com)查询域名 -> 客户端缓存(按顺序分别是浏览器缓存、系统缓存、路由器缓存) -> 访问互联网服务提供商DNS服务器(若存在缓存则直接返回) -> 本地资源根服务器 -> 本地咨询.com顶级域名服务器 -> 本地咨询baidu.com主域名服务器 -> 本地服务通知用户IP并进行缓存
2. TCP连接：建立客户端与服务端的连接（3次握手） -> 传输数据 -> 断开客户端与服务端的连接（4次挥手）
3. HTTP请求：构建HTTP请求报文，并通过TCP协议发送到服务器指定端口；
4. 服务器响应：服务器处理请求完毕后，返回HTTP响应报文；
5. 浏览器渲染解析页面：解析HTML生成DOM树 -> 解析CSS生成CSS规则树 -> 将DOM树与CSS规则树结合生成渲染树 -> 从根节点开始计算每一个元素的大小和位置得到渲染树的布局渲染树 -> 遍历渲染树，调用UI渲染引擎绘制渲染树呈现页面；

## Vue
  1. vue的生命周期定义？  
  vue实例从创建到销毁的整个过程，就是生命周期；即vue实例从开始创建、初始化数据、编译模板、挂载DOM -> 渲染、更新->渲染、销毁的一系列过程，称之为vue的生命周期。
  2. vue生命周期的作用？  
  vue在它的生命周期过程中有多个事件钩子函数，可以让我们更好地控制vue实例整个生命周期过程中的处理逻辑。
  3. vue生命周期公共有几个阶段极其对应的钩子函数？  
  8个阶段，分别是：  
  创建前（beforeCreate）：在实例初始化之前，el和data未初始化，此时this无法使用，data、methods、watcher等无法使用  
  创建后（created）：完成data的初始化，el未初始化，此时可以使用vue实例中的数据以及各种方法，但无法对dom节点进行操作  
  挂载前（beforeMount）：完成el的初始化（此时el是虚拟dom）  
  挂载后（mounted）：完成dom节点的挂载，可在这里发起后端请求，拿回数据配合路由钩子等进行业务处理  
  更新前（beforeUpdate）：在view层数据变化前触发，而不是data中数据改变前触发  
  更新后（updated）：在view层数据变化之后  
  销毁前（beforeDestroy）：可在此处进行确认是否删除实例（组件）操作，仍可以使用this、data和各种方法    
  销毁后（destroyed）：当前组件（实例）已销毁，相关内容皆无法使用  
  4. vue第一次加载页面会触发哪几个钩子函数？  
  第一次加载一定会触发beforeCreated、created、beforeMount、mounted
  5. DOM渲染在哪个周期完成？  
  DOM渲染在mounted中挂载到页面上，此时可以获取到dom元素
  6. v-show和v-if的区别？  
  v-show是css切换，v-if包含完成的创建和销毁过程  
  使用频繁使用v-show，较少改变使用v-if  
  v-if是条件渲染，当值为false时不会渲染，即页面不存在该dom元素(及其子元素)  
  v-show不管是true还是false，dom元素都存在，只是css的display在none和block间切换  
  7. MVVM  
  M - model，代表数据模型，可以在model中处理数据业务逻辑  
  V - view，代表视图，负责将数据模型在UI中显示出来  
  VM - viewmodel，负责监听模型数据的改变以及控制视图行为、处理用户交互，即同步view和model的对象  
  8. computed和watch的差别  
  computed是计算属性：（1）可以缓存，只有当它依赖的属性值改变后，下一次获取computed值时重新获取值并缓存起来；（2）无法进行异步操作；（3）适用于计算比较消耗性能的场景，（4）若为函数，则默认使用get方法，若为配置对象，属性支持get和set方法，当数据变化时使用set方法，当获取数据是使用get方法  
  watch起到观察的作用：（1）无缓存，页面渲染时值不变也会执行；（2）可以执行异步操作；（3）监听函数由两个参数；（4）监听数据必为data或props中的属性。  
  9. vue的两个核心？  
  数据驱动：Object.defineProperty和存储器属性getter和setter，可称为基于依赖收集的观测机制，核心是VM，保证数据和视图的一致性；  
  组件系统
  10. vue单页面的优缺点？  
  缺点：  
    * 不支持低版本浏览器，最低支持IE9；  
    * 不利于seo的优化；（需通过服务端渲染）；  
    * 第一次加载首页耗时长；  
    * 不可以使用浏览器的导航按钮，需要自行实现前进、后退；  
  优点：  
    * 无刷新体验，提升用户体验；  
    * 不再以页面为单位进行开发，更多采用组件化思想，代码结构和组织方式更为规范化，便于修改和调整；  
    * api共享，同一套后端程序代码不用修改就可以用于web、手机、平板等多端；  
    * 用户体验好、快，内容的改变不需要加载整个页面；
  11. MVC和MVVM的区别？  
  MVC：MVC中各部分通信时单向的，View指令发送到Controller中处理业务逻辑，在由Controller通知Model改变状态，Model最后将数据发送到view，用户得到反馈；MVC中关注的时M的不变，但时View依赖M；  
  MVVM：各部分的通信是双向的，采用双向数据绑定的模式，View变动，自动反映在Model上，反之亦然；MVVM在概念上是真正将视图与数据逻辑分离的模式。
  12. Vue的双向数据绑定原理？  
  Vue的双向数据绑定是通过数据劫持结合发布订阅模式实现的，即数据和视图同步更新；Vue双向数据绑定的核心是Object.defineProperty()中劫持属性中的getter和setter方法，在数据变动时，发布消息给订阅者，订阅者触发相应的监听回调。
  13. Vue-Router的实现原理？  
  （1）hash模式：基于浏览器的hash变化不会重新加载页面以及浏览器暴露了hashchange监听事件，每次hash变化都会增加历史纪录；  
  （2）history模式：HTML5增加了新的操作API：pushState和replaceState可以对浏览器历史记录栈进行修改，该方法可以修改浏览器历史记录栈，当前的URL改变浏览器不会立即发送请求。
  14. diff算法：用来计算虚拟dom中被改变的部分，然后针对该部分进行原生dom操作，而不用重新渲染整个页面的算法。  
    步骤：  
    (1) 用 Javascript 对象结构表示DOM结构，然后用这个树构建一个真正的DOM树，插入到文档中;  
    (2) 当状态发生变化时，重新构建一棵树。然后用新树和旧树进行比较，记录下两棵树的差异;  
    (3) 把记录的差异应用到步骤(1)中构建的DOM树上，视图更新;  
  15. 虚拟DOM：其实是一棵以Javascript对象作为基础的树，用对象属性来描述节点，实际上只是一层对真实DOM的抽象。  
    1. 为什么需要虚拟DOM?  
    (1) 具备跨平台的优势：虚拟DOM是以Javascript对象为基础而不依赖真实平台环境，所以具备跨平台的能力;  
    (2) 性能优势：操作元素DOM慢，js的运行效率更高，将DOM层操作放在js层能提高效率;  
    (3) 虚拟DOM本质上是在JS和DOM之间做了一个缓存;  
  16. vuex中state的响应式：  
    通过Store的构造函数中调用resetStoreVM(this,state)方法实现。该方法主要是重置一个私有的_vm(一个Vue实例)对象。这个_vm对象会保留我们的state树，以及用计算属性的方式存储store的getters。  
## Vuex
  1. Vuex定义：是一个专门为Vue应用程序开发的状态管理模式。采用集中式存储管理应用的所有组件状态，并以相应的规则保证状态以一种可预测的方式发生变化。  
  2. 状态管理模式：把组件间的共享状态抽取出来，以全局单例模式管理，通过强制规则维持视图和状态见的独立性。  
  3. vuex解决的问题：(1)多个视图依赖同意状态；(2)来自不同视图的行为需要变更同一个状态。
  4. 直接修改和commit修改的异同点？  
    (1) 相同点：都可以修改state，并且也会触发视图的更新  
    (2) 不同点：如果是在严格模式下strict:true，state的修改只要不经过mutation都会报错  
  5. 为什么建议使用commit修改state？  
    因为在项目中，每一个状态树对应项目的一个状态，每次mutation代表一次项目状态的改变，mutation就是为了使我们可以更加直观观察到项目状态的变化。（PS：另一解释为使用commit提交状态修改是为了配合开发者工具使用，使得状态更好的被追踪，保存状态快照，实现时间漫游/回滚之类的操作。

## Webpack
  1. webpack的本质：JavaScript应用程序的静态模块打包器。当webpack处理应用程序时，会递归地构建一个依赖关系图，其中包含的应用程序需要的每个模块，然后将这些模块打包成一个或多个bundle
  2. webpack的作用  
  （1）依赖管理：方便引用第三方模块、让模块更容易服用，避免全局注入冲突、避免重复加载或加载不需要的模块。  
  （2）合并代码：将分散的模块集中打包成大文件，减少HTTP的请求链接数，配合UglifyJS可以减少、优化代码的体积。  
  （3）管理插件：统一处理引入的插件，babel编译ES6文件，eslint可以检查编译期的错误。  
  总结：webpack的作用是处理依赖、模块化、打包压缩文件、管理插件
  3. webpack的工作过程  
  （1）解析配置参数，合并命令行和webpack.config.js文件的配置信息，输出最终的配置信息；  
  （2）注册配置中的插件，让插件监听webpack构建生命周期中的事件节点，做出相应的反应；  
  （3）解析配置文件中的entry入口文件，找出每个文件依赖的文件，递归执行；  
  （4）在递归文件的过程中，根据文件类型和配置文件中的loader找出对应的loader对文件进行转换；  
  （5）递归结束后得到文件最终的结果，根据entry配置生产代码chunk；  
  （6）输出chunk到文件系统。
  4. 常见的webpack插件(plugins)  
  (1) clean-webpack-plugin:打包前自动清理dist目录，防止文件残留;  
  (2) copy-webpack-plugin:将单个文件或整个目录复制到构建目录;  
  (3) mini-css-extract-plugin:将CSS抽离到单独打包文件并且可以通过配置设置是否压缩;  
  (4) html-webpack-plugin:用于生成HTML5文件的插件，其中script标签自动包含webpack包。如果设置多个入口点，可以据此实现多页面应用程序打包。  
  (5) webpack-dashboard:友好展示打包相关信息的插件  
  (6) webpack-merge:提取公共配置后进行合并的插件，有利于减少重复配置代码  
  (7) size-plugin:监控打包资源体积变化的插件  
  (8) hot-module-replacement-plugin:模块热替换插件  
  5. Loader 和 Plugin 的区别  
    1. Loader本质上是一个函数，对接收到的内容进行转换然后输出结果；因为webpack只认识Javascript，所以loader相当于翻译官针对不同类型的资源进行处理。  
    2. Plugin插件，用于扩展webpack的功能，就是在webpack的生命周期中进行各种操作，从而达到使用目的

## HTTP协议
  1. 常见的HTTP状态码  
    1. 200：客户端请求服务端正常响应  
    2. 301：永久重定向，请求网页永久移动到新位置  
    3. 302：临时重定向，请求网页临时移动到新位置  
    4. 304：未修改，自上次请求后网页内容未进行过修改  
    5. 400：客户端请求错误，服务端无法解析语法，常见于客户端传参错误  
    6. 401：未授权，客户端请求需HTTP认证信息，常见于客户端未登录鉴权  
    7. 404：未找到资源，客户端请求资源在服务器上不存在  
    8. 500：服务器内部错误  
    9. 502：网关错误
  2. GET和POST的区别？（核心区别时GET请求是幂等的，而POST不是）使用上的区别见如下：  
    1. GET请求参数放在URL上，而POST放在请求体里；  
    2. GET请求参数有大小限制，而POST趋于无限大；  
    3. POST相比GET安全，因为GET请求信息直接显示在URL上，而POST在请求体里；  
    4. GET请求可以缓存，而POST不能
  3. HTTP和HTTPS的区别？  
    1. HTTP默认使用80端口，而HTTPS默认使用443端口；  
    2. 使用HTTPS需要申请证书；  
    3. HTTP是超文本传输协议，明文传输，而HTTPS是结果SSL加密协议后传输，更加安全；  
    4. HTTPS比HTTP慢，因为HTTP建立链接仅需要TCP三次握手的三个包，而HTTPS还需要SSL握手的九个包；
  4. TCP三次握手是指建立一个TCP连接时，客户端和服务端总共需要发送三个数据包来确认连接的建立  
    1. 三次握手的作用：(1)确认双方的接收能力和发送能力;(2)指定自己的初始化序列号，未后面的可靠性做准备;  
    2. 三次握手的过程：(客户端处于closed状态，服务端处于listen状态)  
      (1)客户端发送到服务端。客户端发送SYN报文给服务器，并且指明客户端初始化序列号未ISN(c)，即以 SYN = 1,seq=x的形式发送过去。此时客户端处于SYN_SEND状态;  
      (2)服务端发送给客户端。服务端接收到客户端发送的SYN和ISN(c)，也发送一个SYN回去，同时设置ACK=ISN(c)+1以及指明服务器初始化序列号未ISN(s)，即以SYN=1，ACK=x+1,seq=y的形式发送给客户端；  
      (3)客户端发送给服务端。客户端接收到服务端发送的消息后，设置ACK=ISN(s)+1，将自身的ISN(c)+1，即以ACK=y+1,seq=x+1的形式发送给服务端。此时客户端处于ESTABLISHED阶段，服务端接收报文，也处于ESTABLISHED阶段，双方建立连接；  
    3. 三次握手的目的  
      (1)客户端发送数据给服务端，确认服务端可以接收自己的请求  
      (2)服务端发送数据给客户端，客户端确认自己可以发送数据给服务端，同时接受服务端的请求。  
      (3)客户端发送数据给服务端，服务端确认自己可以发送数据给客户端  
    4. 三次握手的过程中，只有第三次握手可以携带数据，第一第二次不可以携带。
  5. 数据传输完毕后，需要终止连接，通过`四次挥手`来保证双发都能断开连接  
    1. 四次挥手的过程  
      (1)客户端发送给服务端。客户端以FIN=1，seq=u的形式发送给服务端，表示需要关闭客户端和服务端的数据传输。此时客户端处于FIN_WAIT状态。  
      (2)服务端发送给客户端。服务端接收信息，先返回ACK给客户端，即以ACK=1，seq=v，ack=u+1的形式返回给客户端，表示收到客户端报文。此时服务器处于CLOSE_WAIT状态。  
      (3)服务端发送给客户端。服务器等待一会，看客户端是否还有数据传输，等处理完数据之后，也需要断开连接，于是发送FIN给客户端，即以FIN=1，ACK=1，seq=w，ack=u+1的形式发送给客户端。此时服务器处于LAST_ACK状态。  
      (4)客户端发送给服务器。客户端接收到FIN之后，返回ACK报文作为应答，即以ACK=1，seq=w+1的形式发送给服务器，此时客户端处于TIME_WAIT状态。  
    2. 为什么需要四次挥手？  
      因为服务器接收到客户端的关闭请求之后，如果有数据因延迟未发送到或仍然有数据需要发送，直接关闭会导致数据缺失，因此需要确保数据发送完成。所以当客户端一段时间没有数据到达后，就发送关闭数据到客户端，告诉客户端可以关闭了。
  6. UDP: 用户数据包协议，是基于IP之上开发能和应用打交道的协议。UDP中最重要的一个信息是端口号，通过端口号UDP可以把指定的数据包发送到指定的程序。  
    UDP的缺陷：(1)数据包在传输过程中容易丢失;(2)大文件传输中，UDP并不知道如何组成这些数据包，不知道如何还原成完整的文件。
  7. TCP和UDP的区别：  
    (1)TCP面向连接，UDP是无连接的即发送数据前不需要建立连接；  
    (2)TCP提供可靠的服务，即TCP连接传输的数据无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证数据可靠。因为TCP可靠，面向连接，不会丢失，所以适合大数据量的交换。  
    (3)TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低。  
    (4)TCP只能一对一，UDP支持一对一、一对多  
    (5)TCP的首部较大为20字节，而UDP首部只有8字节  
    (6)TCP是面向连接的可靠性传输，UDP是不可靠的  
  8. HTTPS的优点  
    1. HTTPS可认证用户和服务器，确保数据正确发送到客户端和服务器  
    2. HTTPS是由HTTP+SSL协议构建的加密传输、身份认证的网络协议，比HTTP安全，可防止数据在传输过程中被窃取、改变，确保数据完整性  
    3. HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但增加了中间人的攻击成本  
    4. HTTPS比HTTP具有更高的SEO排名
  9. HTTPS的缺点  
    1. HTTPS握手阶段比较费时，会使页面的加载时间延迟50%，增加10-20%的耗电  
    2. HTTPS缓存不如HTTP高效，会增加数据开销  
    3. SSL证书需要花钱，功能越强大，证书费用越高  
    4. SSL证书需要绑定IP，不能在同一个IP上绑定多个域名，IPV4资源支持不了这种消耗
  10. HTTP和HTTPS的对比  
    1. 概念对比：HTTP是超文本传输协议，明文传输，HTTPS则是具有安全性的SSL加密传输协议  
    2. 费用对比：HTTPS协议需要CA证书，费用较高  
    3. 连接方式和端口：使用不同的连接方式，端口不同，一般而言HTTPS默认端口为443，HTTP默认端口为80  
    4. 安全性对比：HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全  
  
## 性能优化
  1. 解决资源并发加载浏览器数量限制问题(一般是5-10个)：使用不同的域名请求资源，如静态资源、图片资源等进行域名分离；
  2. 图片懒加载原理：当图像不在可是区域内时，不对img赋值
  3. 使用CDN：静态资源的请求采用CDN可以减少服务器压力、防止不必要携带Cookie的场景等
  4. 负载均衡：如使用nginx反向代理服务器平均各个服务器的压力；
  5. webpack优化：利用插件功能提高打包效率，做按需加载、tree shaking等
  6. 服务端渲染：在服务端将部分HTML页面渲染好直接返回给浏览器，减少与后端的交互，对SEO也更友好；
  7. CSS加载问题：应尽可能放在head位置加载CSS，减少HTML加载完毕后需要等待CSS加载；
  8. JS加载问题：JS加载会阻塞HTML和CSS的加载，所以将script标签放在body后，同时利用script标签的async和defer属性，同步加载js或等HTML和CSS加载完成后再加载JS

## 前端安全
  1. CSRF（跨站请求伪造）：是一种挟制用户在当前浏览器已登录网站上执行非本意的操作的攻击方式；  
    * 抵御方式：(1)增加token验证机制，请求服务端返回token，只有请求中同时携带token和cookie方为合法的请求；(2)验证referer：通过验证请求同中的来源站点（但目前的绝大多数请求都可以进行伪造）；(3)对cookie设置SameSite标识，可以让cookie不随着跨域请求发出（但有浏览器的兼容问题）
  2. XSS（跨站脚本攻击）：利用网站的开发漏洞，注入恶意代码到网页中，使用户加载并执行恶意代码程序。  
    * 抵御方式：(1)输入检查（对内容中的script、iframe等转义或过滤）；(2)设置httponly防止js获取cookie；(3)开启CSP，即白名单，阻止白名单以外的资源加载和运行；