# JS 相关

1. js 中的设计模式

   - 单例模式（Singleton）

     1. 用途：确保一个类只有一个实例（如全局缓存、数据库连接池）
     2. 原理：通过闭包或静态属性缓存实例，阻止重复创建；

   - 工厂模式（Factory）
     1. 用途：封装对象逻辑，统一入口（根据条件生成不同 UI 组件）
     2. 原理：将 new 操作隔离到工厂函数中。
   - 建造者模式（Builder）
     1. 用途：分步构建复杂对象（如配置 HTTP 请求参数）
     2. 通过链式调用逐步设置属性
   - 原型模式（Prototype）
     1. 用途：通过克隆已有对象创建新对象（如性能优化场景）。
     2. 原理：利用 js 的原型继承（Object.create()）
   - 装饰器模式（Decorator）
     1. 用途：动态扩展对象功能（如添加日志、权限校验）
     2. 原理：用包装类增强原始对象，保持接口一致
   - 适配器模式（Adapter）
     1. 用途：转换接口不兼容的对象（如旧 API 适配新系统）
     2. 原理：包装旧接口、暴露新接口；
   - 代理模式（Proxy）
     1. 用途：控制对象访问（如缓存、验证、懒加载）
     2. 原理：通过代理对象拦截原始对象的操作。
   - 外观模式（Facede）
     1. 用途：简化复杂子系统调用（如封装第三方库）
     2. 原理：提供统一的高层接口；
   - 观察者模式（Observer）
     1. 用途：实现发布-订阅机制（如事件系统、数据响应式）
     2. 原理：主题维护观察者列表、状态变化时通知所有观察者。
   - 策略模式（Strategy）
     1. 用途：动态切换算法（如排序、支付方式选择）
     2. 原理：将算法封装为独立类、运行时替换。
   - 状态模式（State）
     1. 用途：管理对象转换（如订单状态流转）
     2. 原理：将状态封装为独立类，委托当前状态对象处理行为。
   - 迭代器模式（Iterator）
     1. 用途：统一遍历集合结构（如自定义数据结构的 for...of 支持）
     2. 原理：实现[Symbol.iterator]方法；
   - 中介者模式（Mediator）
     1. 用途：减少对象间直接耦合（如聊天室消息转发）
     2. 原理：通过中介者对象协调交互；
   - 备忘录模式（Memento）
     1. 用途：保存和恢复对象状态（如撤销操作）
     2. 原理：将状态存储在外部对象中；
   - 职责链模式（Chain of Responsibility）
     1. 用途：解耦请求发送者和处理者（如中间件管道）
     2. 原理：多个处理器链式调用，直到某个处理器处理请求；

2. 箭头函数和普通函数的区别？

   - 箭头函数比普通函数简洁
   - 箭头函数没有自己的 this：它只会在自己作用域的上一层继承 this，因此在定义时 this 就已经确定，无法改变；
   - call\apply\bind 等改变 this 指向的方法无法改变箭头函数中 this 的指向；
   - 箭头函数不能作为构造函数；
   - 箭头函数没有自己的 argument：箭头函数中访问的 argument 实际上是外层函数的 arguments 值；
   - 箭头函数没有 prototype
   - 箭头函数不能用作 Generator 函数，不能使用 yeild 关键字；

3. ES6 模块和 CommmonJS 模块有什么异同？

   - CommonJS 是对模块的浅拷贝，ES6Module 是对模块的引用，即 ES6Module 只存只读，无法改变其值，也就是指针指向不变，类似 const；
   - import 的接口是 read-only，不能修改其值，即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对 commonjs 重新赋值（改变指针指向）但对 es6module 赋值会编译报错；
   - CommonJs 和 ES6Module 都可以对引入的对象进行赋值，即对对象内部属性的值进行改变；

4. var、let、const 的区别

   - 块级作用域：let/const 具有、var 不具有；块级作用域解决了
     - 内层变量可能覆盖外层变量
     - 用来计数循环变量泄露为全局变量
   - 变量提升：var 可提升、let/const 不可以提升（声明前使用报错）
   - 全局属性：var 声明的变量为全局变量，但 let/const 不会；
   - 重复声明：var 允许重复声明，let/const 不允许；
   - 暂时性死区：let/const 声明前无法使用，var 声明的变量可以在声明前使用；
   - 初始值设置：var/let 声明可以不赋值，const 必须赋值；
   - 指针指向：let/var 允许改变指针指向，const 不允许改变指针指向；

5. new 操作符的实现原理

   - 创建一个空对象；
   - 设置原型，将对象的原型设置为函数的 prototype 对象；
   - 让函数的 this 指向这个对象，执行构造函数的代码（为对象添加属性）
   - 判断函数的返回值类型，如果是值类型，返回创建的对象，如果是引用类型，返回这个引用类型的对象；

   ```js
   function objectFactory() {
     let newObject = null;
     let constructor = Array.prototype.shift.call(arguments);
     let result = null;

     if (typeof constructor !== "function") {
       console.error("type error");
       return;
     }

     newObject = Object.create(constructor.prototype);
     result = constructor.apply(newObject, arguments);
     let flag =
       result && (typeof result === "object" || typeof result === "function");

     return flag ? result : newObject;
   }
   ```

6. for...in 和 for...of 的区别

   - for...of 遍历获取的时对象的键值，for...in 获取的是对象的键名；
   - for...in 会遍历整个对象的原型链，性能差不推荐使用，而 for...of 只遍历当前对象不会遍历原型链；
   - 对于数组的遍历，for...in 会返回数组所有可枚举的属性（包括原型链上可枚举的属性），for...of 只返回数组的下标对应的属性值；
   - 总结：for...in 循环主要是为了遍历对象而生，不适用于遍历数组，for...of 可以用来遍历数组、类数组对象、字符串、Set、Map 以及 Generator 对象；

7. 闭包：指有权访问另一个函数作用域中变量的函数，创建闭包的最常见方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量；

   - 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方式来创建私有变量；
   - 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量的引用，所以这个变量不会被回收。

8. call、apply 函数的区别

   1. apply 接受两个参数，第一个参数指定了函数体 this 对象的指向，第二参数为一个带下标的集合，这个集合可以是数组，也可以是类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。
   2. call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二参数开始往后，每个参数依次被传入函数。

9. Promise.all 和 Promise.race 的区别和使用场景

   - Promise.all 可以将多个 Promise 实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是【结果数组】，失败返回的是【最先 reject 失败的值】；成功返回的结果数组顺序和传入顺序一致，但是执行顺序不一定按照顺序；当遇到需要发送多个请求，并根据请求顺序获取和使用数据的场景，可以使用 Promise.all 来解决；
   - Promise.race，接受多个参数，哪个结果最快获得，就返回相应的结果，不管结果本身是成功还是失败。应用于当要做一件事情，超过多长时间就不做了。

10. async/await 的理解

    - 本质上 Generator 的语法糖，它能实现的效果都能用 then 链来实现，它是为优化 then 链而开发的。
    - async 函数返回的是一个 Promise 对象（如果返回一个直接变量，async 会通过 Promise.resolve 包装成 Promise 对象）
    - 不能在最外层使用 await 语法，如果需要调用 async 函数，应使用.then 方法

11. 浏览器的垃圾回收机制

    - 概念：js 代码在运行时，需要分配内存空间来存储变量和值。当变量不再参与运行时，需要系统回收被占用的内存，这就是垃圾回收机制；
    - 回收机制
      - js 具有自动回收机制，会定期对那些不适用的变量、对象所占有的内存进行释放。
      - 全局变量持续到页面卸载，因此无法无法回收，局部变量在函数内声明，除闭包情况，默认在函数执行完成后会进行回收；
    - 垃圾回收方式
      - 标记清除
      - 计数引用

12. 造成内存泄漏的情况

    1. 意外的全局变量：使用未声明的变量，而意外创建全局变量，导致这个变量一致存在内存中无法被回收；
    2. 被遗忘的定时器或回调函数：设置 setInterval 定时器，如果忘记取消，且执行函数有对外部变量的引用，那么这个变量无法被回收；
    3. 脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留这个元素引用，也无法被回收；
    4. 闭包：不合理使用闭包，从而导致某些变量一致存在内存中；

13. 函数柯里化（Curry Function）
    - 柯里化是一种模式，其中具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数，这种技术帮助编写函数式风格的代码，使代码更易读、紧凑、值得注意的是，对于需要被 curry 的函数，它需要从一个函数开始，然后分解成一系列函数，每个函数都需要一个参数。

# React 相关

1. JSX： js 的扩展语法，允许编写类似 HTML 的代码；可以被编译为常规的 js 函数调用（React.createElement(tag, options)）; React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，React 没有采用将标记与逻辑分离到不同文件这种人为的分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。

2. react 的生命周期：MOUNTING、RECEIVE_PROPS、UNMOUNTING

   - 组件挂载时（状态初始化、读取初始 state 和 props 以及两个生命周期方法，只会在初始化时运行一次）
     - componentWillMount：render 之前调用（在此调用 setState 不会触发 re-render 而是进行 state 合并）
     - componentDidMount: render 之后调用
   - 组件更新时（指组件自身 state 变化或父组件传递给组件的 props 变化因此的一系列动作）
     - 组件自身 state 更新时，依次执行
       - shouldComponentUpdate
       - componentWillUpdate
       - render
       - componentDidUpdate
     - 父组件更新 props 而更新
       - componentWillReceiveProps
       - shouldComponentUpdate
       - componentWillUpdate
       - render
       - componentDidUpdate
   - 组件卸载时（一般在此处清除组件副作用）
     - componentWillUnmount
   - 新版增加了 getDerivedStateFromProps，这个生命周期就是将传入的 props 映射到 state 中。16.4 后，这个函数每次会在 re-render 之前调用，作用是：
     - 无条件的根据 props 来更新内部 state，也就是只要有传入 props 值，就更新 state；
     - 只有 props 值和 state 值不同时才更新 state 值；

3. React 的事件机制和原生 DOM 事件流有什么区别？

   - react 的事件是绑定到 document 上的，而原生的事件是绑定到 dom 上的，因此相对绑定的地方来说，dom 上的事件要优先于 document 上的事件执行；
   - react17 及之前：事件委托在 document 上，所有 react 事件需要冒泡到 document 才被处理；如果页面存在多个 react 版本，事件可能冲突；
   - react18 之后（使用 createRoot）事件委托绑定到 root 容器节点。事件仅在当前 react 树的范围内冒泡，隔离性更好；支持并发渲染，避免潜在的事件拦截问题；
   - 设计原因：
     1. 避免多个 react 版本的事件在 document 层冲突（如微前端场景）
     2. 并发渲染兼容性：事件系统与并发模式（Concurrent Mode）深度集成，root 节点作为边界可控；
     3. 性能优化：减少全局 document 的事件监听，按需绑定到 root 节点；

4. React 函数组件和类组件的区别

   1. 语法和定义方式
      - 函数组件：接受 props 返回 jsx
      - 类组件：ES6，继承 React.Component，必须实现 render 方法返回 jsx；
   2. 状态管理
      - 函数组件：useState
      - 类组件：this.state 和 this.setState
   3. 生命周期方法：
      - 函数组件：useEffect 模拟生命周期
      - 类组件：componentWillMount、componentDidMount、componentWillUpdate 等；
   4. this 绑定问题
      - 函数组件：无 this、直接范围 state/props
      - 类组件：需要手动绑定 this 或在构造函数使用箭头函数
   5. 性能优化：
      - 函数组件：useMemo\useCallback\memo 等
      - 类组件：shouldComponentUpdate 或继承 PureComponent
   6. Hooks 的独占性：
      - 函数组件：可以使用 useState\useEffect\useContext 等；
      - 类组件：无法使用 hooks，只能通过生命周期和类方法实现逻辑；

5. setState 是同步还是异步？

   1. 合成事件与生命周期：在 react 合成事件与生命周期函数中，setState 表现为异步。多次调用会合并更新，并会在未来的某个时机批量处理，不会立即反映到状态中。
   2. 原生事件与定时器：在原生事件和定时器中执行 setState，表现是同步的，执行 setState 后会立即更新状态并出发组件重新渲染；
   3. 异步操作的本质：setState 的异步性并非指内部实现是异步的，而是由于调用顺序和更新机制导致在合成事件和钩子函数中无法立即互殴去更新后的值。
   4. 确保最新数据：若需要在 setState 完成后执行某函数并使用最新状态，可利用其回调函数。该回调函数在状态更新且组件重新渲染后被调用。
   5. setState 的同步异步性取决于其使用环境和方式。

6. 什么是 fiber，fiber 解决了什么问题？
   由于 15 及之前版本的 StackReconciler 方案由于递归不可中断，如果 diff 时间过长，会造成页面的 UI 无响应的表现，vdom 无法应用到 dom 中。为了解决这个问题，16 版本实现了新的基于 requestIdleCallback 的调度器（react 团队自己 polyfill 了），通过任务优先级的思想，在高优先级任务进入的时候，中断 reconciler。为了适配新的调度器，推出了 FiberReconciler，将原来的树形结构（Vdom）转换为了 Fiber 链表的形式（child/sibling/return），整个 Fiber 的遍历基于循环而而非递归，随时可中断。

7. React 组件中的传值方式？

   1. 父传子：props；
   2. 子传父：回调函数；
   3. 跨多层组件：Context/状态管理库；

8. react 中 props 和 state 有什么区别？

   1. props 是传递给组件的（类似函数的形参），而 state 是组件内部组件管理的；
   2. props 不可修改，所有 react 组件都必须像纯函数一样保护它们的 props 不被改变；由于 props 是传入不被改变的，因此将任何仅使用 props 的组件视为 PureComponent，也就是相同的输入下，呈现相同的输出。state 是组件创建的，state 是多变的、可修改的，每次 setState 都是异步更新；

9. react 中 refs 的作用是什么？
   Refs 是 react 提供的安全访问 DOM 元素或者某个组件实例的句柄；

10. React Diff 原理

    1. 把树形结构按照层级分解，只比较同级元素；
    2. 列表结构的每个单元添加唯一的 key，方便比较；
    3. React 只会匹配相同 class 的 component
    4. 合并操作，调用 component 的 setState 方法的时候，React 将其标记为 dirty 到每一个事件循环结束，React 会检查所有标记 dirty 的 component 重新渲染；
    5. 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 控制 diff 性能；

11. 受控组件和非受控组件有什么区别？

    1. 受控组件：数据由 state 驱动，通过 onChange 实时处理，适用于表单复杂需要实时联动校验等场景；
    2. 非受控组件：数据由 DOM 节点管理，需通过 ref 获取，适用于简单表单、文件上传、第三方库集成；
    3. 常见问题：
       1. 为什么文件输入必须是非受控？文件输入是只读的（浏览器限制）无法通过 value 属性控制，必须用 ref 获取文件对象；
       2. 如何让非受控组件支持默认值？使用 defaultValue/defaultChecked
       3. 受控组件性能优化？对高频输入（如实时搜索，使用防抖或避免在 onChange 中执行昂贵操作。

12. 为什么虚拟 DOM 会提高性能？
    虚拟 DOM 相当于在 js 和真实 DOM 中间加了一个缓存，利用 DOM Diff 算法避免了没有必要的 DOM 操作，从而提高性能；

13. React 中 forwardRef 的作用及其应用场景？

    1. 作用：
       1. 打破函数组件的 ref 限制：默认情况下函数组件不能直接接收 ref（因为函数组件没有实例）。forwardRef 允许父组件通过 ref 访问子组件内部的 DOM 节点或自定义值；
       2. 透传 ref 到子组件的特定元素：将父组件传递的 ref 转发到子组件内部的某个 DOM 节点（如 input、div）或类组件实例。
    2. 应用场景：
       1. 访问子组件的 DOM 节点：当父组件需要操作子组件的 DOM 元素（如 focus）
       2. 封装第三方组件库：当封装一个需要暴露内部 DOM 的第三方组件（如自定义 Button 组件需要支持 ref）
       3. 高阶组件（HOC）中转发 ref：在 HOC 中保留原始组件的 ref 引用；
       4. 暴露子组件的自定义方法：通过 useImperativeHandle 配合 forwardRef 暴露子组件的特定方法（而非整个 DOM）
    3. 为什么需要 forwardRef
       1. 函数组件无实例：函数组件没有 this，默认无法通过 ref 获取实例或 DOM；
       2. ref 不是普通 prop：ref 是 React 的保留属性，不通过 props 传递，必须显式转发；
       3. 组件封装性：避免父组件直接操作子组件的内部实现，而是通过 forwardRef 按需暴露特定接口。

14. 什么是合成事件？（React 对浏览器原生事件的封装）

    1. 目的：合成事件是 react 模拟 DOM 事件的一个事件对象，旨在提供一个跨浏览器的事件接口。使得开发者能够通过统一的方式完成对不同浏览器事件的处理；
    2. 特性：合成事件拥有与浏览器原生事件相似的 API，如 stopProppagation 和 preventDefault 方法，并增加了如 nativeEvent 属性等。在 React 中，所有事件都是合成的，而非原生 DOM 事件，但可以通过 e.nativeEvent 属性获取原生事件。
    3. 工作原理：React 采用顶层事件代理机制，保证冒泡一致性，并引入事件池避免频繁创建和销毁事件对象，提高性能。事件不是直接挂载到 jsx 定义的 DOM 节点上，而是通过事件代理挂在到某个祖先节点上。
    4. 16.x 及以前的合成事件：事件委托到 document、部分事件会绑定在当前元素、存在 react 事件和原生事件的映射关系，比如 onMouseLeave 会映射到原生的 mouseout 事件、事件池机制；
    5. 17 后的合成事件：事件委托到 root、react capture 阶段的合成事件提前到原生事件 capture 阶段执行、移除事件池机制、事件具有优先级；

15. react v18 有几种渲染模式？

    1. 传统的同步渲染模式（LegacyMode）：开发者可以通过使用不同的 API（createRoot 或 render）来选择不同的渲染模式；
    2. 并发渲染模式（ConcurentMode）：并发渲染模式通过 Fiber 架构将渲染拆分为多个可中断和可恢复的小任务，并根据优先级进行调度，从而提高渲染效率和用户体验。

16. 什么是高阶组件 hoc？

    1. 定义：react 中用于组件复用和逻辑抽象的设计模式。它是一个函数，接收一个组件作为参数，并返回一个新的组件。
    2. 功能：
       1. 复用逻辑：高阶组件允许开发者在不改变原始组件的情况下，通过封装公共逻辑或者状态，使得多个组件能够共享这些功能，避免编写重复代码，提高开发效率；
       2. 功能增强：高阶组件可以在不修改原始组件的前提下，为其添加新的功能或特性，例如数据获取、权限校验等；
       3. 逻辑抽象：高阶组件可以将复杂的逻辑抽象起来，使得原始组件更加简洁和专注，有助于提高代码可维护性和可读性。
    3. 实际应用场景：
       1. 数据请求：创建一个高阶组件用来处理数据加载功能，可以在多个组件中复用这一逻辑；
       2. 权限控制：通过高阶组件对组件进行权限控制，只有满足特性权限的用户才可以访问某些功能；
       3. 日志记录：创建一个高阶组件来记录组件的渲染信息，帮助调试和监控。

17. 错误边界组件的作用是什么？
    错误边界组件可以捕获并打印发生在其子组件树任何位置的 js 错误，并且它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。 1. 可以捕获子组件的错误，自身的错误捕获不到。 2. 子组件的异步方法错误捕获不到。 3. 通过定义 getDerivedStateFromError 和 componentDidCatch 生命周期，当子组件树发生错误时，getDerivedStateFromError 方法会被调用，并返回一个新的状态对象，用于各高校组件的状态。同时 componentDidCatch 方法会被调用，并接收错误对象和错误信息。

18. React 对插槽（Portals）的理解，如何使用，有哪些使用场景？

    1. 定义：Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀方案；
    2. Portal 是 React16 提供的官方解决方案，使得组件可以脱离父组件层级挂载在 DOM 树的任何位置。

19. React 中如何避免不必要的 render？
    React 基于虚拟 DOM 和 diff 算法的完美结合，实现对 DOM 的最小粒度更新，对于日常开发都能满足需求。但对于复杂功能的业务场景需要考虑性能问题。提高性能最重要的一点是避免不必要的 render

    1. shouldComponentUpdate 和 PureComponent
    2. 利用高阶组件：在函数组件中没有 shouldComponentUpdate 生命周期，可以利用高阶组件，封装类似 PureComponent 的功能；
    3. memo、useMemo、useCallback：可以用来缓存组件的渲染，避免不必要的更新。memo 只能用于函数组件。

20. 展示组件和容器组件的区别

    1. 职责：展示组件负责界面的展示，它接收输入的属性，然后根据这些属性渲染出界面。容器组件负责数据的获取和处理，它把获取到的数据传递给展示组件。
    2. 与数据的关联：展示组件不关心数据来源，只负责展示。容器组件需要和数据源交互，比如从服务器获取数据或修改数据。

21. 设计 React 组件的思路：

    1. 明确组件的职责：确定这个组件是负责展示数据、处理用户交互还是获取数据等；
    2. 定义组件的接口：确定组件接收哪些属性，以及向外暴露哪些方法或者事件；
    3. 考虑组件的复用性：尽量使组件具有通用性，能够在不同的场景下使用；
    4. 处理组件的状态：根据组件的需求，合理地使用状态管理，确保组件的状态使可预测和可维护的。

22. useEffect、useLayoutEffect 与生命周期的对应关系？

    1. useEffect：类似于 componentDidMount、componentDidUpdate 和 componentWillUnmount 的组合。它在组件挂载后执行，在组件更新后如果依赖性发生变化也会执行，并且在组件卸载时可以进行清理操作。
    2. useLayoutEffect：与 useEffect 类似，但它在所有 DOM 变更之后同步调用。可以看作是 componentDidMount 和 componentDidUpdate 在布局阶段的版本。
    3. useEffect 是异步执行，它会在浏览器渲染完成后执行；useLayoutEffect 是同步执行的，它会在所有 DOM 变更后同步调用，在浏览器绘制之前执行。适合需要在 DOM 更新后立即执行的操作，比如读取 DOM 布局信息。

23. React Diff 和 Vue Diff？

    1. react 的 diff 算法基于两个假设：不同类型的元素会产生不同的树；开发人员可以通过设置 key 属性来告知 react 哪些元素在不同的渲染之间是稳定的。在对比时，react 会对新旧虚拟 DOM 树进行深度优先遍历，分层比较节点，当发现节点类型不同时，直接替换整个子树，当节点类型相同且 key 相同，会进行更细致的比较和更新。
    2. vue 的 diff 算法在比较节点时，同样会优先判断节点类型是否相同。在处理列表时也以来 key 属性。不过 vue 的 diff 算法在某些细节上和 React 不同，例如在静态节点和动态节点的处理上，vue 会对静态节点进行优化，尽量减少对静态节点的重复比较。

24. 什么是 Suspense？
    Suspense 是 React 中的一个特性，它主要用于处理异步操作，比如异步加载组件或者数据。它允许组件在等待异步操作完成时显示一个 fallback 状态（如加载提示），当异步操作完成后，再渲染出实际的内容。这使得异步操作再 React 组件中的处理更加优雅和直观。

25. useRef 的应用场景

    - useRef 用于持久化可变值的 hook，其核心特点是跨渲染周期保留引用，且修改它不会触发组件重新渲染。

    1. 访问/操作 DOM 元素：获取原生 DOM 节点的引用；
    2. 存储可变值：替代 useState 存储需要变化但不需要触发 UI 更新的值
    3. 保存定时器/事件监听器：避免因组件重新渲染导致定时器或监听器被重复创建；
    4. 缓存昂贵计算的结果：配合 useMemo 实现更灵活的计算缓存；对比 useMemo，useMemo 依赖变化会重新计算，useRef 手动控制何时更新；
    5. 获取子组件实例（类组件）：通过 ref 访问子组件的方法或属性；
    6. 与 forwardRef 结合暴露特定方法：控制子组件向父组件暴露的接口；避免父组件直接操作子组件 DOM，仅暴露必要接口；

26. React 的 Diff 算法时 VDOM 的核心机制，用于高效计算出新旧虚拟 DOM 树的差异，并最小化对真实 DOM 的操作

    - Diff 算法的基本原则
      1. 同级比较：仅对同一层级的节点进行比较，不跨层级比较（时间复杂度从 n3 - n）
      2. key 优化：通过 key 属性识别稳定节点，减少不必要的重新渲染；
      3. 组件类型优化：优先比较组件类型，类型不同直接替换；
    - Diff 算法的详细步骤

      1. 比较根节点
         - 规则：根节点类型不同时，直接卸载整棵树并重建；
      2. 比较相同类型的 DOM 节点
         - 规则：若节点类型相同（如都是 div）则只变更变化的属性；
      3. 比较相同类型的组件节点
         - 规则：组件类型相同时
           - 保留组件实例，更新其 props
           - 触发组件生命周期（getDerivedStateFromProps，shouldComponentUpdate）
           - 递归比较其子节点
      4. 列表节点的比较（核心）
         - React 对子节点列表采用双端比较算法（16 版本后）步骤如下
           1. 第一轮遍历：从左到右：逐个对比新旧子节点，直到遇到第一个 key 不匹配的节点停止；
           2. 最后一轮遍历：从右到左，从列表末尾开始反向比较，直到遇到第一个不匹配的节点停止。
           3. 处理剩余节点
              1. 场景 1：新列表有剩余节点 - 创建新 DOM
              2. 场景 2：旧列表有剩余节点 - 删除旧 DOM
              3. 场景 3：乱序节点 - 同过 key 匹配移动节点（尽量复用）
      5. key 的作用：
         1. 唯一标识：帮助 React 识别哪些节点是稳定的、可复用的；

    - Diff 算法的优化策略

      1. Batching（批处理）：将多次 DOM 更新合并为一次
      2. 惰性处理：优先处理用户可见区域的变更（如 React Fiber 的时间切片）
      3. 跳过子树：若 shouldCOmponentUpdate 返回 false，则跳过整个子树的 diff；

    - 为什么 React Diff 高效？
      1. 广度优先分层比较：减少递归深度；
      2. Key 的合理使用：最大优化节点复用；
      3. 组件颗粒度控制：通过组件类型快速跳过无变化子树；

# Nextjs 相关

1. nextjs 重新设计了一套路由？

   1. 与服务器端渲染集成：nextjs 的路由主要是为了更好地与服务器端渲染配合，能够根据不同的请求路径在服务器端动态生成页面，而传统的 react router 主要是基于客户端渲染；
   2. 简化开发流程：它提供了更简洁的路由定义方式，比如基于文件系统的路由，开发者可以通过文件结构来直观地定义路由，减少配置的复杂性。

2. Nextjs 中获取数据有哪些方法？

   1. getStaticProps: 用于在静态生成（SSG）时获取数据，在构建时运行，可以获取数据并将其作为 props 传递给页面组件；
   2. getServerSideProps：用于在服务器端渲染（SSR）时获取数据，在每个请求时运行，同样将数据作为 props 传递给页面组件。
   3. 直接在组件内部获取数据（如使用 useEffect 等）：这种方式适用于客户端获取数据，但需要注意数据加载的时机和性能影响。

3. ServerComponent 的整个渲染过程时怎么样的？在这个渲染过程中 ServerComponent 和 ClientComponent 有什么区别？

server component 出现的目的是为了更靠近服务器能更快速的拿到请求的数据，而服务器的渲染过程中，会构建一个未完成渲染的可序列化的 react tree，然后里面会包含 client component 的节点，而这些节点会被 bundler 处理为只有 id，props 的属性和保留对客户端组件的这么一个节点，又因为所有的 props 都必须时可序列化的，所以像 onClick 这些事件处理方法自然不能给到服务器组件了。
当浏览器接收到服务器返回的 JSON 后，会重新构建 react tree，通过 bundler 将之前的节点引用，替换成对应的客户端组件。
而当 react 组件需要 promise 等待数据的获取时，需要用到 suspense 来包裹，所有在一开始生成 RSC 时，遇到时会通过一个占位符（fallback）来占据这棵构建树的节点，当完成 promise 请求后会再次调用服务端组件函数，完成后再将其流式传递到浏览器，替换原来的占位符。

4.  nextjs 的水合：指客户端渲染时，react 会尝试重用服务端渲染生成的 HTML 结构，然后在其上面绑定事件和状态恢复，以提高性能和用户体验。

5.  nextjs 常见错误:Hydration Failed 如何解决？
    所谓水合（Hydration）指的是 React 为预渲染的 HTML 添加事件处理程序，将其转为完全可交互的应用程序的过程。水合的前提是 DOM 树和组件树渲染一致。出现水合错误的常见原因如下：

    1. HTML 元素错误嵌套：比如在 p 标签里又嵌套一个 p 标签。除了 p 嵌套错误，其他可能的还有：
       - p 嵌套在另一个 p
       - div 嵌套在 p 中
       - ul 或 li 嵌套在 p 中
       - 交互式内容（所谓交互式内容，指的是专门用于用于交互的内容，比如 a、button、img、audio、video、input、label 等等）不能能嵌套
    2. 渲染时使用 typeof window !== "undefined"等判断；这个错误只会出现在客户端组件中，因为 next14 采用基于 React Server Component 架构后，只有客户端组件才会在客户端进行水合，服务端组件直接在服务端进行渲染，并不会在客户端进行水合。服务端渲染的时候，因为在 noed 环境下，isClient 为 false，返回 server，而在客户端的时候，会渲染成 client，渲染内容不一致导致出现水合错误。
    3. 渲染时使用客户端 API 如 window、localStorage 等：原因和 2 差不多，因为服务端没有相应的 API，可能出现服务端渲染和客户端渲染不一致的。
    4. 使用时间相关的 API，如 Date：原因在于服务端渲染和客户端渲染的时间不一致，客户端组件它会先在服务端进行依次预渲染，传给客户端后还要进行一次水合，添加事件处理程序，最后根据客户端事件进行更新。所以客户端组件可以简单理解为“SSR+水合+CSR”
    5. 浏览器插件导致：根本原因是有些插件会在页面加载之前修改页面结构，导致 DOM 渲染不一致。
       解决水合 Failed 的方法：
    6. 使用 useEffect：如果要使用客户端的 API，应该尽可能放在 useEffect 中。
    7. 禁用特定组件的 SSR 渲染：渲染不一致的本质是客户端组件既要在服务端也要在客户端渲染一份，因此可以直接取消客户端组件的服务端渲染（借助 nextjs 提供的 dynamic 函数）
    8. 使用 suppressHydrationWarning 取消错误提示：如果实在无法避免可以添加 suppressHydrationWarning={true}属性取消错误提示。该方法是 react 提供的，只能用于一层深度。建议不过度使用；
    9. 自定义 hook（本质是 1 的封装）

6.  Nextjs 中，服务端组件和客户端组件的渲染流程是混合进行的，两者协作以优化性能和用户体验。

    1. 服务端组件
       - 渲染阶段
         1. 请求阶段
            1. 用户访问页面时，nextjs 服务器接收到请求
            2. 识别页面中的服务端组件（默认所有为服务端组件，除非进行标记）
         2. 数据获取
            1. 服务端组件可以直接在组件内部使用 async/await 获取数据（如数据库查询、API 调用）
         3. 渲染为静态 HTML
            1. 服务端组件在服务器上渲染为纯 HTML 和 JSON（不包含 React 状态和事件逻辑）
            2. 生成的 HTML 包含客户端组件的“占位符”
         4. 响应返回
            1. 将渲染好的 HTML、JSON 数据（用于客户端 Hydration）和客户端组件代码一起发送给浏览器。
       - 特点
         1. 无客户端 js：不包含 useState、useEffect 或浏览器 API
         2. 自动代码俄方额：仅发送必要的组件代码到客户端
         3. SEO 友好：内容完全在服务端渲染，可以被爬虫直接抓取；
    2. 客户端组件
       1. 渲染流程
          1. 服务端预处理
             1. 服务端识别客户端组件（通过“use client”标记）
             2. 服务端生成该组件的静态 HTML 占位符，标记为需要客户端 js
          2. 客户端 Hydration
             1. 浏览器接收到 HTML 后，下载客户端组件的 js 包
             2. React 在客户端激活（hydrate）组件，将静态 HTML 转换为可交互的 React 组件；
             3. 恢复状态（如从服务端传递的初始 props）
          3. 后续交互
             1. 用户点击（如点击按钮）触发客户端组件的状态更新，重新渲染仅发生在客户端。
       2. 特点：
          1. 完整的 react 能力：支持 useState\useEffect、事件监听等；
          2. 渐进式增强：初始内容由服务端渲染，后续交互由客户端处理；
    3. 混合渲染流程（服务端+客户端组件）

    ```jsx
    import ClientCounter from "./clientCounter";

    export default async function Page() {
      const serverData = await getData();

      return (
        <div>
          <h1>{serverData.title}</h1> {/* 服务端渲染 */}
          <ClientCounter initialCount={serverData.initialCount} /> {/** 客户端组件 */}
        </div>
      );
    }
    ```

        1. 服务端
            1. 渲染Page为HTML（包含serverData.title的静态内容）
            2. 为ClientCounter生成占位符，并嵌入serverData.initialCount作为初始props
        2. 客户端
            1. Hydrate ClientCounter；使用initialCount初始化状态；
            2. 用户点击按钮时，仅更新ClientCounter的客户端状态；

    4. 如何选择？
       1. 优先使用服务端组件：静态内容展示、需要直接访问后端数据或敏感逻辑
       2. 必须使用客户端组件：需要交互、使用浏览器 API
    5. 高级场景
       1. 服务端组件可以嵌套客户端组件，反之亦然；
       2. 客户端组件中无法直接导入服务端组件（需通过 children 传递）
       3. 结合 next/dynamic 实现按需加载客户端组件；
    6. 性能优化：
       1. 减少客户端 js：将非交互部分保留位服务端组件
       2. 流式渲染：使用 Suspense 分块发送 HTML；

7.  NextJS 渲染原理

    1. Page Router
       1. 页面路径：基于 pages 目录的文件结构
       2. 渲染方式：通过 getStaticProps(SSG)、getServerSideProps(SSR)或默认客户端渲染（CSR）显式声明；
    2. App Router
       1. 页面路径：基于 app 目录的文件结构，支持嵌套布局和 React Server Components
       2. 渲染方式：根据组件类型（服务端组件/客户端组件）自动选择最优渲染策略；
    3. 核心渲染流程
       1. 请求阶段
          1. 用户访问 URL：浏览器发起页面请求
          2. 服务器路由匹配：nextjs 服务器根据 app 目录结构匹配对应的页面组件
       2. 服务端组件渲染
          1. 数据获取：服务端组件直接使用 async/await 获取数据
          2. 静态 HTML 生成：服务端组件在 Nodejs 环境中渲染为 HTML，不包含客户端 js
       3. 客户端组件处理
          1. 标记与代码分割：通过“use client”指令标记的客户端组件会被单独打包
          2. 占位符注入：服务端生成的 HTML 中包含客户端组件的占位符和初始 props
       4. 响应返回
          1. HTML+JSON 数据：服务器返回以下内容：
             1. 静态 HTML（服务端组件渲染结果）
             2. 客户端组件的 js 包（按需加载）
             3. 初始状态数据（嵌入到**NEXT_DATA**脚本中）
       5. 客户端 Hydration
          1. 激活交互性：浏览器下载客户端组件代码后，react 将静态 html 激活为可交互的 spa
             1. 恢复客户端组件的状态（initialCount）
             2. 绑定事件监听器（如 onClick）
       6. 后续导航（Client-Side Navigation）
          1. SPA 行为：通过 next/link 或 next/router 的导航触发
             1. 仅请求目标页面的 json 数据（而非完整 HTML）
             2. 客户端动态更新 DOM，实现无刷新跳转；
    4. 混合渲染策略
       1. 静态生成（SSG）页面无动态数据或使用 generateStaticParams，可以在构建时生成 HTML、CDN 缓存、性能最佳；
       2. 服务端渲染（SSR）页面包含动态数据（如 cookies()、headers()），在每次请求时生成 HTML，支持个性化内容；
       3. 客户端渲染（CSR）：组件标记为"use client"且无服务端数据依赖，需要 Hydration，支持完整交互性。
    5. App Router 和 Page Router 的差异
       1. 数据获取：app 模式在组件中使用 async/await，page 模式通过 getStaticProps/getServerSideProps

# 构建流程相关

1. webpack 中 loader 和 plugin 的区别

   1. 功能不同
      - loader 本质是一个函数，它是一个转换器。webpack 只能解析原生 js 文件，对于其他类型的文件就需要 loader 进行转换；
      - plugin 是一个插件，用于增强 webpack 功能。webpack 在运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 api 改变输出结果；
   2. 用法不同
      - loader 的配置在 module.rules 下进行，类型为数组，每一项都是一个 object，里面描述了什么类型的文件，使用什么加载和使用的参数；
      - plugin 的配置在 plugins 下，类型为数组，每一项都是一个 plugin 实例，参数都通过构造函数传入；

2. webpack 的构建流程

   - 初始化参数，解析 webpack 配置参数，合并 shell 传入和 webpack.config.js 文件配置的参数，形成最后的配置结果；
   - 开始编译，使用得到的参数初始化 compiler 对象，注册所有配置插件，插件监听 webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。
   - 确定入口，从 entry 入口，开始解析文件构建 ast 语法树，找出依赖，递归；
   - 编译模块，从递归中根据文件类型和 loader 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归知道所有入口文件的依赖文件都经过了本步骤的处理；
   - 完成模块编译，在上一步使用 loader 翻译所有模块后，得到每个模块被编译后的最终内容以及它们之间的依赖关系；
   - 输出资源，根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成单独文件加入到输出列表，这步是可以修改输出内容的最后机会；
   - 完成输出，在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统；
   - webpack 构建流程是一个串行的过程。它的工作流程就是将各个插件串联起来，在运行过程中广播事件，插件只需要监听它所关心的事件，就能加入到 webpack 机制，去改变 webpack 的运行，使得系统扩展性良好。

3. webpack 的 tree shaking 原理
   是一个利用 es6 模块静态结构特性去除生产环境下不必要代码的优化过程。其工作原理在于：

   - 当 webpack 分析代码时，它会标记出所有的 import 语句和 export 语句
   - 然后，webpack 确定某个模块没有被导入时，它会在生成的 bundle 中排除这个模块的代码；
   - 同时，webpack 还会进行递归的标记清理，以确保所有未使用的依赖项都不会出现在最终的 bundle 中。
   - 确保使用的是 es6 语法，只有这样才能让 tree shaking 发挥作用；

4. 如何提高 webpack 的打包速度

   - 利用缓存：利用 webpack 的持久缓存功能，避免重复构建没有变化的代码；
   - 利用多进程/多线程构建：使用 thread-loader、happypack 等插件可以将构建过程分解为多进程/多线程；
   - 使用 DllPlugin 和 HardSourceWebpackPlugin：DllPlugin 可以将第三方库预先打包成单独文件，减少构建时间；HardSourceWebpackPLugin 可以缓存中间文件，加速后续构建过程。
   - 使用 TreeShaking：配置 Webpack 的 Tree Shaking 机制，去除未使用代码，减少生成的文件体积；
   - 移除不必要的插件：移除不必要的插件和配置，避免不必要的复杂性和性能开销；

5. vite 比 webpack 快在哪里？

   - 开发模式的差异
     - 开发环境下，webpack 是先打包后启动开发服务器，vite 是先启动，然后再按需编译依赖文件；也就是 webpack 所有模块都需要在开发前进行打包，增加了启动时间和构建时间；vite 采用的策略只有在请求模块时进行实时编译，这种按需编译的模式缩短了编译时间。
   - 对 ESModule 的支持
     - 现代浏览器本身就支持，ESModule，会主动请求去获取所需文件。vite 利用这一点，将开发环境下的模块文件直接作为浏览器执行的文件，而不是像 webpack 那样先打包，再交给浏览器执行，减少了中间环节，提高了效率；
   - 底层语言的差异
     - webpack 基于 nodejs 构建，而 vite 则是基于 esbuild 进行预构建依赖。esbuild 时采用 go 语言编写，go 语言时纳秒级别的，而 nodejs 是毫秒级别的。因此 vite 在打包速度上相比 webpack 有 10-100 倍提升；
   - 热更新的处理
     - wenpack 中，当一个模块或其依赖的模块内容改变时，需要重新编译这些模块；
     - vite 中，当某个模块内容改变时，只需要让浏览器重新请求该模块即可，减少了热更新时间；

6. Monorepo 的理解

   - Monorepo 是一种项目代码管理方式，指单个仓库中管理多个项目，有助于简化代码共享，版本控制、构建和部署等方面的复杂性，提供更好的可重用性和协作性。Monorepo 提倡开放、透明、共享的组织文化；
   - 一个仓库多个相关项目、容易看到代码库的变化趋势，更好的团队协作；
   - 相同版本的依赖提升到顶层安装一次，节省磁盘空间
   - 多个项目都在一个仓库中，没有项目力度的权限管理，一个项目出问题，可能影响所有项目；
   - 多项目共存、编码方便，代码复用性高，方便代码重构，以来调试方便，依赖包迭代的情况下，借助工具自动 npm link，直接使用最新版本依赖，简化操作流程；
   - 多个项目共存，工程配置一致，代码质量标准和风格可以一致化；
   - 构建性 monorepo 工具可以配置依赖项目的构建优先级，可以实现一次命令完成所所有部署；
   - 构建性 monorepo 工具可以配置依赖项目的构建优先级，可以实现一次命令完成所所有部署

7. Node 服务保活（确保稳定运行）需要从进程管理、错误恢复、监控告警、资源优化等多个维度入手；
   1. 进程管理：防止服务崩溃
      1. 使用进程管理工具：PM2（支持自动重启、负载均衡、日志管理）
      2. 集群模式（提升容错能力）利用多核 CPU 启动多个进程，避免单点故障
   2. 错误处理：预防未捕获异常
      1. 全局错误捕获，监听 process.on("unhandleRejection"), process.on("uncaughtException")
      2. 优雅推出：收到 SIGTERM 信号时清理资源
   3. 健康检查与自动恢复
      1. 添加监控检查接口：配合 Kubernetes/Docker 的 livenessProbe 或 Nginx 定期请求；
      2. 心跳检测：使用 node-cron 定时自检关键功能（如数据库连接）
   4. 资源监控与告警
      1. 实时监控工具
         - 基础监控：pm2 monit / node-process-stats(实时查看 CPU/内存)
         - 高级方案：Prometheus + Grafana: 自定义指标
      2. 日志集中管理
         - 工具：ELK（Elasticsearch + Logstash + Kibana）
         - 关键日志：错误日志、重启记录、性能瓶颈警告；
   5. 系统级保活（生产环境必备）
      1. 使用 docker 容器：通过 restart 策略自动恢复；
      2. linux systemd 托管；
   6. 预防性优化
      1. 内存泄漏优化
         - 使用 heapdump 定期生成内存快照分析；
         - 避免全局变量、及时清理定时器/监听器；
      2. 负载均衡
         - 使用 nginx 或 HAProxy 分流请求、避免单进程过载；
   7. 备灾与回滚
      1. 备份关键数据：数据库、配置文件定期备份至云存储
      2. 快速回滚机制：使用 git 标签或 Docker 镜像版本控制；

# HTTP 和浏览器相关

1. GET 和 POST 的区别?

   - 请求参数的位置：GET 请求参数在 URL 后，参数间用&连接，多个参数会造成 URL 长度增加。而 POST 请求的参数包含在请求体中，不会再 URL 中显式；
   - 请求长度的限制：GET 请求参数由于赋加在 URL 后，因此可能受浏览器对 URL 的限制，存在长度限制。POST 请求则没有这个显式，可以传递大量数据；
   - 安全性：GET 请求参数暴露在 URL 中，因此不能用于传输敏感数据，如密码等。POST 参数在请求体中，相对安全（非绝对，安全性还需要依赖其他因素，比如 SSL/TLS 加密等）
   - 幂等性：GET 请求是幂等的，即多次执行同一 GET 请求，服务器返回相同结果。而 POST 请求则是不幂等的，因为每次提交都会创建新的资源。
   - 缓存：GET 请求可以被缓存，POST 则不会，除非在响应头增加适当的 Cache-Control 或 Expires 字段。
   - 后退/刷新按钮的影响：GET 请求可以被浏览器缓存，因此可以通过点击后退/刷新按钮来重复执行，而 POST 不会，因为这些操作对 POST 请求没有实际意义。

2. HTTP2 相对于 HTTP1.x 有什么优势和特点？

   - 二进制分帧层：HTTP2 不再使用文本传输数据，而是将所有数据分割为更小的消息和帧，并以二进制格式进行编码，这有助于高效解析 HTTP 消息，减少错误解析的可能性；
   - 多路复用：HTTP2 引入多路复用，允许在单个 TCP 连接中并行处理多个请求和响应。消除了 HTTP1.x 中的对头阻塞问题，极大提高了网络性能和资源利用率；
   - 头部压缩：HTTP2 使用头部压缩技术，通过共享头部信息，显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著；
   - 服务器推送：HTTP2 允许服务器主动向客户端推送资源，实现了对流量的精细控制，有助于防止网络拥堵和资源浪费；

3. HTTPS 怎么保证安全？

   - 加密传输：HTTPS 使用 SSL/TLS 协议对 HTTP 报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性；
   - 身份验证：HTTPS 通过数字证书对身份进行验证，确保通信双方的真实性，在建立 HTTPS 连接时，服务器会提供数字证书来证明自己的身份，如果验证通过，客户端可以信任服务器，并继续对其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击；
   - 数据完整性保护：在传输数据之前，HTTPS 会对数据进行加密，并使用消息 HASH 算法生成一个 HASH 值，在数据达到接收端后，接收端使用相同的算法对接收到的数据进行 HASH 计算，并与发送端的 HASH 值进行比较，如果一直，说明没有被篡改，如果不一致，通信双方需要重新进行验证或中断。

4. HTTP 状态码

   - 1xx（信息性状态码）
     - 100 Continue：客户端继续请求
     - 101 Switch：切换协议
   - 2xx（成功状态码）
     - 200 OK：请求成功
     - 201 Created：请求已经被实现，并因此创建了一个新的资源；
     - 204 No Content：服务器成功处理请求，但没有返回任何内容；
   - 3xx（重定向状态码）
     - 301 Move Permanently：请求的资源永久移动到新的 URL 上；
     - 302 Found：请求的资源现在临时从不同的 URL 响应请求；
     - 304 Not Modified：客户端执行了 GET 请求，但文件未发送改变；
   - 4xx（客户端错误状态码）
     - 400 Bad Request：服务器无法理解请求
     - 401 Unauthorized：请求要求进行身份验证
     - 403 Forbidden：服务器理解请求，但拒绝执行
     - 404 Not Found：服务器无法找到请求的资源；
     - 405 Method Not Allowed：请求帐指定的方法不被允许
   - 5xx（服务端错误状态码）
     - 500 Internal Server Error：服务器遇到一个未曾预料的情况，导致其无法完成对请求的处理；
     - 501 Not Implemented：服务器不支持当前请求所需要的某个功能；
     - 503 Service Unavailable：由于临时的服务器维护或过载，服务器当前无法处理请求；

5. post 请求为什么会多发送一次 option 请求

   - POST 发送前的 OPTIONS 请求实际上是 HTTP 的一种特性，成为预检请求。这个主要发生在跨域请求的场景中，尤其是当请求涉及一些可能不安全的方法（PUT、DELETE、POST）或使用了一些自定义的 HTTP 头部时；
   - 预检请求的目的是检查服务器是否允许来自不同源的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可；以下是 OPTION 请求的主要特点和原因：
     1. 安全性：HTTP 协议中，GET、HEAD 被认为是安全的，它们不会导致服务器上的资源变化，但诸如 POST、PUT、DELETE 等可能会导致资源创建、修改、删除。因此在发送这些非安全请求之前，浏览器会先发送一个 OPTIONS 请求来询问服务器是否允许这样操作.
     2. 自定义头部：如果请求中包含了某些自定义的 HTTP 头部，浏览器也会发送 OPTIONS 请求来询问服务器是否接受这些头部；
     3. CORS 配置：服务器在响应 OPTIONS 时，可以通过 Access-Control-Allow-Methods、Access-Control-Allow-Headers 等头部来告诉浏览器它允许哪些方法和头部。如果服务器的响应中包含了这些头部，并且允许了客户端想要执行的操作，那么浏览器才会继续发送实际的 POST 请求。

6. http 的请求和响应报文分别是什么样的？
    - 请求报文：由请求行、请求头部、空行和请求正文构成。请求行包含了HTTP方法、请求的URI以及HTTP版本。请求头部则包含若干与请求相关的信息，如Accept-Charset、Accept-Encoding等；空行用于分隔请求头和请求正文；请求正文包含需要发送给服务器的数据；
    - 响应报文：由状态行、响应头部和响应正文组成。状态行包含了HTTP版本，状态码及状态码描述，用于描述请求的处理结果；响应头包含了与响应相关的元信息，如Content-Type、Content-Length等；响应正文则包含了服务器返回给客户端的数据。

7. HTTP中的keep-alive是干什么的？
    - http中的keep-alive称为http长连接，是一种通过重用TCP连接来发送和接受多个HTTP请求的机制。主要作用包括：
        1. 减少连接建立开销：在没有keep-alive的情况下，每次http请求都需要经过TCP三次握手建立连接，这会导致大的延迟和资源消耗。而使用keep-alive可以在一个tcp连接上发送多个http请求，从而减少了建立连接的开销；
        2. 降低网络负载：每次建立和关闭连接，都会消耗网络带宽和服务器资源，通过持久连接，可以减少连接的频繁建立和关闭，从而降低了网络负载和服务器负载；
        3. 提高性能和响应时间：由于避免了连接建立和关闭的开销，keep-alive可以提高请求的响应时间和整体性能。客户端可以在同一连接上连续发送请求，而服务器也可以在保持连接的情况下更快地响应这些请求；
        4. 支持HTTP管道化：HTTP管道化是允许客户端在同一个TCP连接中发送多个请求而无需等待每个请求的响应的技术。与keep-alive结合使用时，可以进一步提高性能；

8. 从输入URL到看到页面发生的全过程
    1. 浏览器解析URL：浏览器内部代码解析URL，首先检查本地hosts文件，看是否有对应的域名，如果有，浏览器直接向该IP地址发送请求，如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名替换成对应的服务器IP；
    2. 建立tcp连接：浏览器得到IP地址后，会通过tcp协议与服务器建立连接，tcp/ip协议是internet的基础，它负责确保数据在网络中的可靠传输，这一过程会进行三次握手，确保双方都已经准备好进行通信；
    3. 发送http请求：tcp连接建立后，服务器会向服务器发送http请求，这个请求包含请求行、请求头、空行、请求正文；
    4. 服务器处理请求：服务器接收到请求后，根据请求内容进行相应的处理。这可能包括数据库查询、生成动态内容等；
    5. 发送http响应：服务器处理完请求后，发送一个http响应给浏览器，这个响应包含状态行、响应头、响应正文；
    6. 浏览器解析和渲染页面：浏览器接收到响应后，会解析响应正文中的html代码，并下载所需的css、js等资源文件。然后，浏览器会根据这些资源来渲染页面，最终呈现给用户；

9. 浏览器缓存的优先级
    1. ServiceWorker缓存：由于其可以完全控制网络请求，因此具有最高优先级，即使是强缓存也可以被它覆盖。ServiceWorker是运行在浏览器背后的独立线程，一般可以用来实现缓存功能，但注意，由于serviceworker中涉及拦截请求，所以必须使用https协议来保证安全；
    2. MemoryCache缓存：这是内存中的缓存，主要包含的是当前页面中已经抓取的资源，如样式、脚本、图片等。对我们访问页面以后，再次刷新页面，可以发现很多内容来自内存缓存；
    3. HTTP Cache缓存，包括强制缓存和协商缓存：
        - 强制缓存：在有效时间内，不会向服务器发送请求，直接从缓存中读取资源。控制强缓存的字段分别是expires和cache-control，其中cache-control的优先级高于expires
        - 协商缓存：当强缓存失效后，浏览器会携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存。控制协商缓存的字段有last-modified/if-modified-since和etag/if-none-match
    4. Disk Cache（磁盘缓存）：存储在硬盘中的缓存，读取速度较慢，但胜在容量和存储时效性上。
    5. Push Cache（推送缓存）：这是HTTP2中的内容，当以上4中缓存均没有命中时，才会被使用；

10. 为什么会存在跨域，及常见的跨域解决方法？
    - 跨域的存在主要原因是浏览器的同源策略限制；同源策略是浏览器的安全机制，旨在防止一个域的脚本与另一个域的内容进行交互，以保护用户免受诸如跨站脚本攻击和跨站请求伪造等安全威胁。所谓同源，指的是两个页面具有相同协议、主机和端口。当三个条件任意一个不同时，就会触发跨域问题；
    - 常见的跨域解决方法：
        1. JSONP：利用标签不受同源策略控制的限制，通过动态插入标签来请求不同源的资源。JSONP只支持GET请求，并需要在服务器端进行配合；
        2. CORS（跨域资源共享）：CORS是一种W3C规范，它定义了一种浏览器与服务器交互的方式来确定是否允许跨域请求；通过服务器端设置相应的HTTP头部信息，如Access-Control-Allow-Origin，来允许跨域请求。CORS支持各种http请求方法，并且更加灵活和安全；
        3. 代理服务器：通过搭建一个代理服务器来转发请求，使得前端可以通过代理服务器来简洁访问不同源的资源，这样，前端请求实际在同源服务器，再由服务器去请求不同源的资源；
        4. 使用window.postMessage：window.postMessage是HTML5引入的新API，允许来自不同源的脚本进行通信，通过监听window对象的message事件，可以接收其他窗口发送过来的消息；
        5. 设置document.domain: 如果两个页面同属于一个顶级域名下的不同子域名，可以通过设置document.domain为相同的顶级域名实现跨域，但是这种方式存在限制，并且可能引入其他安全风险；

11. 浏览器的渲染机制：一个复杂且精细的过程，主要涉及解析HTML、CSS、构建DOM树和CSSOM树，然后合并它们以构建渲染树，再进行布局和绘制，最终将页面内容展示给用户。
    - 解析HTML并构建DOM树：当浏览器接收到HTML文档后，解析HTML标签，转为DOM节点，然后按照文档的结构将这些节点组织成一棵树结构，即DOM树。DOM树是浏览器内部表示网页内容的一种方式，它包含了网页中所有的元素和属性；
    - 解析CSS并构建CSSOM树：浏览器解析css代码，将样式规则转为CSSOM节点，并构建成CSSOM树，CSSOM树描述了HTML文档中每个元素的样式信息；
    - 构建渲染树：浏览器将DOM树和CSSOM树合成渲染树，渲染树只包含需要显式的节点和样式信息，不包含隐藏的元素或不可见的样式。这一步是渲染过程中的关键步骤，因为它决定了哪些元素将被渲染以及如何渲染；
    - 布局：构建完渲染树后，浏览器根据渲染树的信息计算每个节点的位置和大小，生成布局。这个过程也称为重排或回流，它涉及到对元素的位置和尺寸进行精确计算，以确保页面元素能够正确显式在屏幕上。
    - 绘制：布局完成后，浏览器会将每个节点的样式信息转换为像素，然后绘制到屏幕上。这个过程也称为重绘，涉及到将元素的视觉表现绘制出来；


12. 什么是重绘和回流及怎么减少重绘和回流？
    - 重绘：当页面中元素的样式改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程是重绘；
    - 回流：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程是回流；
    - 减少重绘和回流的方法：
        1. 避免频繁操作样式：尽量一次性修改多个样式属性，而不是逐一修改；
        2. 利用css3动画：css3动画和过渡不会触发回流，它们是通过GPU进行渲染的；
        3. 避免使用table局部：table布局发生在变化时可能需要多次计算，这会增加回流次数，尽量使用flexbox或grid等现代布局技术；
        4. 批量修改DOM：如果需要添加、删除或修改多个DOM节点，可以考虑使用DocumentFragment或离线节点，这样可以在一次回流中完成所有操作；
        5. 使用绝对布局：绝对布局的元素不会触发其父元素及后续元素的回流，因为它们脱离了正常的文档流；
        6. 避免使用内联样式：内联样式会增加重绘和回流的可能性，因为它们直接修改元素样式，尽量使用css文件管理；
        7. 利用图片加载：使用合适的图片格式和大小，避免使用大量图片，减少页面的渲染负担；
        8. 利用浏览器的缓存机制：对于不经常改动的资源，可以利用浏览器的缓存机制来减少请求次数，从而加快页面加载速度；

13. 浏览器的事件机制：主要涉及到事件的触发、传播和处理；当用户在浏览器进行某些操作时，如点击、移动鼠标或输入文本，会触发相应的事件，这些事件封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用；

    - 事件的传播分为三个阶段：捕获阶段、目标阶段和冒泡阶段；在DOM2级事件模型中，事件首先在最外层HTML进行捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理函数的元素。接着，事件处理器在目标的元素上执行，这是事件处理的核心阶段；最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件；
    - 事件处理过程中，浏览器维护事件队列，一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器支持宏任务和微任务的概念，用于管理异步执行的任务。
