
# vue组件中style标签加入scoped的原理及其作用？
* 使用style scoped标签是为了实现css样式的局部作用域，确保组件内部的样式仅对该组件内的元素生效，不会影响其他组件或全局样式。
* 原理：
    1. 唯一标识符生成：当style scoped被编译时，vue在组件的dom元素上添加一个唯一的、不可见属性（data-v-xxx），其中xxx是一个随机生成的哈希值，确保每个组件实例都有一个独一无二的标识；
    2. css选择器改造：编译器会修改style scoped中的css选择器，使其包含对应的唯一标识，具体做法是在每个选择器前添加一个属性选择器，如data-v-xxx或:scope[data-v-xxx]（取决于所使用的编译器和vue版本），这样原本的css规则就会变成
    ```css
    .my-class {
        color: red;
    }
    [data-v-xxx] .my-class {
        color: red;
    }
    ```
    这意味者只有带相应的data-v-xxx属性的元素才会匹配到这些样式，即组件内部的元素；
* 作用
    1. 防止样式污染：scoped属性确保组件样式只对当前组件的DOM元素，避免了不同组件样式之间同名干扰，由于编译后具有各自的独特标识符，它们之间的样式不会混淆，极大增强了大型项目的可维护性和可扩展性，尤其是当多个开发者协作时，每个人可以专注于自己组件的样式编写，无需担心影响其他组件或全局样式；
    2. 简化样式调用：由于scoped样式具有明确的局部性，当在浏览器开发者工具中检查组件时，可以很容易识别出哪些样式规则是由当前组件的style scoped定义的，这有助于快速定位和调试样式问题；
    3. 提供组件的独立性：使用scoped有助于实现组件的完全封装，使得组件在任何上下文中都能保持一致的外观和行为。这符合vue倡导的“单一职责原则”和“组件化开发”，使得每个组件都可以作为一个独立、可复用的单元；
    4. 促进代码复用：尽管scoped样式限制了样式的作用范围，但vue仍然允许通过css变量、后代选择器等方式在组件内部实现样式夫哟个，同时，对于需要在多个组件间共享的样式，可以将其提取到单独的全局或模块化css中，保持整体风格的一致性；
* 注意：
    * 尽管scoped样式大大减少了样式冲突的风险，但在某些情况下仍可能出现“样式穿透‘问题。例如，当子组件需要覆盖父组件的样式，或者需要对深层嵌套的后台元素应用样式是，可能需要使用deep修饰符来打破scoped的限制；不过应当谨慎使用此类穿透技巧，因为它可能削弱scoped样式带来的隔离效果。在实际开发中，应优先考虑通过调整组件结构或使用css选择器的恰当组合来避免过度依赖穿透；
    * vue组件中style scoped的原理时通过为组件dom元素添加唯一标识符并在css选择器中引用该标识符，从而实现样式作用域的局部化。这一特性对于防止样式污染、简化调试、增强组件独立性和促进代码复用具有重要意义；

# provide和inject
* vue框架中用于跨组件通信的一种依赖注入机制，主要在于没有直接父子关系的组件间传递数据；在vue2/vue3中，两者API的基本概念和用途相同，但在实现细节和用法上存在一个差异。

## vue2中provide和injec
1. provide：
    * 在父组件中使用，通常作为选项对象的一个属性
    * 定义一个对象或返回对象的函数，该对象的属性代表要向下传递的数据
    * 提供的数据对所有子孙组件可见，但不会出现在父组件模板的props，也不需要子孙组件显式声明接收
2. inject：
    * 在子组件中使用，作为选项对象的一个属性
    * 通过键值对形式指定需要从祖先组件中注入的数据
    * 注入的数据通常会作为子组件实例的属性存在，可以直接在模板或方法中使用。
3. 特定：
    * 非响应式：默认情况下，通过provide传递简单类型是非响应式的，如果传递一个对象，虽然对象的属性值可以是响应式的，但整个对象的替换不会触发子组件中注入的数据更新；
    * 深度注入：vue2中的inject可以接收一个from选项，用于指定从哪个祖先组件开始查找注入的数据，这有助于解决深层次嵌套组件中同名提供者的问题；

## vue3中provide和inject
1. provide：
    * 在父组件中使用，通常作为setup函数的返回值的一部分，通过provide函数定义
    * 可以传递响应式对象，这意味着无论是简单类型还是复杂类型，只要它们处于vue的响应式系统中，变化都会自动同步注入到子组件中；
2. inject
    * 在子组件中使用，通常在setup函数中通过inject函数接收注入的数据
    * 不再支持from选项，因为vue3的依赖注入系统已经能够自动处理同名提供者的冲突，按照最近祖先的原则进行注入；
3. 特点：
    * 响应式增强：vue3中的provide和inject支持响应式数据的自动同步，无论传递的是简单类型还是复杂对象，只要是响应式，改变这些数据，注入数据的子组件都会更新；
    * Composition API：在vue3的composition API中，provide和inject作为函数使用，更自然融入到setup函数的逻辑中，使得代码组织更加清晰；

# Promise中的值穿透是什么？
1. 指的是在链式调用.then或.catch方法时，如果传递给这些方法的回调函数参数不是函数，而是直接传递了一个值（如基本类型、对象或另一个Promise实例），那么该值不会被当作回调函数执行，而是直接作为下一个.then或.catch链中结果值传递下去，这种行为就像是该值”穿透”了当前的then和catch处理阶段，直接进入了后续的处理链；
    * 基本值穿透
    ```js
    Promise.resolve(1).then(2).then(val => {
        console.log(val); // 2
    })
    ```
    在第一个then中直接传递值2，而不是一个函数，由于这不是一个有效的回调函数，所以2作为值传递到下一个then中，在那里都被当作正常的resolve值处理；
    * Promise实例穿透
    ```js
    Promise.resolve(2)
        .then(Promise.resolve(3))
        .then(val => {
            console.log(val); // 3
        })
    ```
    在这里，传递给then是一个立即resolve为3的promise实例，由于它不是回调函数，该promise实例作为值穿透到下一个then，在他那里的内部值作为resolve的值处理；
2. 值穿透机制简化了某些场景下的代码编写，例如当想要在promise链中插入一个固定的值，而不需要额外定义一个只返回该值的回调函数。然而，这种特性也可能导致意料之外的行为，特别是当误将预期作为回调函数传递的值直接传递时，因此，在编写promise链时，应确保正确使用回调函数，避免无意中的值穿透导致逻辑错误，如果确实希望直接传递一个值作为后续链的输入，应确保这是有意为之，并且符合预期的程序逻辑；

# 如何确定页面的可用性时间，什么是Performance API？
* 确定页面的可用性时间通常是指测量用户首次能够与页面进行有效交互的时间点，特称为”首次可交互时间”（FID）或“可交互时间”（TTI）。这是一个关键的性能直播，因为他反映了用户对网页响应速度的实际感知。确定页面可用性时间通常设计一下几个步骤：
1. 使用performance api
    * 这是浏览器提供的一个强大工具集，用于收集和测量与网页性能相关的各种指标，如加载时间，资源请求，渲染事件等。以下是如何使用performance api来确定页面可用性时间：
        1. 初始化标记：在页面加载初期（DOMContentLoaded）设置一个初始化标记，表示此时DOM结构已加载完成，但可能还有异步资源加载脚本，图片，文字等在加载中；
        2. 监控关键资源加载：监听performance对象的resource timing数据，跟踪关键资源的加载完成情况，这些资源的加载可能直接影响页面的可交互性；
        3. 检测主线程空闲：主线程是否长时间无阻塞，可以判断页面是否可交互的重要依据，可以使用requestIdleCallback、performance.now()、performance.mark()和performance.measure()等方法来监控主线程的忙碌状态和耗时；
        4. 计算关键渲染路径：分析关键渲染路径，即从html到cssom构建、布局、绘制和合成的过程。performance api提供了performanceObserver接口，用来监听paint、first-contentful-paint、largest-contentful-paint等与渲染密切相关的事件；
        5. 评估交互响应能力：通过检查是否有长任务阻塞主线程或者观察longtask事件，来判断页面是否具备足够的响应能力。长任务是js执行、样式计算、布局和渲染等过程，如果这些过程持续时间长，导致用户无法及时页面交互；
        6. 计算TTI：综合上述信息，根据一定的算法计算出页面的tti，tti通常定义为最后一个长任务结束之后，主线程连续一段时间内无诸塞，且关键资源已加载完成的时刻；
2. 可以使用第三方工具：lighthouse、webpagetest等工具，它们已经封装好了计算TTI等相关性能指标的逻辑，可以简化测量过程；

# Koa和Express有什么不同？
* 两者都是类型的nodejs的web服务器框架，旨在简化构建服务器端应用程序的过程，但存在一些关键的设计理念和实现上的差异；
1. 设计哲学和定位
    * express
        * 增强型框架：以增加便利性和扩展性为核心，为nodejs提供了一套丰富的中间件系统和便捷的API，内置了许多常用的中间件如路由、静态文件服务等，使开发者能够快速搭建功能完备的web应用；
        * 广泛兼容：遵循nodejs社区的传统开发模式，支持回调函数、promise、以及后来通过第三方中间件支持的async/await。其庞大且成熟，有众多的第三方中间件可供选择；
    * Koa
        * 轻量级重构：被设计为一个更轻量级、更纯粹的基础框架，它重新审视了nodejs的HTTP服务器开发问题并尝试解决其中的痛点，如回调地狱和错误处理，koa并未提供大量内置中间件，而是提供了简洁的核心api和强大的中间件机制，鼓励社区围绕它构建模块化的解决方案；
        * 现代异步编程：一开始就拥抱es6及更高版本的js特性，早期版本使用generator函数和co模块实现协程式控制，后续版本直接基于async/await实现异步操作，遵循更直接的同步式代码风格；
2. 异步处理和中间件执行模型
    * express
        * 传统的回调链：express中间件通过回调函数实现，每个中间件按照注册顺序依次执行，下一个中间件在前一个中间件的回调中被调用。这种模型易于理解，但涉及复杂的异步逻辑时，可能导致深度嵌套的回调函数（回调地狱）。
    * Koa
        * 洋葱模型：koa利用generator函数或async/await实现了独特的洋葱模型中间件执行机制，中间件在请求处理过程中会被执行两次：先从外向内进入，然后从内部向外退出。这种模型允许中间件在请求和开始结束阶段都能访问和修改上下文，使得中间件之间可以更灵活地交互和共享状态，同时保持代码的清晰和简洁；
3. API和上下文对象
    * express
        * req/res对象，express基于nodejs的原生http模块，中间件直接操作req和res对象，这些对象提供了丰富的属性和方法用于处理http请求和响应；
    * Koa
        * ctx对象，koa引入的统一ctx，它封装了req、res并将常用的方法和属性提升到自身，如request、response、body、status等，使得代码更具一致性，较少对原始req和res的直接操作；
4. 错误处理
    * express
        * 明确定义错误处理中间件：express需要显式定义错误处理中间件，这些中间件通常放置在其他中间件之后，并通过四个参数的形式接收错误对象。如果没有捕获到的错误被传递给next函数，会触发这些错误处理中间件；
    * Koa
        * 隐式错误传播：koa中，当一个中间件抛出错误或返回带有catch方法的promise时，该错误会被自动传递给下一个能处理错误的中间件，这种设计简化了错误处理流程，无需显式定义错误处理中间件的位置；
5. 生态和社区
    * express：庞大而成熟的生态
    * koa：专注核心，生态相对较小

