
# Ajax、Axios、Fetch的区别

## Ajax
1. 概念：ajax不是一个具体的库，而是一套使用XMLHttpRequest或fetch api等技术在后台与服务器交换数据、更小部分网页内容，而无需加载整个页面的编程模式。现在普遍使用JSON替代XML作为数据格式。
2. 特点：
    * 原生API：ajax基于浏览器原生的XMLHttpRequest或Fetch API实现；
    * 手动管理：使用Ajax需要手动编写和管理请求各个步骤，代码量相对较大、易用性低；
    * 兼容性好：由于基于原生API、Ajax具有良好的浏览器兼容性，几乎所有的现代浏览器都支持；

## Axios
1. 概念：一个流行的开源js库，提供了一种基于Promise的、易于使用的接口，用于发出HTTP请求，它封装了XMLHttpRequest或Fetch API、，简化Ajax开发工作；
2. 特点：
    * Promise基础：Axios基于promise设计，支持async/await，便于进行异步流程控制；
    * 功能丰富：提供请求和相应拦截、自动转换请求/响应数据、取消请求、超时设定、请求/响应配置等高级功能；
    * 跨平台：不仅支持浏览器环境，还可以在node环境中作为http客户端使用
    * 简洁易用：api设计直观，只需几行代码就能完成复杂的请求操作，大大简化网络请求的编写和管理；

## Fetch
1. 概念：原生浏览器提供，基于promise的现代替代品，用于取代传统的XMLHttpRequest以进行网络请求；
2. 特点：
    1. 原生支持：fetch开箱即用
    2. promise基础：基于promise，易于使用async/await进行异步编程
    2. 简介现代：api设计简洁，使用更符合现代js风格的选项对象进行配置
    3. 功能扩展：可以通过window.Headers/window.Request/window.Response等相关API进行更精细的控制请求和相应；
    4. 局限性：fetch api的默认行为与XMLHttpRequest不同，如缺少错误处理，不支持自动转换非200状态码的相应为json，以及对跨域请求cors的支持不如xhr自然；

## 比较与选择
1. ajax通常指的是基于XHR的原始网络请求编程方式，如今更多作为一种泛称而非具体实践方式被提及。在实际开发中，往往会选择axios或fetch api而非直接使用原生XHR。
2. axios以其丰富的功能、良好的易用性和跨平台能力受到广大开发者青睐，适用于大多数web项目的网络请求，特别是在需要高级特性的情况下；
3. fetch api作为原生标准，具有较小的体积和开箱即用的优势，适用于追求简介、轻量化，或者对浏览器兼容性要求较高的项目；但在使用fetch时需要注意处理其默认行为的特殊之处，并可能需要额外polyfill来支持旧版浏览器；

# 对称加密与非对称加密的区别和用处；
## 区别
1. 密钥数量和性质
    * 对称加密：仅使用一个密钥进行加密和解密。这个密钥对双方是相同的，必须通过安全的途径共享给对方；
    * 非对称加密：使用一对互相关联的密钥，包括公钥和私钥。公钥可以公开，任何人都可以使用公钥加密数据，而私钥必须保密，只有拥有的人才可以解密数据；
2. 安全性：
    * 对称加密：取决于密钥的安全保管。一旦密钥泄露，加密数据就可以被破解。密钥管理成本随着通信参与者数量增加而加大；
    * 非对称加密：即使公钥公开，只要私钥安全，数据是安全的。攻击者想要破解，必须攻破基于数学难题的密码学难题，难度高于对称加密。但是，私钥保护至关重要，一旦泄露，所有使用该私钥加密的数据都将面临风险；
3. 计算效率
    1. 对称加密：由于只有一个密钥参与运算，加密和解密速度快，适合大数据量的加密传输；
    2. 非对称加密：由于涉及复杂的数学运算，加解密速度相对慢，不适合直接加密大量数据，通常用于加密少量敏感数据信息，用于建立安全信任；
4. 使用场景
    1. 对称加密：适用于数据量大，实时性要求高的场景，如文件加密存储，实时视频流加密、数据库内部数据加密等；
    2. 非对称加密：适用于密钥交换，身份认证，数字签名等场景，如HTTPS协议中的密钥协商；
## 用处
1. 对称加密的用处、
    * 数据保护：对敏感数据进行加密存储，防止未尽授权的访问
    * 实时通信：在即时通讯、视频会议、在线游戏等实时服务中，对传输数据进行实时加密，保证通信隐私；
    * 批量输出传输：在云存储、备份服务、数据库同步等场景中，对大量数据进行高效加密传输；
2. 非对称加密的用处
    * 密钥交换：在需要安全通信的双方之间，通过非对称加密交换对称密钥，如SSL握手过程中的Diffie-Hellman密钥交换或RSA密钥交换；
    * 身份验证：通过公钥加密一段消息，只有持有对应私钥的一方才能正确解密，以此证明身份；
    * 数字签名：使用私钥对数据摘要进行加密，形成数字签名。他人可以用公钥验证签名，确认数据违背篡改且确出自私钥持有者之手，用于软件更新包验证、电子合同签署等场合；
    * 数据加密：尽管非对称加密直接用于大量数据加密效率低，但在某些场景下仍可直接用于数据加密；

# DNS的具体解析过程
1. DNS（域名解析）的具体解析过程涉及多个步骤和交互，旨在将人类可读的域名转换为用于网络通信的IP地址，详细的DNS解析过程如下：
    * 客户端查询：当用户在浏览器或其他应用程序中输入一个域名并请求访问时，应用程序首先检查本地操作系统中的hosts文件，如果hosts文件存在该域名的IP地址映射条目，系统将直接使用该IP地址进行连接，无需进一步的DNS查询
    * 本地DNS缓存查询：如果hosts文件中没有匹配项，应用程序将请求操作系统的本地DNS解析器。解析器首先检查本地DNS缓存，这是一个存储近期查询结果的临时数据库。如果缓存中有目标域名的有效IP地址记录，则直接返回该记录，避免对外部DNS服务器的查询。
    * 递归查询至本地DNS服务器：若本地缓存未命中，解析器发起一个递归查询请求到配置的本地DNS服务器（通常是ISP提供或手动设置的）。本地DNS服务器负责代表客户端完成整个解析过程，直到找到最终答案；
    * 迭代查询与根域名服务器：本地DNS服务器首先检查自身是否已缓存有目标域名的记录。如果没有，它将开始迭代查询。首先，向根域名服务器发送请求，询问负责顶级域名的权威名称服务器的地址；
    * 迭代查询与权威域名的服务器：TLD服务器回应指向二级域名权威服务器的指针。本地DNS服务器继续向二级域名的权威名称服务器查询具体的主机记录。权威服务器维护着该域名区域的所有记录，并能够直接返回准确的IP地址或相关资源记录；
    * 响应和缓存：权威域名服务器将目标域名的IP地址或其他响应数据返回给本地DNS服务器。本地DNS服务器接收到结果后，不仅将其转发给最初发起查询的应用程序，还会根据记录的TTL值将其缓存起来，以备后续相同查询使用。这样可以加速后续对同一域名的访问；
    * 客户端接收响应：应用程序收到ip地址后，即可使用该地址建立于目标服务器的网络连接，进而获取网页内容，发送电子邮件或其他网络服务。
2. 总结过程：客户端查询 - 本地DNS缓存 - 递归查询至本地DNS服务器 - 递归查询与根域名服务器 - 迭代查询与权威域名的服务器 - 响应和缓存 - 客户端接收响应；

# 浏览器的解析渲染过程
1. 解析HTML：浏览器接收到服务器返回的HTML文档后，通过其内置的HTML解析器开始解析这些文本内容。解析过程中，HTML标签解析为DOM节点，形成一颗DOM树。每个节点包含元素类型、属性以及对应的文本内容。这个过程遵循HTML标准定义的语法规则，遇到任何语法错误时，浏览器会尝试进行容错处理；
2. 解析CSS：浏览器开始解析与HTML文档相关的css样式表。这包括内联样式、style标签内的样式以及外部样式文件。css解析器将css规则转为cssom，即css规则树。每条css规则则对应一个或多个cssom节点，描述了如何应用到对应的DOM节点；
3. 构建渲染树：随着DOM树和CSSOM树的构建完毕，浏览器会将两者合并成一个渲染树。渲染树仅包含那些需要显示在屏幕上的可见DOM节点，以及应用于这些节点的最终计算样式。例如，对于设置display：none的元素，虽然它们存在于DOM树，但不会出现在渲染树，因为不需要进行渲染；
4. 布局：有了渲染树，浏览器可以进行布局，确定每个可见节点在视口内的确切位置和尺寸。布局算法会遍历渲染树，计算每个节点的几何信息。这一过程考虑了css盒模型、定位、浮动等因素；
5. 绘制：布局完成后，浏览器进入绘制阶段，按照渲染树的顺序、逐个节点进行绘制操作。绘制涉及到填充颜色、描边边界、渲染背景图像、文字渲染等具体图形操作。复杂的节点可能需要多次绘制。
6. 分层：对于复杂场景，浏览器可能会将渲染树的不同部分分割成多个图层。每个图层独立绘制到一块内存中，然后按照正确的堆叠顺序进行合成。这种分层机制有助于提升渲染性能，特别是当部分图层内容相对静止而其他部分频繁变化时，可以只绘制变动的部分；
6. 合成与显示：最后，各图层的信息被提交给复合线程。复合线程负责将这些图层合并成一个完整的帧，并将数据帧发送到GPU进行光栅化处理。GPU将光栅化后的像素数据输出到屏幕上，用户即可看到渲染完成的网页内容。为了实现平滑滚动和动画效果，这个过程通常会在每一帧的时间间隔内重复进行。

# meta元素都有哪些，各自的作用是什么？
* meta元素是html中用于提供网页元数据的一种标签，通常位于文档的head部分。元数据是关于数据的数据，它并不会直接展示给用户，而是提供浏览器、搜索引擎和其他web服务器使用，以便更好地理解、渲染、索引和展示网页。
1. charset（字符集声明）：指定网页的字符编码，告诉浏览器应使用哪种字符集来解码和显示网页内容。最常见的字符集是UTF-8，它支持多种语言和广泛的字符范围；<meta charset="UTF-8" />
2. viewport（视口设置）：针对移动设备优化网页布局，控制浏览器在不同屏幕尺寸和分辨率下的缩放行为。此元标签帮助开发者定义网页在移动端浏览器视口的大小、初始缩放比例、最大最小缩放限制等参数，确保响应式设计的正确展现；<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
3. description (网页描述)：描述网页的简短描述，用于搜索引擎优化。 <meta name="description" content="description" />"
4. keywords (网页关键字)：定义网页的关键字，用于搜索引擎优化。 <meta name="keywords" content="keywords" />"
5. robots (搜索引擎爬虫指令)：定义网页的爬虫行为，用于搜索引擎优化。 <meta name="robots" content="index,follow" />"
    * index: 允许搜索引擎将该页面添加到其索引中；
    * nofollow：建议搜索引擎不要跟随该页面上的任何链接；
    * 可以组合使用以上指令。如noindex、follow表示不允许索引页面但允许跟踪链接；
6. content-type：类似于charset，但使用http-equiv属性模拟HTTP响应头中的Content-Type字段，指定文档类型和字符编码。现代网页中，推荐单独使用charset属性；
7. refresh：在指定时间后自动刷新当前页面，或者跳转到指定URL。通常用于页面定时更新或自动临时重定向。<meta http-equiv="refresh" content="5;url=http://www.example.com/" />"
8. X-UA-Compatible：针对旧版IE浏览器，指示其使用最新的渲染模式来解析页面，避免因兼容性视图导致的样式或功能问题；
9. icon：网页图标，虽然不是严格意义上的meta元素，但通过link标签设置网页图标，使其在浏览器标签页、书签、历史记录等处显示；
10. author、generator、etc（开发者声明）：提供有关网页作者，创建工具等附加信息。对用户影响小，主要供其他软件或开发者参考。

# npm install命令的安装过程；
1. 初始化环境：npm首先确保当前环境中已安装nodejs和npm自身。如果未安装，需要先完成这些基础环境的安装；
2. 解析命令行渲染：npm解析用户输入的命令行参数，如果--save、--production、--global等，以确定安装模式、是否保存依赖到package.json文件以及是否安装生产依赖等。
3. 读取package.json文件：在项目目录下查找package.json文件，这是项目依赖列表的来源。如果指定了特定模块，npm将直接安装指定模块，否则，他将基于package.json中的dependencies和devDependencies字段来安装所需模块；
4. 创建node_modules目录：如果项目目录下尚无node_modules目录，npm创建它，用于存放即将安装的模块；
5. 获取依赖列表：对于每一个待安装的模块，npm会根据其版本范围从注册表获取最新符合范围的版本信息。这通常涉及网络请求，可能会受到网络延迟、超时或代理设置等因素影响；
6. 下载模块：npm开始下载选定版本的模块及其依赖，下载的模块通常为tar.gz归档文件，包含模块源码、package.json、LICENSE等文件；
7. 提前并安装模块：下载完成后，npm解压每个模块包，并将其内容放置在node_modules目录下的相应子目录中。同时，npm运行模块的package.json中定义的scripts.postinstall脚本，进行额外的安装后处理；
8. 解决依赖冲突：如果多个模块依赖于同一模块的不同版本，npm会尝试通过扁平化策略来解决冲突，将最合适的单个版本放入顶层node_modules目录中；确保所有依赖都能共享这个版本。对于无法扁平化的复杂情况，npm可能会在模块内部创建嵌套的node_modules目录，以解决依赖冲突；
9. 生成或更新package-lock.json：安装过程中，npm会记录每个模块的确切版本，下载源和校验哈希等信息，生成或更新package-lock.json文件。这个文件确保了项目在未来安装时能获得完全一致的依赖版本，提高了部署的可重复性和可靠性；
10. 清理与完成：安装完成后，npm清理临时文件，报告任何安装失败的模块，并退出进程。
* 总结：整个过程中，npm可能会遇到网络问题、权限问题、磁盘空间不足、模块间的依赖冲突问题。对于这些问题，npm会尝试给出相应的错误信息，并可能建议解决方案。用户可以根据提示信息进行故障排查和修复。


# GET请求存在参数长度限制，是http协议限制的吗？
1. GET请求确实存在传参长度显示，并这不是http协议本身直接规定的。实际上，HTTP协议本身规范并没有明确规定GET请求参数的最大长度。然而，在实践中，GET请求参数长度的限制主要来自以下几个方面：
    * 浏览器限制：不同的web浏览器可能对URL的总长度实施了各自的限制，这些限制通常都在2000-8192字节之间，具体数值因浏览器而异；超出限制的URL可能会导致浏览器截断请求或拒绝加载；
    * 服务器限制：web服务器（Apache、Nginx等）和后端应用框架也可能设置了对请求URL或查询字符串长度的限制，以防止潜在的安全风险或资源消耗过大。这些限制可能通过服务器配置或应用程序配置进行调整，具体数值取决于服务器管理员或开发者的设定。
    * 中间件限制：在请求到达服务器之前，可能经过负载均衡器、方向代理、防火墙等网络中间件。这些组件也可能有自己的请求长度限制，进一步约束了GET请求参数的长度。
    * 操作系统限制：操作系统在处理TCP/IP连接时，可能对单个网络包的大小有限制，从而间接影响了URL的最大长度。不过，对于大多数现代网络环境而言，这一因素通常不是主要限制；
    * RFC文档建议：虽然不是强制要求，但RFC 3986建议URI的整体长度应“尽可能短”，并且指出“尽管没有严格限制，但URI实现应当能处理至少255个八字节的路径组件和大约2000个八位字节的整个URI”
2. 综上所述，GET请求参数长度的限制主要源自浏览器、服务器、中间件等具体实现和配置，而非HTTP协议本身的硬性规定。为了避免因参数过长导致的问题，对于传输大量数据或复杂参数的场景，通常建议使用POST、PUT或其他能够承载更大请求主体HTTP方法，或考虑将数据进行合理分块、压缩或编码，以适应GET请求的实际限制。同时，保持良好的编程实践，避免URL中包含敏感信息，因为GET请求的参数会显示在浏览器地址和服务器日志中，不利于数据隐私保护。

# Typescript里面有哪些Javascript没有数据类型？
* ts作为js的超集，引入了一系列特有的类型系统特性，增强了对遍历、函数参数、返回值以及其他编程实体的类型检查，以下是ts中存在而js不存在的一些关键类型：
    * 枚举：枚举成员可以是数字或字符串，并且可以相互比较和转换为枚举值。在js中，虽然可以通过对象或常量模拟类似功能，但原生js不支持枚举语法；
    * 元组类型：元组允许定义固定数量且每个元素类型明确的数组。js数组是任何类型的元素集合，而在ts中可以精确指定数组中每个位置的数据类型；
    * 接口：接口用于定义对象的结构形状，包括属性、方法、索引签名、可选属性、只读属性等。接口提供了灵活的类型抽象，可用于类型检查、面向对象编程以及描述API契约。js中没有直接对应的类型定义方式，通常通过duck typing或使用es6类来近似实现；
    * 类型别名：类型别名允许为现有类型创建一个新的名称，便于代码清晰和复用。js中没有直接的类型别名概念；
    * 泛型：泛型允许定义适用于多种类型的数据结构和函数，推迟类型参数到实例化时确定。js编程而已通过函数重载、隐式类型检查等方式模拟泛型的效果，但缺乏ts中的类型参数、约束、泛型接口和泛型类等高级特性的直接支持；
    * 字面量类型：字面量类型用于精确指定变量或参数必须为某个特定的字符串、数字或布尔值。js中虽然可以直接使用这些值，但没有类型层面的字面量类型约束；
    * 联合类型：联合类型表示一个值可以是几种类型之一，js中虽然可以混合使用不同类型，但在ts中通过类型注解可以明确指定变量或参数可以接受的多种类型。
    * 交叉类型：交叉类型表示一个值同时具有两种或更多类型的特性，js中无法直接表达这种类型组合，ts提供了方便的语法；
    * 类型守卫与类型断言：ts提供了类型守卫和类型断言来在运行时有条件地检查或显式指定变量的类型，增强类型系统的灵活性。js中没有类似的类型系统支持。
    * void、never、unknown、any：
        * void：表示没有任何返回值的函数或空值；
        * never：表示永远不会有返回值的函数（抛出异常或无限循环）或不可能存在的值；
        * unknown：表示未知类型，它是所有类型的顶级类型，用于强调某个值可能存在任何类型，需要显式检查或转换后才能安全使用；
        * any：表示可以是任何类型，关闭了对该变量的类型检查，主要用于向遗留的js代码过渡或应对过于复杂的动态类型场景。

# HTTP报413错误，该如何解决？
1. 413错误状态码表示“Payload too large”，即请求体过大（通常是POST、PUT等方法提交的数据），超过了服务器愿意或能够处理的上限。
2. 解决方法：
    * 调整服务器配置：如果使用nginx作为反向代理或web服务器，可以在配置文件中增加或修改client_max_body_size指令，将值调大。对于Apache服务器，可以在配置文件中使用LimitRequestBody指令设置限制；
    * 调整应用程序设置：如果使用nodejs、php、python等后端框架，查看相应文档，找到配置请求体大小限制的地方并进行调整。
    * 优化客户端请求：如果正在上传大文件或发送大量数据，考虑分开上传或多步请求，避免一次性发送过大的请求体。
    * 压缩数据：如果数据格式允许，可以考虑在客户端对请求体进行压缩（gzip），减小其传输大小，从而可能避免触发服务器的大小限制；
    * 检查第三方服务限制：如果应用依赖第三方API服务器，确保查阅其文档确认是否存在请求体大小限制，并按其指引调整请求或申请扩大限制。
3. 解决413错误的关键在于识别导致错误的原因，然后采取相应的措施调整限制或优化请求。确保所设限制既能满足业务需求，又不会对服务器资源造成过度压力。同时，良好的客户端逻辑（合理的文件上传策略，数据压缩
也是避免此类错误的有效手段。


# token放在cookie，和放在localStorage、sessionStorage有什么区别？
1. 生命周期
    * cookie：默认情况下，除非设置过期时间，否则cookie会在浏览器会话结束被删除，称为“会话cookie”；若设置了过期时间，则cookie可以在指定时间内持久存在，即使关闭浏览器再打开，cookie仍然有效
    * localStorage：数据保存在本地，除非手动清除或使用js api删除，否则数据永不过期，即使关闭浏览器或电脑，重新打开仍能保留；
    * sessionStorage：数据仅在当前浏览器窗口（或标签页）的会话期间有效。一旦窗口或标签页关闭，sessionStorage将被清除。
2. 安全性
    * cookie：可以设置Secure属性，确保cookie只在HTTPS连接上传输，提高数据传输安全性；可以设置httponly属性，防止通过js访问cookie，减少xss攻击窃取cookie的风险；
    * localStorage、sessionStorage：由于不涉及网络传输，因此不需要Secure，两者不能设置httponly属性，始终可以通过js访问，这意味着如果存在xss漏洞，攻击者可以通过注入脚本盗取存储其中的token；
3. 跨域行为
    * cookie：受samesite属性和domain、path属性控制，可以跨域（如果服务器允许）；
    * localStorage、sessionStorage：不具备跨域能力，数据始终局限设置它的原始源（协议+域名+端口），不同源的iframe或页面无法访问彼此的localStorage或sessionStorage；
4. 数据大小限制
    * cookie：4kb，且浏览器对单个域名下的cookie总数也有一定限制（各浏览器不同）
    * localStorage、sessionStorage：存储5M左右数据；且不区分域名、仅受浏览器整体存储限制；
5. 使用场景
    * cookie：适用于需要在多个子域名间共享的认证token；需要服务器端维持状态且需要一定程度的安全保护时，可将token作为httponly、secure的cookie发送给客户端；
    * localStorage：适用于长期存储用户偏好、离线数据等无需随着会话结束而清除的信息，且不需要跨越不同窗口或标签共享；适合跨页面的无状态API认证，如将jwt存放在其中，用于前后端框架分离的无刷新授权验证；
    * sessionStorage：适用于一个窗口或标签页内，需要在页面间传递状态，但不想永久保存在客户端的情况，如购物车信息、临时编辑数据等。
## 总结
* 综上所述，选择将token存放在cookie、sessionStorage、localStorage中，应根据业务需求、安全性考量以及跨页面/跨域需求来确定；通常情况下，出于安全性考量，建议将敏感信息存储为httponly、secure的cookie，而对于一些不需要严格安全保护且需要长期保存的客户端状态，考虑使用localStorage；若只在当前会话期间保留数据，则使用sessionStorage。
