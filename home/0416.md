
# es6代码转为es5代码的实现思路是什么？
1. 源代码解析
    * 使用js解析器，将es6源代码解析为抽象语法树（AST）。AST是一种将结构化数据表示形式，它将代码分解成一系列的节点，每个节点代表源代码中的一个语法元素，并保留了这些元素之间的关系和上下文信息。
2. 转换操作
    * 对解析得到的AST进行遍历和转换，根据目标ES版本，针对ES6特性，应用相应的转换规则。Babel通过插件（plugins）或预设（presets）来指定这些规则，例如：
        * 将箭头函数转为常规函数
        * 将let和const声明转换为var声明，并处理块级作用域；
        * 将模板字符串转为字符串拼接；
        * 将类转为构造函数、原型方法及静态方法；
        * 将解构赋值转为传统赋值语句；
        * 将模块语法转为Commonjs或AMD规范的模块加载方法；
3. 代码生成：
    * 将经过转换的AST重新转回文本形式的ES5代码。这个过程称为”代码生成“或”代码答应“，由Babel的@babel/generator模块负责；他会遍历AST，根据ES5的语法规则生成对应的字符串形式代码；
4. 编译输出与集成
    * 输出转换后的ES5代码，可以保存为单独的文件或替换原本的ES6源文件。在实际项目中，这一过程通常集成到构建工具的工作流中，以便自动化处理整个项目的源代码，并与其他优化任务协调工作。

#  babel的原理描述？
1. 解析：使用内置的js解析器读取输入的es6源代码。解析器遵循ecmascript规范，将源代码解析成一个详细的抽象语法树（AST）。AST是源代码的中间表示形式，以结构化、层次化的数据结构存储代码的所有语法元素及其关系，便于后续的分析和转换。
2. 转换：babel通过插件系统对AST进行深度遍历和节点替换、添加和删除操作。插件时一组预定义的规则，它们针对特定的ES6特性识别对应的AST节点，并应用相应的转换逻辑。用户可以根据选择和配置不同的插件，或者使用预设（针对特定环境或目标的插件集合）；转换过程中，Babel会将ES6特有的语法转换为等效的ES5语法或polyfill，确保在不支持这些特性的旧版浏览器或环境中能够正常运行；
3. 生成：经过转换的AST需要被还原为可执行的文本代码。babel使用@babel/generator模块将修改后的AST重新序列化为ES5兼容的JS源代码。生成器会遵循ES5的语法规则，确保生成的代码不仅功能上等同于ES6代码，且具有良好的可读性和格式。
4. 配置与集成：用户通过.babelrc、package.json中的babel字段和命令行参数配置Babel。指定要使用的插件、预设及其它的编译选项。

# 如何理解Reflect，以及它出现的原因？
## 理解
* Reflect是一个在ES6引入的内置对象，它提供了对js对象属性的底层操作的封装，以及对元编程能力的支持。Reflect主要用于反射操作，即在运行时检查和修改对象类型和对象内部结构的能力；
    1. 反射API的统一入口：Reflect提供了一套完整的、与Object对象上的同名方法相对应的静态方法，如Reflect.get\Reflect.set\Reflect.has等。这些方法旨在补充或替代[[Prototype]]链上的同名方法，提供更清晰、更一致的接口来操作对象属性。
    2. 显式抛出错误：Reflect方法在遇到错误或不成功的情况下，通常会显式抛出错误，而不是静默失败或返回非确定性结果。这增强了代码的可预测性和调试便利性，特别是在处理元编程场景时。
    3. 与Proxy对象的紧密配合：Reflect与ES6引入的另一个重要特性——Proxy对象紧密相关。Proxy用于创建对象的代理，其陷阱方法在捕获对应操作时，通常会调用对应的Reflect方法和执行默认行为。这种设计使得Proxy能够透明拦截和自定义对象操作，同时保持原生行为的可用性。
    4. 提供元编程能力：Reflect提供了一系列用于元编程的高级方法，如Reflect.construct（模拟new操作符）、Reflect.apply（模拟函数的apply方法）等；
    5. 返回值的语义化：Reflect方法的返回值往往更加语义化，比如Reflect.set返回一个布尔值，表示设置操作是否成功；Reflect.get则直接返回属性的值，无需通过undefined来判断属性是否存在。这种设计有助于编写更简洁、意图更明确的代码。
## 原因
1. 标准化底层操作：js中许多与对象属性操作相关的功能分散在Object对象的方法、内建操作符中。Reflect的引入旨在提供一个标准化、集中且完整的接口来访问和操控这些底层操作，提升语言的易用性和一致性。
2. 支持Proxy的正确实现：proxy对象的陷阱方法需要有能力调用对应的默认行为。Reflect提供了这些方法，使得Proxy可以在自定义行为的同时，轻松地委托给原始操作。这种设计确保了Proxy能够无缝与现有代码和库协同工作，不会因为代理而改变基础行为的预期结果。
3. 增强异常处理和代码可维护性：Reflect方法倾向于显示抛出错误，而非错误静默失败或返回模糊的结果。这种设计提高了代码的健壮性，使得开发者能够容易捕捉和处理潜在问题，尤其是在进行复杂的元编程操作时。
4. 促进函数式编程和库开发：Reflect提供的功能对于函数式编程、元编程以及那些需要精细控制对象属性访问和修改的应用场景非常有用。它为库作者提供了一套统一且易于使用的工具，有助于构建更为强大、灵活且易于的代码库。

# git flow是什么？如何使用
* git flow 是一种基于GIT的分支模型工作流；提供了一种结构化的分支管理策略，旨在通过清晰的角色分工和流程指导，确保高效、有序的软件开发和版本发布。git flow包括以下核心分支：
    1. 主分支（master）
        * 代表产品正式发布的稳定版本。仅接收从其他分支合并进来的验证无误的版本更新；
        * 常保持与生产环境同步，其HEAD应该始终指向可部署的状态；
    2. 开发分支（develop）
        * 代表正在进行开发的下一个主要版本；所有新的功能开发都基于此分支进行；
        * 所有开发人员日常提供代码到次分支进行集成测试和持续集成；
    3. 功能分支（feature）
        * 为开发新功能而创建的短期分支，从develop分支派生；
        * 功能开发完成，通过合并请求或直接合并回develop分支；
    4. 发布分支（release）
        * 当develop分支积累一定的新功能，准备进入发布周期，从develop分支创建。
        * 用于修复bug、撰写文档、准备发现等发布相关的活动，不允许添加新功能；
        * 发布准备工作完成后，合并回master和develop分支，打上相应的版本tag
    5. 热修复分支（hotfix）
        * 当生产环境中发现紧急问题需要快速修复时，从master分支派生；
        * 修复完成后，直接合并回master和develop分支，并在master打上新的版本标签；

# webpack如果使用了hash命名，是否每次都会重新生成hash，简单描述webpack的集中hash策略；
1. 使得，使用hash测了，每次打包都会生成新的hash。这是因为hash是基于构建过程中的某些因素计算的出的，这些因素通常包括但不限于：
    * 当前构建时间戳或随机数，确保每次构建的唯一性；
    * 构建过程中涉及的源文件内容，特别是哪些影响输出文件的源代码；
    * 构建配置本身，如webpack配置文件的变化；
* 由于每次构建上述因素都可能有微小差异，即使源代码没有实质性变化，hash也会变更。这样做的目的是确保生成的文件名与构建产物的内容严格对应，从而支持浏览器缓存策略；
    * 当项目中的文件未发生变化，构建后的hash也不会变，浏览器可以利用相同的命名命中缓存，提高加载速度；
    * 当项目中有任何文件发生变化，构建后的hash会发生变化，浏览器将视为新资源下载并更新，确保用户获得最新版本的代码。
2. webpack提供了三种不同的hash策略来影响输出文件的命名：
    * hash
        * 全项目级哈希：hash是基于整个项目的构建上下文生成，包括所有模块及其依赖。这意味只要项目中任何一个文件有所变化，重新构建后生成的hash就会改变；
        * 影响范围：使用[name].[hash].js格式的文件名时，所有输出的chunk都将共享一个hash值，因此，只要项目中任何一个文件改动，所有输出文件的hash都会同步更新，导致项目的缓存失效；
    * chunkhash：
        * chunk级哈希：chunkhash是基于每个独立的chunk的内容生成的，每个chunk都有自己的chunkhash。只有某个chunk内的源码发生变化时，仅该chunk的chunkhash会改变，其他未变动的chunk仍保持原有hash；
        * 影响范围：使用[name].[chunkhash].js格式的文件名时，不同chunk之间chunkhash互不影响。这样可以实现细粒度更细的缓存控制，仅当特定chunk的内容变化时，对应的输出文件才会更新其hash，其余未变动chunk的文件可以继续利用浏览器缓存；
    * contenthash
        * 资源内容哈希：contenthash是基于每个输出文件的实际内容生成的。即使两个chunk依赖相同的源文件，只要编译结果稍有不同，他们的contenthash也会不同。
        * 影响范围：使用[name].[contenthash].js格式时，每个输出文件拥有独立的contenthash。这样可以确保只有文件内容真正变化时，其hash才会改变，进一步优化缓存效果，避免不必要的缓存失效。

# vue的模板语法用的是哪个web模板引擎，如何理解模板引擎？
* vuejs使用的是自定义的模板语法，虽然其语法形式与Mustache类似，但vue并没有直接采用现有的web模板引擎（如Mustache、Handlebars、Pug等），而是构建了自己的模板编译器。vue的模板引擎是专门为vue的组件系统和响应式数据绑定设计的，它包含了vue特有的指令、插槽、计算属性、条件渲染、列表渲染等高级功能，并且与vue的虚拟DOM系统紧密结合，以实现高效的DOM更新。
* 模板引擎是一种程序或库，它允许开发者使用特定的模板语言编写动态网页或应用程序界面的布局和内容，然后再运行时将这些模板与数据结合起来，生成最终的HTML或其他格式的输出。理解模板引擎的关键概念和特点如下：
    1. 分离关注点：模板引擎促进了MVC或MVVM架构模式的实现，它将视图层的逻辑从业务逻辑和数据模型中分离出来。模板文件专注于描述界面和结构的呈现方式，而数据处理和业务逻辑则在控制器或ViewModel中处理。
    2. 模板语言：模板引擎定义了一种专门的模板语言或语法，通常包含变量插值、控制结构、指令、过滤器等功能。这些语法允许开发者再模板中嵌入动态数据、执行逻辑操作，并在后端数据源或前端数据模型交互；
    3. 数据绑定：模板引擎的核心功能之一是实现数据绑定。它允许模板中的特定占位符或标记与数据模型中的属性关联起来。当数据模型发生变化时，模板引擎会自动更新相应部分的视图，确保视图与数据始终保持同步。
    4. 编译与渲染：模板引擎通常包括编译器和渲染器两部分。编译器负责将模板文件解析成中间表示，并可能进行预优化。渲染器则在运行时接收数据模型作为输入，结合编译后的模板信息，生成最终的HTML输出。
    5. 服务器与客户端渲染：模板引擎即可用于服务器端渲染，在服务器端生成完整的HTML页面发送给客户端；也可以用于客户端渲染（CSR），在浏览器端根据接收到的数据动态生成界面。现代框架（Vue、React、Angular）通常支持两种渲染模式。
    6. 扩展性与定制化：许多模板引擎允许开发者自定义指令、过滤器、标签等，以适应特定项目或团队的需求。此外，模板引擎还可能提供插件机制，方便集成第三方库或服务。


# 301、302的https被劫持如何处理？
1. 确认劫持类型
    * 中间人攻击：攻击者通过非法手段获取中间位置，如路由器、代理服务器、JSP等，篡改或注入流量。这可能导致原本的HTTPS连接被降级为HTTP，或者伪造证书进行中间人解密再重加密；
    * DNS劫持：攻击者篡改DNS查询结果，将用户导致恶意服务器，即使用户访问的是正确的HTTPS URL，也可能被重定向到仿冒站点。
    * 浏览器插件或恶意软件：某些恶意插件或软件可能篡改浏览器行为，包括重定向请求；
2. 加强网站安全配置
    * 使用强加密和安全密钥：确保服务器、DNS账户、SSL/TLS证书私钥等访问权限受到严格保护，使用强加密码和多因素认证防止未经授权的访问。
    * 启用HSTS（HTTP Strict Transport Security）：
        * 再服务器响应头添加Strict-Transport-Security指令，告知浏览器该域只能通过HTTPS访问，且在指定时间内强制将所有对该域的HTTP请求升级为HTTPS。这有助于防止中间人将HTTPS重定向为HTTP；
        * 向HSTS preload list提交域名，让主流浏览器在出产时旧内置对您网站的HSTS策略，进一步降低风险；
3. 使用安全的重定向策略
    * 避免不必要的301/302重定向，确保网站架构清晰，避免因配置错误或冗余的重定向规则导致的安全隐患；
    * 使用绝对URL：在进行301/302重定向时，使用完整的、包含协议和主机名的绝对URL，防止被重写为不安全的HTTP连接；
    * 检查服务器配置：确保web服务器的重定向规则不受外部影响，且仅在必要时执行重定向。
4. 验证SSL/TLS证书
    * 使用权威CA签发的证书：确保网站使用受信任的证书颁发机构签发的SSL/TLS证书，避免自签名证书或不受信任的证书引发浏览器警告；
    * 启用OCSP stapling：服务器主动提供证书撤销状态信息，减少客户端验证证书状态时的延迟和被劫持风险；
    * 启用TSL会话复用和False Start：提高HTTP连接速度，减少中间人干扰的机会；
5. 监测与报警
    * 实时监控证书状态：使用监控服务检查证书的有效性、到期情况及中间证书链的完整性，及时受到异常警告；
    * 监控HTTP响应状态码：设置监控工具检查网站返回的HTTP状态码，一旦发现非预期的301/302响应，立即触发告警；
6. 教育用户及反馈
    * 引导用户识别安全连接：教导用户识别浏览器地址的锁图标、绿色地址栏及HTTPS前缀，提醒他们注意任何关于证书或连接不安全的警告；
    * 建立反馈渠道：鼓励用户在遭遇疑似劫持及时报告，以便快速响应和调查；
7. 法律途径

# Generator yield的作用？
1. 定义生成器函数：在js中，使用function*定义一个Generator函数。这样函数内部可以包含任意数量的yield表达式。 当调用Generator函数时，他不会立即执行函数体，而是返回一个Generator对象。
2. 暂停和恢复执行：当Generator函数只想到yield表达式时，函数会暂停执行并返回一个值。暂停时，Generator会保存当前的执行上下文，以便后续恢复执行时能够从同一位置继续。
3. 迭代产出值：Generator对象实现了迭代器接口，可以被for...of循环、next()方法或被其他迭代机制驱动。每当通过迭代器接口请求下一个值时，Generator会从上次暂停处继续执行，直至遇到下一个yield语句。此时，它会阐述yield后面表达式的值，然后再次暂停执行。
4. 异步编程支持：Generator函数特别适用于实现异步编程逻辑。通过配合yield语句与Promise或async/await，可以写出更简洁、更易于理解和维护的异步代码；例如，可以使用yield语句等待异步操作完成，并在异步操作完成后恢复generator的执行，从而实现非阻塞的异步流程控制。
5. 资源管理与控制流：由于Generator能够精确控制执行的暂停和恢复，它可以用来管理复杂的控制流，如协调程序或状态机。这有助于处理需要分布执行、中间有等待或条件判断的任务，比如游戏逻辑、数据流处理等。

# 前端框架设计模式：MVVM、MVP、MVC的含义及其原理？

## MVVM（Model-View-ViewModel）模式
1. 含义：MVVM是一种将业务逻辑、用户界面和数据绑定紧密联系的设计模式。它通过引入“ViewModel”层，作为Model和View之间的桥梁，负责转换Model数据以适应View的展示需求，并且提供双向数据绑定机制，使view和model状态保持同步；
2. 原理
    * model：负责存储和管理应用程序的数据，通常包含业务逻辑和数据验证。Model的变化会触发通知机制（观察者模式），通知其他层数数据已更新。
    * view：负责呈现用户界面，显示model数据。在MVVM中，view通常是一个声明式模板，通过数据绑定表达式直接引用viewmodel属性；
    * viewmodel：作为view的抽象，封装了视图相关的业务逻辑和状态。viewmodel从model获取数据，对其进行转换、格式化等操作，形成便于view使用的数据结构。同时viewmodel监听model的变化，并通过数据绑定技术自动更新view。反过来，view中的用户交互会触发实际，这些事件通过数据绑定机制自动更新viewmodel的属性，进而影响model；
## MVP（Model-View-Presenter）模式
1. 含义：MVP模式是一种改进的MVC模式，旨在进一步分离视图与业务逻辑。它引入了Presenter层，作为view和model之间的中间，负责协调两者之间的交互；
2. 原理
    * model：同MVVM中的model，负责管理和存储应用程序数据，提供数据操作接口；
    * view：仅负责显示用户界面，不直接与Model交互，view通过接口向presenter传递用户输入事件，并根据presenter的指示更新自身。
    * presenter：持有对view和model的引用，充当两者之间的协调者。presenter处理view的用户交互，调用model进行数据操作，并将处理结果转为view可以理解的格式。同时，presenter监听model的辩护，主动更新view以反映最新的数据状态；
## MVC（Model-View-Controller）模式
1. 含义：MVC是最经典的前端框架设计模式之一，旨在分离用户界面、业务逻辑和数据管理；
2. 原理
    * model：如同上述模式，负责数据管理，存储业务和数据验证；
    * view：负责渲染用户界面、展示model数据，view可以直接或简洁监听model的变化，以更新自身的显示。
    * controller：接收用户的输入事件，调用model进行相应的数据操作，并根据操作结果更新view。controller通常不直接修改view，而是通过view通过的接口告知其应该如何更新。
## 总结：
1. MVVM强调数据双向数据绑定，通过ViewModel自动同步Model和View的状态，减轻了手动更新数据的负担，尤其是声明式编程的前端框架；
2. MVP通过Presenter层进一步解耦view和model，使得view更轻薄，更易于测试。presenter完全控制了view的更新逻辑，使得业务逻辑更加集中和易于维护。
3. MVC是最基础的模式，controller直接处理用户交互并更新view，虽然view和model直接有一定的耦合，但在简单场景下结构清晰、易于理解。

# 完整的路由导航解析流程？
1. 导航被触发：用户点击带有to属性的router-link组件，或者通过编程方式调用router.push等方法时，新的路由导航请求被触发；
2. 当前路由组件的beforeRouteLeave守卫：定义了该守卫，则在离开当前路由前被调用。这个守卫可以执行一些清理工作，也可以判断是否允许离开理由（返回false或抛出错误）
3. 全局前置守卫router.beforeEach：每次导航路由开始时被调用，它可以访问到即将进入的目标路由信息、当前导航正要离开的路由信息以及next函数。（在此处可以进行权限验证，设置路由信息等）
4. 路由独享守卫beforeEnter：如果目标路由配置定义了该守卫，他将在全局守卫之后，路由解析之前执行。该守卫接受与全局前置守卫相同的参数，并通过调用next决定是否继续导航。
5. 组件内的beforeRouteUpdate守卫：对于复用的路由组件，如果组件内定义了该守卫，它将在数据响应式更新之前被调用。此守卫主要用于处理参数变化时数据获取或逻辑更新，无需重新创建组件实例；
6. 全局解析守卫router.beforeResolve：在所有异步路由组件及守卫resolve完成之后、里有即将改变但未改变之前，全局解析守卫会被调用。它与router.beforeEach类似，但只在异步操作完成后触发，适用于需要依赖异步数据加载完成后再进行某些操作的场景。
7. 路由组件的beforeRouteEnter守卫：对于即将进入的路由组件，如果定义了beforeRouteEnter守卫，它将在组件实例被创建之前调用。由于此时组件实例未创建，无法访问组件内的方法或状态。但可以通过next函数的回调参数访问到已创建的组件实例，这个守卫通常在组件实例化进行数据预取或设置初始状态。
8. 组件渲染：上述所有守卫都没有阻止，此时开始渲染目标路由对应的组件。如果是首次进入，则创建实例；如果是复用，仅更新数据。
9. 路由组件的created、mounted等钩子；
10. 全局后置守卫router.afterEach：无论导航成功还是失败，全局后置守卫都会被调用。接收与前置守卫类似的参数，但没有next函数，因为它无法影响导航。这个守卫通常用于更新浏览器的URL历史记录、页面标题，或者进行其他与路由切换相关的全局后处理工作。
