
# Form表单时如何提交文件的？原理是什么？
1. 创建表单：使用form标签创建一个HTML表单，设置必要的属性，如action和method；注意：为了能正确提交文件，必须设置enctype为multipart/form-data。因为默认是application/x-www-form-urlendcoded，无法提交文件。
2. 添加文件输入域：使用<input type="file" />创建一个文件选择器，用户可以通过它选择本地文件。可以使用accept属性限制可选文件类型；
3. 用户操作：用户在浏览器点击文件输入域后，选择一个或多个文件，这些文件的信息被浏览器存储在内存中，准备随表单一起提交；
4. 表单提交：用户点击提交按钮或通过其他方式触发表单提交，浏览器开始处理文件上传过程：
    * 数据封装：浏览器根据enctype="multipart/form-data"将表单数据和文件内容封装成一个多部分消息体。每部分由一个或多个头部和主体组成。对于文件字段，头部包含了诸如字段名、文件名、MIME类型等信息，主体则是文件的二进制类型等信息。非文件字段则以适当的方式编码后放入各自的头部和主体；
    * 发送请求：浏览器选定的HTTP方法向表单的action属性指定的url发起请求，并在请求体中附带之前封装好的多部份消息体。
    * 服务端接收：服务器接收到请求后，解析请求体的消息体。根据Content-type和边界字符串，服务器分离出各自部分，识别文件字段，并根据头部信息保存文件到服务器指定的位置。同时，非文件字段的值也可以被提取出来供服务器端逻辑处理；
5. 服务器响应：服务器完成文件接收和处理后，通常返回一个相应告知客户端上传结果，如成功与否、错误信息或新文件的URL等。客户端可以根据响应进行相应的用户界面更新或后续操作。

# documentFragment是什么？它有什么好处？
1. DocumentFragment是一个特殊的DOM对象，他代表一段独立的、轻量级的文档片段，尽管它属于Node类型，但并不是真正的DOM树的一部分。DocuemntFragment主要用于存储和操作DOM元素，但这些操作不会反映到实际DOM树中，直到DocuemntFragment被插入到DOM中为止；
2. 特点
    1. 离线文档片段：DocumentFragment可以看作是一个存在于内存的临时DOM存储区，可以在其中创建、添加、删除或修改节点，而这些操作不会引起浏览器重绘或回流，因为未涉及真正的DOM；
    2. 节点容器：DF可以包含任何类型的节点，并且本身也是一个节点，具有nodeType和nodeValue等属性；
    3. 节点集合：DF可以被视为一个节点集合，可以使用常规的DOM方法来操作其内部节点；
    4. 一次性插入：当需要DF中的所有节点一次性插入到DOM树，只需要将DF作为一个整体插入到目标位置。此时所有内部节点会从DF从移出并插入到实际DOM，整个过程视为一次DOM操作；
3. 好处
    1. 性能优化：由于DF不的操作不会触发dom更新，所以它可以有效减少对DOM的直接操作次数。在实际应用中，频繁的dom操作往往都是消耗性能的，因为每次都可能导致重绘或回流。使用DF将多次操作集中在一次操作，有助于提升性能；
    2. 批量操作：当需要批量创建或修改多个节点时，可以先在DF中完成这些操作，然后再一次性将整个片段插入到DOM中。这种方法特别适用于动态生成列表，模板渲染等场景，避免多次插入节点可能引起多次回流和重绘；
    3. 简化代码：通过DF可以将复杂操作封装在一起，代码更加简洁易懂，同时也便于维护和复用；
    4. 跨文档移动节点：如果需要在文档之间移动节点，使用DF可以避免直接操作不同文档的节点可能导致的异常。可以先将节点移动到DF中，在将其从一个文档移动到另一个文档；

# ajax的请求状态有几种？
* ajax请求状态通过XHR的readyState属性表示，readyState属性表示请求/响应过程的不同阶段，共有以下五种状态：
    1. 0：未初始化，表示XHR对象被场景，但尚未调用open
    2. 1：载入，已调用open方法，建立了服务器的连接，但尚未调用send
    3. 2：载入完成（HEADERS_RECEIVED）请求已到达服务器，响应的头部信息已接收，但响应主体部分的数据尚未完全下载；
    4. 3：交互中（LOADING）响应主体数据正在下载中，此时，可以开始访问响应部分数据，如使用responseText或responseXML属性；
    4. 4：完成（DONE）整个请求过程已经完成。无论成功或失败，响应主体数据已经全部下载。此时可以通过检查status和statusText属性来判断请求的结果状态码和状态说明；
* 除了readyState描述的请求过程外，还有配套的onreadystatechange事件处理器，每当readyState改变时，都会触发该事件。在事件处理器中，通常会检查readyState是否为4，如果是，则进一步检查status属性以确定HTTP响应状态码，判断请求是否成功。

# 什么是js中的伪数组，如何转为真数组？
* 伪数组：指看起来像数组（即拥有整数索引的有序元素集合，并且具有length属性）但实际上并不具备完整的数组特性和方法的对象。伪数组通常不直接继承自Array.prototype，因此不能直接使用数组的方法如push、pop等；典型的伪数组包括：
    1. arguments对象：函数调用时传入的参数列表；
    2. DOM方法返回的结果集，如NodeList或HTMLCollection
    3. jQuery对象（实际上是对DOM元素包装后的对象集合），虽然jq提供了一些类数组方法，但本质上仍然是伪数组；
* 转换真数组的方法：
    1. Array.from
    2. Array.prototype.slice.call：对于不支持最新特性的浏览器，最长使用的方法；
    3. [...likeArray]
    4. 手动遍历与push

# 怎么给vue定义全局方法？

1. 挂载到Vue.prototype上：在一个单独的js文件中定义所需的全局方法，然后将其添加到vue.prototype上。这一所有的vue实例及其子组件都可以通过this关键字访问到这些方法；
2. 使用全局混入：创建一个全局的混入对象，然后在应用初始化时通过vue.mixin添加到全局。这样，混入中的methods属性中的方法都会被合并到每一个vue组件中；
3. 使用插件：通过编写一个vue插件，不仅可以在其执行install方法中挂载全局方法，还可以执行其他全局配置。这种方法适用于封装更复杂的功能，包括但不限于全局方法，指令，组件注册等；


# 在使用计算属性时，函数名可以和data中的属性同名吗？
* 计算属性不可以与属性同名。虽然从技术角度上讲，vue可能会允许这种命名，但由于vue的内部机制以及避免混乱，最佳实践中强烈不建议使用计算属性和data属性同名；
* 原因如下：
    1. 命名冲突：在vue实例初始化过程中国，各部分的属性都会被挂载到this上下文中，如果计算属性函数名与data属性同名，前者会覆盖前者，导致不符合预期；
    2. 混淆与维护困难：同名计算属性函数和data属性会使代码意图变得模糊，增加阅读和维护的难度。
    3. eslint警告或错误：项目启用严格的代码检查工具，配置中通常会有规则禁止这种同名情况，编译时会提示错误或警告。

# 是否使用HTML5的Web Audio API？
* Web Audio API提供了一套强大的音频处理、合成和操纵功能，适用于以下情况：
    1. 复杂音频处理：如果音频进行实时音频分析，滤波，混音，增益控制，延迟，回声，均衡器调整等复杂的音频处理控制，audio api是不错的选择。
    2. 游戏音频与交互式音频：对于游戏开发，虚拟现实，增强现实或其他需要高度可互动音频体验的项目，audio api可以实现准确的音频同步、3D空间音频定位、音频事件触发等功能，提升用户沉浸感。
    3. 音乐合成与创作工具：开发在线音乐合成器、音序器、采样器等创作应用程序，audio api的音频合成功能会对MIDI的支持可以支持构建完整的音乐制作环境
    4. 自定义音频控制播放：标准的audio标签无法满足时，audio api提供了更底层、精细的控制能力；
    5. 性能敏感场景：对于性能要求较高的应用，尤其是移动端，web audio api可以直接在web worker线程中处理音频，避免阻塞主线程，保证应用流畅度。
* 不适用Web Audio API的情况：
    1. 简单的音频播放
    2. 快速开发和简单需求
    3. 浏览器兼容性考量：在非主流浏览器存在兼容性问题时，使用简单<audio />标签更为保险；

# requestAnimationFrame的运行机制？
* requestAnimationFrame是浏览器提供的一个API，用于在浏览器下一次重绘之前安排js回调函数执行。它的运行机制主要包括以下几个关键：
    1. 异步调度
    2. 与渲染同步：会在浏览器渲染周期内，恰好在重绘和复合阶段之前执行。意味着回调函数执行时，浏览器已经完成了布局和绘制阶段，即更新屏幕。这样的设计确保了动画或视觉与浏览器的渲染工作紧密结合，充分利用硬件加速，实现平滑、高效的动画效果；
    3. 帧率视频：尽量在60fps开始时触发回调，如果浏览器由于性能限制或系统繁忙无法维持60fps，回调的执行频率会自动适应实际的屏幕刷新率，防止五位的过度渲染。有助于节省计算资源，避免因过度渲染导致的卡顿或电池消耗；
    4. 取消机制：如果在新的帧开始时，当前页面不再出于活动状态，浏览器会取消已调度但尚未执行的回调，以节省资源。当页面再次可见时，动画会从上一次离开时的状态继续，而不是尝试补足期间丢失的帧。
    5. 避免不必要的渲染：不可见时取消回调执行，可见恢复执行；
    6. 链式调用：若需要连续执行动画，通常在回调内部再次调用，形成链式调用，保证动画的连续性。这样可以确保每一帧结束后，新的帧请求被立即调度，保持动画流畅性。


# 如何用栈实现队列（js）
* 可以使用两个栈来实现队列，遵循如下步骤：
1. 创建两个栈：一个用于入队，一个用于出队；
```js
class QueueUsingStack {
    constructor() {
        this.enqueueStack = []
        this.dequeueStack = []
    }
}
```
2. 入队操作：当需要将一个元素添加到队列尾部时，将其压入入队栈
```js
enqueue(element) {
    this.enqueueStack.push(element)
}
```
3. 出队操作：出队时，如果出队栈为空，将入队栈的所有元素弹出并压入出队栈，这样出队栈顶部元素就是队列的第一个元素，然后，可以从出队栈顶部弹出并返回这个元素；
```js
dequeue() {
    if (this.dequeueStack.length === 0) {
        while (this.enqueueStack.length !==0) {
            this.dequeueStack.push(this.enqueueStack.pop())
        }
        if (this.dequeueStack.length === 0) {
            throw new Error('Queue is empty')
        }
        return this.dequeueStack.pop();
    }
}
```
4. 检查队列是否为空：只需要检查两个栈是否为空
```js
isEmpty() {
    return this.enqueueStack.length === 0 && this.dequeueStack.length === 0;
}
```
5. 总结：利用两个栈实现了队列的基本功能，先进先出。如果操作始终在入队栈进行，而出队操作则在必要时将元素从入队栈转移到出队栈，确保顺序符合队列的要求。


# instanceof的原理，如何实现一个stanceof函数？
1. 作用：用于判断一个对象是否为某个构造函数的实例。其基本原理时基于js的原型链机制。当使用instanceof时，他会按照以下步骤执行：
    1. 获取右操作数的prototype属性：这是构造函数所关联的原型对象，即新创建的对象在其构造函数内部通过new关键字创建，其内部[[Prototype]](可通过__proto__或Object.getPrototypeOf()访问)会被设置为原型对象；
    2. 沿着左操作数的原型链向上查找：从对象自身的[[Prototype]]开始，逐级向上遍历其原型链，直至达到null
    3. 比较原型链上的对象的构造函数的prototype属性：在遍历过程，如果发现任何一个原型对象与构造函数的prototype属性相等，即找到了构造函数的原型出现在了对象原型上的位置，此时返回true，否则，遍历到原型链顶端没找到匹配项，返回false；
2. 模拟实现
```js
function myInstanceof(obj, Constructor) {
    if (typeof obj !== 'object' || obj === null) {
        return false
    }
    let proto = Object.getPrototypeOf(obj)
};
    while (proto !== null) {
        if (proto === Constructor.prototype) {
            return true
        }
        proto = Object.getPrototypeOf(proto)
    }
    return false;
```
