# React异步渲染的概念，什么是Time Slicing和Suspense？
* react异步渲染时react框架中用于提升用户体验、实现流畅UI更新的一项关键技术。它主要通过两个核心概念来实现：time slicing（时间切片）和 Suspense。
* time slicing
    * 概念：时间切片是react 16引入的一个特性，它允许react将复杂的ui渲染过程分解成一系列的小任务。这些小任务可以在多个浏览器帧中执行，而不是一次性阻塞主线程完成所有渲染工作。这样，即使在处理大量数据或复杂组件树时，用户界面也能保持响应式，因为浏览器有机会在渲染过程中穿插执行其他任务，如用户输入或动画。
    * 工作原理：在react中，当组件树需要更新时，渲染过程不是一口气完成的，而是被细分成多个小片段，每个片段在浏览器的一个渲染帧（大约16毫秒）内完成。当一个帧的时间用尽时，react会暂停当前渲染任务，将控制权交还给浏览器，使得其他高优先级的任务得以执行。下一帧开始时，react会从上次中断的地方继续执行下一个切片，直至整个渲染过程完成。
* Suspense
    * 概念：Suspense是React的另一个重要特性，旨在解决数据加载和代码分割带来的延迟问题，以提供更好的用户体验。Suspense允许组件在等待异步数据或代码时”暂停“渲染，直至所需资源准备就绪，然后”恢复“渲染，这一过程对用户而言是平滑且无感知的。
    * 应用场景
        1. 数据加载：当组件依赖的数据尚未从服务器获取时，可以使用suspense包裹组件，从而在数据加载期间显示加载指示器，而不是立即渲染空白或错误信息。
        2. 代码分割：suspense可与lazy结合使用，实现按需加载组件。当懒加载的组件即将被渲染时，suspense会等待其代码下载并执行完毕；
    * 工作原理：suspense组件作为边界，内部可以包含一个或多个可能需要异步操作的子组件。当这些子组件请求数据或等待代码加载时，suspense会展示一个fallback属性指定的内容。一旦数据或代码准备就绪，suspense会重新渲染这些子组件，同时隐藏fallback内容，展示最终的UI状态；

# redux的设计思想？
1. 单一数据源：redux倡导应用的状态存储在一个单一的不可变对象树中。这个对象称为store。这意味着整个应用的状态都可以从这个store中读取，且任何状态的变更都必须通过这个store来进行，确保了状态管理的一致性和可预测性。
2. 状态是只读的：在redux中，状态数一旦创建，就不能直接修改。当需要改变状态时，必须通过dispatch一个action来描述这一变化。这种设计确保了状态变更的可追踪性和调试便利性。
3. 使用纯函数进行状态变更：redux利用reducers，这些是纯函数，接收旧状态和一个action作为输入，返回一个新的状态和对象。纯函数没有副作用，每次给定相同的输入都会产生相同的输出，这使得状态管理变得简单且易于理解。
4. 中间件：redux引入和中间件的概念，允许在dispatch action和调用reducer之间插入自定义逻辑。这为异步操作、日志记录、错误处理等提供了灵活的扩展点，而无需修改核心的store逻辑。
5. 时间旅行调试：由于状态的变更历史可以通过action记录下来，redux天然支持时间旅行调试。开发者可以轻松回溯和重放状态变更，这对于调试和理解应用行为非常有帮助。
6. 可预测的状态管理：通过上述设计，redux确保了应用状态的每次变更都是可以预测的。这对于大型项目和团队合作尤为重要，因为它降低了因状态管理不当导致的bug风险。
7. 与UI库无关：虽然redux常与react一起使用，但本身并不绑定任何特定的ui库。这意味着redux可以与vue、angular或其他前端框架无缝集成。

# webpack如何利用localStorage离线缓存静态资源？
* webpack利用service worker而非localStorage来实现离线静态资源的缓存，这是因为localStorage不适合存储大量二进制文件（图片、音频、视频等）而更适合存储键值对形式的小型数据。相比之下，service worker和cache api提供了更有效的机制来缓存和管理静态资源，以实现离线访问。
* 以下是使用webpack配合service worker实现离线缓存的基本步骤
    1. 安装必要的依赖：workbox-webpack-plugin；
    2. 配置webpack：引入WorkboxWebpackPlugin并配置它来生成一个Service Worker文件，该文件将负责缓存静态资源。
    3. 注册service worker：在主HTML文件中，或者通过js动态注册service worker。确保在生产环境中注册service worker。
* 通过上述步骤，webpack将在构建过程中产生一个service worker文件，该文件会在用户访问应用时自动注册并开始缓存静态资源。当用户再次访问时，即使离线，service worker也能从缓存中提供这些资源，从而实现离线访问功能。

# webpack中css-loader和style-loader的区别？
* css-loader和style-loader是处理css文件的常用加载器，它们各自承担不同的职责，共同协作以在打包过程中正确管理和应用css样式；
## css-loader
1. 功能：css-loader主要负责解析css文件，并将css文件导入和URLs转换为webpack能够识别和处理的模块依赖。这意味着它能够处理css中的相对路径，将它们转换为正确的、可被webpack打包的模块路径。简而言之，它使得css可以像js模块一样被导入和处理；
2. 位置：通常情况下，css-loader位于加载链较早的阶段，特别是在需要进一步处理之前（比如通过style-loader或MiniCssExtractPlugin.loader）之前。
## style-loader
1. 功能：style-loader的职责是在浏览器中动态注入css。它将css-loader处理后的css代码插入到dom中，通常是通过创建style标签并将css内容放入其中的方式。这使得应用的样式能够立即生效，无需额外的http请求来加载外部css文件；
2. 位置：style-loader通常放在css-loader之后，在加载器链中更靠近打包输出的阶段。它负责将css-loader处理过的css代码应用到页面上。
## 组合使用
* 实际应用中，css-loader和style-loader通常一起使用，以实现从css文件中导入样式并直接注入到浏览器页面中的目的。一个典型的使用场景是在开发环境中，这样可以快速看到样式效果，而不需要刷新页面或单独管理css文件。
* 对于生产环境，通常推荐使用MiniCssExtractPlugin.loader替代style-loader，这样可以将css提取到单独的文件中，有利于缓存和性能优化。

# webpack中file-loader和url-loader的区别？
* file-loader和url-loader都是用来处理项目中静态资源的加载器，它们之间存在一些关键差异；
## file-loader
1. 基本功能：file-loader主要职责是将文件从源代码中移动到输出目录（默认dist下的特定子目录），并返回该文件在输出目录中的公共URL路径。这适用于任何类型的文件，不仅仅是图像文件。
2. 路径处理：它允许你自定义输出文件的名称和存放路径，这对于组织和管理输出文件结构非常重要。
3. 应用场景：当需要将资源文件保留在单独的文件中，并且希望在打包后的代码中通过URL引用这些文件时，file-loader是一个合适的选择；
## url-loader
1. 基本功能和附加特性：url-loader基于file-loader构建，除了具备file-loader的基本功能外，还提供了一个额外的功能，既可以将体积较小的文件转为base64编码的data url字符串直接嵌入到js或css代码中，而不是作为单独的文件输出。这样可以减少http请求，提供页面加载速度，尤其是对于小文件来说。
2. 阈值设置：url-loader允许设置一个阈值，只有小于这个阈值才会转为base64字符串，超过阈值文件则会像file-loader一样处理，即输出文件系统并返回URL路径；
3. 应用场景：当希望自动优化资源加载，减少http请求，特别是对于那些不会频繁变动的小文件，url-loader是一个很好的选择，它在提高性能的同时还能保持对大文件的传统处理方式。
## 总结
1. 相同点：两者都能处理文件并将其输出到指定目录，返回资源的URL路径；
2. 不同点：url-loader提供了将小文件转为base64字符串的额外功能，这对于优化加载时间和减少HTTP请求特别有用，而file-loader则专注于将文件转移到输出目录并提供url引用，不涉及base64编码转换；
3. 选择依据：根据项目需求和资源文件大小来决定使用哪个加载器，或在配置中结合使用两者，以达到最佳的性能和管理效果。


# git的快照指的是什么？
* 快照是git的一个核心概念，它代表了项目在某一个特定时间点的所有文件及其内容的整体状态。具体来讲
1. 快照的创建：每当执行一次git commit命令时，git就会创建一个快照。这个快照包含了都是工作目录中所有被跟踪文件的当前状态，包括文件的具体内容、文件的元数据等。值得注意的是，git的快照不仅仅是记录文件的差异或更改部分，而是记录每个文件的完整内容；
2. 内容寻址：git通过内容寻址存储来保存这些快照。每个文件的内容都会被计算出一个哈希值，这个哈希值与文件内容一一对应，基于此git能够唯一标识每个文件版本。因此每个提交实际上是对一个指向这些文件快照的指针。
3. 节省空间：git通过一个叫做blob的对象存储文件内容，当文件内容没有变化时，即使多次提交，git也只会存储一份该文件的内容。这样，即使项目有成千上万次提交，相同的内容的文件也不会重复存储，大大节省了存储空间；
4. 历史追踪：快照机制让git能够高效地追踪和回溯历史版本。每个提供都有一个唯一的ID，这个ID不仅代表了本次提交的快照，还包含了上一次提交的ID，从而形成了一个历史链条，便于版本追溯和比较。

# git的工作区域有哪三个部分组成？
1. 工作目录：这是开发者日常编辑和查看文件的地方。当在项目中添加、修改或删除文件时，这些改动首先发生在工作目录中。这是直接与文件交互的层面，也是最直观的部分。
2. 暂存区：暂存区是一个临时区域，用于保存计划在下一次提交时包含的文件更改。当使用git add时，会将工作目录中的文件改动从工作区域转到暂存区。暂存区起到了中转站的作用，使得有机会审查并精确控制那些更改将被纳入下一次提交。
3. git仓库：git仓库是本地存储所有历史提交、分支和标签的地方。它包含一个名为.git的隐藏目录，里面存储了所有版本化的文件信息和元数据。当使用git commit时，暂存区中的内容会被创建一个新的快照，并存储到git仓库中。这个仓库是项目的版本历史记录，允许回滚到之前的任意提交状态，查看历史更改，以及进行分支管理等操作。

# 在git中，如何对提交的版本打标签？
* 在git中，为提交的版本打标签是一个记录重要时刻或版本发布的好方法。打标签分为两种类型：轻量标签和附注标签。
* 轻量标签：它只是一个简单的指针到特定的提交上，没有其他额外信息；
```shell
git tag <tag_name> [commit_hash]
git tag v1.0
# 如果不指定commit_hash，则默认为最新的依次提交打标签；
```
* 附注标签：存储在git数据库中的一个完整对象，它包含标签名、标签信息、标签日期、标签者的名字和电子邮件地址，以及一个可选的GPG签名。相比轻量签名，附注标签包含更多的元数据，更适合作为正式版本发布
```shell
git tag -a <tag_name> [-m "<tag_message>"] [commit_hash]
git tag -a v1.1 -m "version 1.1 release" abc123465
# 这里abc123465是提交的哈希值，可以用它来精确指定打标签的提交点。
```
* 其他常用命令
```shell
# 查看所有标签
git tag
# 查看标签详情
git show <tag_name>
# 推送标签到远程仓库：如果你想分享你的标签，需要将其推送到远程仓库
git push origin <tag_name>
# 若要推送所有标签到远程仓库，可以使用
git push origin --tags
```
