
# 为什么不使用this.state直接修改数据？
1. 违反单向数据流原则：react鼓励单向数据流的设计模式，并在需要修改状态时通过回调函数或事件处理器传递回父组件。直接修改state会绕过这种有序的数据流动，使状态管理变得难以跟踪和理解，增加代码的复杂性和bug出现的可能性；
2. 无法触发组件重新渲染：react组件的状态是决定其输出的关键因素之一。当state发生变化时，react会自动调用组件的render方法，重新计算ui并更新dom。直接修改state的值并不会触发这一重新渲染过程，因此ui不会相应更新。为了确保状态变更后组件能够准确重新渲染，必须使用setState方法。
3. setState的批量更新与异步特性：setState方法不仅负责更新状态，还处理一些内部优化工作，如合并多次连续的setState调用，将多个状态更新排队并在稍后的一个时刻一次性应用，以及可能的异步更新。直接修改state会错失这些优化，可能导致不必要的重新渲染、丢失状态更新，甚至产生竟态条件。
4. 难以维护组件状态的一致性：使用setState时，可以传入一个函数而不是一个对象。这个函数接收当前state和传入的参数作为输入，返回一个新的state。这样可以确保在并发更新时，基于同一时刻的state计算新的state，避免竟态条件。直接修改state无法利用这种机制维护状态的一致性。
5. 违反react的最佳实践和编程约定：社区广泛推荐使用setState来更新状态，而非直接修改state。遵循这些最佳实践有助于编写出易于理解、维护、符合预期的代码，有助于团队成员之间的协作。

# vue的data中的一个属性值发生变化，视图是否会立即同步执行重新渲染？
* 属性值发生变化，会触发重新渲染过程，但是否立即执行完毕并反映到屏幕上取决于具体的更新策略和特定情况。
    1. 响应式系统与依赖追踪：vue使用响应式系统来监控data对象中属性的变化。组件实例创建时，vue会递归遍历data中的属性，通过Object.defineProperty将它们转为getter和setter，以便在属性值发生变化时通知相应的依赖，以便在属性值发生时通知相应的依赖。组件模板中的插值表达式、计算属性、监听器等会订阅这些属性，形成依赖关系。
    2. 视图更新流程：当一个响应式属性的值发生变化时，vue会触发相关依赖的更新。对于vue视图而言，这意味着组件的render函数将重新执行，生成新的虚拟DOM。接着，vue的虚拟domdiff算法会比较新旧虚拟DOM树的差异，计算出最少量的dom操作，最后将这些操作应用到实际的dom上，这个过程称为视图更新。
    3. 异步更新队列：默认情况下，vue采用异步更新队列来批量处理状态变更，这意味着在同一个事件循环中，若有多次data属性的变更，vue不会立即执行每次更改后的视图更新，而是将这些状态变更放入队列中，等待同一事件循环结束时一次性进行视图更新。这一做可以避免因频繁渲染而导致的性能开销，特别时当多个状态连续变化时。
        例外情况：在某些特定场景下，如使用nextTick、setTimeout或原生DOM事件处理器内部，状态变更更可能触发立即更新。这是因为这些情况发生在事件循环的不同阶段，vue无法将它们合并到同一个更新批次中。
    4. $forceUpdate：如果需要强制更新组件立即重新渲染，可以调用组件实例上的$forceUpdate方法。会跳过vue的响应式系统，直接触发组件的render函数重新组件，但在大多数情况下么这不是必要的，因为正常的响应式数据变更足以触发视图更新。过度使用$forceUpdate可能导致性能下降和不必要的渲染。


# webpack、rollup、parcel的优劣是什么？
## webpack
1. 优点
    * 灵活性：webpack提供了及其丰富的配置选项，可以精细控制每一个打包细节，包括模块解析、加载器、插件、优化策略等；适用于复杂的大型项目；
    * 生态丰富：webpack拥有庞大的生态系统，提供了无数的加载器和插件以应对各种场景，如处理不同类型资源（图片、字体、样式）、代码分割、懒加载、压缩优化、热更新等；
    * 代码分割：跳过动态导入、SplitChunksPlugin等机制，webpack能实现细粒度的代码分割和按需加载，有效优化首屏加载速度和总体性能；
    * Tree Shaking：借助于esm的静态分析、webpack能够实现tree shaking，去除未使用的代码，进一步减小包体积。
    * 模块热替换：Hot Module Replacement，wepack的HMR功能可以在开发环境中实现模块的实时更新，无需刷新页面即可看到改动效果，极大提高开发体验。
2. 缺点
    * 学习曲线陡峭：由于配置众多且复杂，初学者需要花费大量时间学习和理解；
    * 配置繁琐：对于小型项目或追求零配置的开发作者而言，可能需要编写大量配置代码，增加了项目的启动成本；
    * 构建速度：在大型项目中，webpack的构建速度可能相对较慢，尤其是初始化构建和增量构建时，虽然可以跳过缓存、多进程构建等方式优化，但配置和维护成本相对较高。

## rollup
1. 优点
    * 面向库和模块打包：rollup专为打包库和模块而设计，擅长将小块代码编译成高效、无冗余的IIFE或UMD格式，特别适合库的发布；
    * 优秀的tree shaking：rollup支持静态分析es模块导出导入，天生支持tree shaking，能够非常有效地移除未使用的代码，生成极小的bundle；
    * 简洁的配置：rollup的配置文件相对简洁，易于理解和编写，适合对构建过程有一定了解且偏好简洁配置的开发者。
    * 更快的构建速度：由于专注于模块打包，rollup在处理中小型项目或库时，构建速度通常优于webpack；
2. 缺点
    * 生态相对较小：相较于webpack、rollup的插件和加载器较少，某些复杂场景可能需要自行编写插件或寻找社区解决方案；
    * 对应用打包支持有限：rollup对于大型单页应用的打包支持不如webpack完善，特别是在代码分割、动态导入、HMR等可能需要更多手动配置或额外插件支持。
    * 配置复杂度随需求增长：虽然rollup的基础配置简洁，但随着项目复杂度增加，如果需要处理多种资源类型，实现复杂的代码分割等，配置文件可能变得复杂。

## parcel
1. 优点
    * 零配置：parcel最大的特点就是开箱即用，无需任何配置即可开始打包项目，非常适合快速原型开发和小型项目；
    * 内置一切：parcel内置了对多种类型文件的处理，以及代码压缩，tree shaking，HMR等功能；大大减少了依赖管理和配置工作。
    * 构建快速：parcel通过多线程和缓存机制实现了非常块的构建速度，即使时首次构建也能快速完成。
    * 易于上手：由于无配置，新手可以很快上手parcel、降低学习成本；
2. 缺点
    * 灵活性不足：对于需要高度定制化构建流程的大型项目或者有特殊需求的场景，parcel的零配置特性可能导致无法满足细致的打包需求；
    * 生态相对年轻：相比webpack、parcel的社区和生态系统还不够完善，可用的插件和教程较少；
    * 性能瓶颈：在处理大型项目时，parcel的内存占用和构建速度可能会称为瓶颈，尤其是在处理大量文件和复杂依赖关系。

# vuex的严格模式是什么，有什么作用？如何开启
1. 严格模式是一种旨在帮助开发者避免在非预期的情况下直接修改vuex状态树的机制。启用严格模式后，vuex对状态变更进行严格的监控，当监测到状态在外侧被直接修改时，它将抛出错误，提醒开发者遵循vuex的核心原则——所有的状态变更必须通过mutations进行；
2. 严格模式的作用：
    1. 强制遵循vuex的设计规范：严格模式确保所有状态变更必须通过提交mutations来进行，这是vuex期望的正确状态管理方式，它鼓励开发者遵循”单一数据源“原则，则状态变更集中化，使得状态变化可以预测、可追踪；
    2. 辅助调试：当直接修改状态时，严格模式会即时抛出错误，指出违规操作的具体位置，这对于调试和定位问题非常有帮助，尤其在大型项目中，可以及时发现并纠正不符合规范的代码；
    3. 提升代码质量和团队协作：通过强制执行规则，严格模式有助于团队成员遵守统一的规范和最佳实践，提高代码质量和一致性，它强化了状态变更和透明度和可维护性，使得代码审查和协作更为顺畅；
3. 如何开启严格模式：使用strict属性将其设置为true即可；开启严格模式后，直接修改state，vuex会报错，提示必须通过mutations更改状态；
    * 注意：严格模式在开发过程中非常有用，但因为他会增加额外的运行时检查，可能会影响生成环境的性能。因此在部署生产环境时，通常建议关闭严格模式，以避免不必要的性能损耗。
4. 总结：vuex的严格模式是一个重要的辅助工具，用于确保状态变更遵循vue新的设计原则，提升代码指令，方便调试和团队协作。通过在创建store时设置strict开启。


# 如何确保构造函数只能被new调用，而不是作为普通函数；
1. 检查this是否为实例对象：在构造函数内部，检查this是否为构造函数的实例，如果不是，抛出错误，这样，当构造函数被普通调用时，由于this通常是undefined或全局对象，函数将立即中断执行并给出错误提示。
```js
function MyClass() {
    if (!(this instanceof MyClass)) {
        throw new TypeError('Class constructor MyClass cannot be invoked without "new"');
    }
    // 构造函数逻辑
}
```
2. 使用类（ES6及以上）：如果使用es6类语法，构造函数默认只能通过new关键字调用。直接调用类会导致语法错误。
```js
class MyClass {
    constructor() {}
}
```
3. 使用工厂函数替代构造函数：如果不希望用户直接调用构造函数，可以考虑使用工厂函数封装实例化过程。工厂函数内部使用new调用构造函数，并返回新创建的实例。这样，用户只能通过调用工厂函数来获得类的实例，而不能直接调用构造函数。
```js
function createMyClassInstance() {
    return new MyClass();
}
const instance = createMyClassInstance();
```
4. 总结：
    1. 对于传统构造函数，检查this是否为构造函数实例，如果不是抛出错误；
    2. 使用es6类语法，类的构造函数只能通过new调用，直接调用会导致语法错误；
    3. 使用工厂函数封装实例化过程，隐藏构造函数，用户只能通过过程函数获取实例；


# 对于定长和不定长的数据，HTTP是怎么传输的？
1. 定长数据传输
    1. 客户端发送请求时，如果请求体是定长数据，会在请求头中包含Content-Length字段；
    2. 服务器收到请求后，读取Content-Length值，等待接收相应长度的数据
    3. 客户端发送完全部数据后，服务器确认数据完整无误，开始处理请求并生成响应；
    4. 服务器响应头同样包含Content-Length字段，表示响应正文长度；
    5. 客户端接收到响应后，根据Content-Length接收完整的响应正文；
2. 不定长数据传输
    1. 对于不定长数据，客户端可以选择使用Transfer-Encoding：chunked。客户端将数据分为若干个分块，每个分块前附上十六进制的长度值，然后发送数据块，重复此过程直至数据发送完毕，最后发送一个长度为0的空分块表示数据结束。
    2. 服务器接收到chunked数据时，逐个解析并积累数据块，直到接收到长度为0 的分块，确认数据接收完成；
    3. 对于不定长的响应数据，服务器同样可以使用Transfer-Encoding：chunked。它将数据分块发送，每块签名带有长度信息，客户端按照chunked协议解析并累积数据，直到接收到长度为0的分块。
3. 在实际应用中国，HTTP数据传输可能会结合以下机制来更好处理定长和不定长数据：
    1. 持久连接：通过保持TCP连接的开放状态，多次HTTP请求/响应可以复用同一连接，减少建立新连接的开销，对于传输大体积数据更高效。
    2. 分块编码：如前所述，这是一种针对不定长数据的有效传输机制，尤其适用于数据大小未知或动态生成的情况；
    3. 流失传输：对于非常大的不定长数据，可以使用http流失传输，允许客户端在数据传输过程中就开始处理数据，而不是等待整个数据完全接收完毕；
    4. Range请求：对于定长数据，客户端可以通过发送Range请求头指定只请求数据的一部分，服务器返回对应范围的数据。这对于断点传输、视频seeking等场景非常有用。

# JS脚本延迟加载的方式有哪些？
1. JS脚本延迟加载，旨在提高网页加载速度，尤其是初始化速度，通过对推迟非关键脚本的执行或加载，直到它们对页面渲染或用户体验产生直接影响的时刻。
    1. script标签的defer属性：使用defer属性时，浏览器会异步下载脚本，并确保在文档解析完毕且DOMContentLoaded事件触发前，按照脚本在文档中的顺序执行它们。这中做法既不会阻塞文档解析，又能确保脚本间依赖的正确执行顺序；
    2. async属性：async属性的脚本会被异步下载，一旦下载完成，浏览器会立即执行脚本，而不考虑其相对文档中其他脚本的顺序。这意味着脚本执行顺序不可控，适合哪些互相独立，无需依赖其他脚本的非阻塞脚本。
    3. 动态创建script标签：在需要加载脚本时，使用js动态创建script标签，并将其插入到文档中。这种方法提供了最大的灵活性，可以精确控制脚本何时加载和执行。
    4. 使用记载库或框架：模块加载器和模块打包工具提供的异步加载功能，可以按序加载模块或拆分代码，实现延迟加载。
    5. 使用Intersection Observer API：对于可视区域关联的脚本，可以利用Intersection Observer API，当元素进入可见区域时，加载对应的脚本；
    6. 使用async或defer的polyfill或模拟实现：对于不支持原生async或defer属性的老版本浏览器，可以使用polyfills或编写自定义代码模拟类似行为，实现脚本的异步加载和延迟执行。
    7. 使用preload或prefetch连接：使用link ref="preload"可以指示浏览器优先加载指定资源，而不会阻塞页面，prefetch则用于预加载未来可能需要的资源，优先级较低。这两种方式可以帮助提前加载脚本，但不立即执行。

# CSR和SSR分别是什么？
1. CSR（Client-Side Render）客户端渲染，是指浏览器内容的生成和渲染都在用户的浏览器上完成，当用户访问网站时，服务器不直接发送完整以及渲染好的HTML页面，而是发送一个基本的HTML结构和一些初始化应用程序的js代码，这个基本HTML结构被称为shell或骨架屏，它可能只包含了网站的导航，布局框架等静态部分。浏览器加载到这个基本HTML文档后，开始加载并执行js代码，这些代码通常是由前端框架（vue、react、angular）编写的，他们负责向服务器发送异步请求来动态生成页面的实际内容，生成的DOM结构随后被浏览器渲染出来，呈现在用户眼前，因为渲染发生在客户端，所以后续的页面交互，路由切换等操作也主要由客户端js来处理；
2. SSR（Server-Side Render）服务端渲染则是指网页内容在服务器端生成HTML文档后，直接将完整的、已渲染好的HTML发送给客户端。当用户请求一个页面时，服务器不仅处理业务逻辑和数据查询，还负责使用系统的启动框架在服务器执行渲染过程，将数据和UI组件相结合，生成完整的HTML输出，浏览器接收到这个HTML后，可以直接解析并展示给用户，无需等待额外的js执行和数据获取。在SSR场景下，客户端接收到的初始化页面已经包含了所有必要的内容，用户可以立即看到完整的页面结构和数据，无需等待客户端js加载和执行，此外，搜索引擎爬虫等非js执行环境可以直接抓取到有意义的HTML内容，有利于SEO。
3. 总结
    * CSR：网页内容在用户浏览器中通过执行js代码动态生成，初始加载速度块，但你用户看到首屏内容之前可能需要等待js加载和执行，seo友好性较差。
    * ssr：服务器生成完整的HTML页面并直接发送浏览器，用户可以立即看到完整的内容，首屏加载体验好，有利于seo，但服务器端渲染增加了服务器负担，可能导致服务器响应时间增加，且需要处理好服务器端和客户端状态同步等问题。
    * 现代web应用通常根据实际需求，结合使用csr和ssr或者采用同构渲染等技术，以平衡用户体验、seo、性能和复杂性能等因素。

# 如何使用vue router进行深度链接？
1. vue router提供了对深度链接的支持，使用户可以通过浏览器地址栏直接输入特定的URL，或者通过分享、书签等方式访问应用内的特定路由。深度链接使得每个路由都可以拥有一个唯一的URL，从而实现对应用内各个页面的直接访问。步骤如下：
    1. 定义路由接口，包括路径和对应的组件；
    2. 启用HTML5 History模式：使用History模式需要服务器支持，以便将所有未匹配的请求重定向到应用的入口点，以确保在直接访问深层链接时能够正常加载vue应用。
    3. 使用路由守卫刷新和直接访问：当用户直接通过深度链接访问或刷新页面时，vue应用需要重新获取数据以填充对应的组件。
    4. 使用路由链接生成深度链接
    5. 处理外部链接和书签

# base64编码图片，为什么会使数据量变大？
1. 编码机制：Base64是一种二进制文本字符的编码方法，它使用64个特定字符来表示任意二进制数据量，具体来说，base64编码将每连续的3个字节二进制数据转为4个base64字符。这种编码过程遵循以下原则：
    1. 每3个字节被分为4组，每组6位。
    2. 对于不足3字节的数据，会在末尾填充0字节以形成完整的3字节块，然后进行编码。填充的字节在base64编码中用特定字符表示。
2. 数据存储：原始图片数据通常以二进制形式存储，而base64编码将其转为文本字符串。由于每个base64字符代表6位二进制数据，而一个字节由8位，因此：
    1. 对于恰好能整除3的字节数，base64编码后会得到4n个字符，这意味着原始数据量增加1/3；
    2. 对于不能整除3的字节数，除了增加1/3外，还需额外添加1或2个字节填充字符来保持编码后的长度为4的倍数，虽然填充字符不携带有效信息，但它们也计入总字符数。不过，相对于原始数据，填充字符所占字符比较小，对总体数据膨胀影响相对较小；
3. 总结：主要原因是编码机制将原本的3字节数据扩展为4个base64字符，直接导致了大约1/3的数据增长。此外，填充字符也会轻微导致数据增加。
