
# webpack的source map的作用 及 生产环境使用

1. 作用：用于解决js代码经过各种打包工具转换后难以定位源代码的问题。source map本质上是一种映射关系，它记录了构建过程中生成编译后代码与源代码之间的对应关系，便于开发者针对浏览器在开发者工具中定位的错误信息，快速定位到源代码。
2. 生产环境中：
    * 推荐使用source-map，产出独立的.map和对应的.js文件。这种情形下，，源代码不会被打包进生产文件中，减少生产文件大小，仅在调试时下载额外代码文件。
    * hidden-source-map：类型source-map，但不会生成的bundle中注入source map URL，可以用于生产，但要求开发者自己处理sourcemap的上传和关联工作。
3. 出于实际需要使用，生产环境的sourcemap是否启用取决于开发者的安全考虑。

# 重绘和回流的差异
1. 回流：渲染树中元素的几何或布局属性发生变化，浏览器需要重新计算元素在页面中的位置和尺寸，及其他受影响的元素尺寸和位置；
    * 添加或删除可见的DOM元素
    * 元素的内容发生变化
    * CSS样式属性发生变化，影响布局的属性display、float、position等
    * 浏览器视窗尺寸变化
2. 重绘：当元素的外观属性（前景、背景、边框颜色等）发生变化时，浏览器需要重新绘制元素，但不计算元素的位置和尺寸；
    * 改变背景
    * 文本颜色改变
    * 图片的src属性改变（新旧图片尺寸相同）
3. 影响范围
    * 回流：对元素及其子元素甚至整个渲染树产生连锁反应
    * 重绘：只对受影响的单个元素，不会引起周围元素的布局变动
4. 性能成本
    * 回流：性能开销大，涉及布局重新计算和布局树的更新，可能需要遍历整个渲染树。
    * 重绘：性能开销较小，仅重新绘制某元素的像素，但多次重绘仍可能消耗大量性能；

# CSS伪类和伪元素

1. 伪类：用于选择元素的不同状态，或元素在DOM树中与其上下文关联的特殊位置
    * :hover\:active\visited\:nth-child(n)\:focus等
2. 伪元素：用于创建或选择元素内的特定部分，这部分是真实存在的概念上的区域，并不是DOM树中的实际节点。伪元素用来插入内容，或者选定的部分应用样式。
    * ::before\::after\::first-letter\::first-line\::selection等
3. 语法差异：css3规范：伪元素使用::，伪类使用:
4. 应用目的不同
    * 伪类用于表示元素状态，对现有DOM的一种补充描述
    * 伪元素则用于创建或标记元素内的特定部分，这部分在视觉中存在，但在DOM结构不存在。

# 协商缓存
1. 缓存策略：有利于web应用性能优化，减少服务器请求压力；通过恰当的缓存策略，减少不必要的重复请求，可以加快页面加载速度；
2. 缓存类型
    * 强缓存：浏览器加载资源使用本地缓存的副本，判断强缓存的标准通常使用http头部
        * Expired：绝对时间戳，表示资源过期时间
        * Cache-Control：其中的max-age表示资源在客户端可以被缓存的持续时间
    * 协商缓存：浏览器请求资源前先检查本地资源是否过期，如果缓存有效，则向服务器发送条件请求（带有If-Modified-Since或If-None-Match头部）询问服务器资源是否发生改变。如果未改变，则返回304状态码及更新的头部信息，浏览器继续使用本地缓存；若资源更改，则返回200以及更新后资源。
        * ETag：实体标签，服务器为资源生成的一个唯一标识，每次资源更新都会变化；
        * Last-Modified：资源最后一次修改时间，浏览器通过对比这个时间确定本地资源和服务器资源是否过期。
3. 合理使用缓存策略，web应用可以减少不必要数据传输，缩短页面加载时间，缓解服务器压力。

# 加快页面加载的速度手段
1. 减少DNS查找
    * 利用DNS预解析，减少DNS查找所需的时间消耗；
    * 减少不必要的不同域名资源加载，每次跨域请求都需要DNS解析，影响页面加载速度；
2. 精简和压缩资源
    * css、js、html打包压缩，gzip传输
    * 图片资源合理压缩，使用正确的格式，精灵图减少图片加载数量
    * 删除无用代码和注释
3. 资源合并和拆分
    * 合并css、js，减少HTTP请求数量
    * 按需加载和动态载入模块，避免一次性加载过多资源
    * 代码分割，大文件拆分为按需加载的小文件
4. 资源缓存和CDN加速
    * 设置合理的http缓存头（cache-control、expires、etag、last-modified），利用客户端缓存减少重复请求
    * 使用内容分发网络（CDN）托管静态资源
5. 异步加载和懒加载
    * 异步加载js资源，避免阻塞页面渲染
    * 图片等非首屏资源，使用懒加载
6. 使用Service Worker
    * 创建Service Worker脚本，实现离线缓存和资源拦截，提供离线访问功能
7. 优化css和js
    * css放在head，避免渲染阻塞，或使用rel="preload"预加载
    * 非必要js放在底部，或使用async和defer属性异步加载
8. 图片优化
    * 使用精灵图，base64或矢量图
    * 使用响应式图片适配不同尺寸设备屏幕尺寸
9. 优先加载关键资源
    * 使用资源优先级Hint标签，指示浏览器预加载关键资源
10. 合理组织和优化DOM结构
    * 减少DOM数量，避免复杂和冗余的DOM结构
    * 使用CSS3硬件加速特性优化动画和过渡效果


# 什么是HTTPS中间人攻击？如何防止
1. HTTPS中间人攻击人是一种网络安全威胁，发生在两个网络实体之间建立的HTTPS连接中。攻击者通过非法手段在通信路径中插入自己作为”中间人“。伪装每个通信反向上的合法接收者，以此截获、监视、篡改甚至伪造双方传递的数据，而不被实际的发送者和接收者察觉。
2. 中间人攻击针对HTTPS连接的具体过程通常包括如下几个步骤：
    * 拦截通信：攻击者设法使受害者的网络流量经过其控制的设备，或者利用漏洞、社会工程学等方式诱骗受害者连接到攻击者设立的虚假网络服务。
    * 伪装身份：当受害者尝试与目标网站建立HTTPS连接时，攻击者冒充该网站向受害者发送一个伪造的SSL/TLS证书，但实际上是由攻击者自行签发的，指向了攻击者控制的服务器；
    * 建立信任：如果受害者没有正确验证证书的有效性，可能会错误地接受伪造证书并建立起看似安全的HTTPS连接
    * 窃取与篡改数据：一旦受害者与攻击者建立了假冒的HTTPS连接，后续的所有通信都会经过攻击者。此时，攻击者可以解密并查看原本应为私密的传输内容，同时可以修改数据后重新加密，发送给真正的服务器或回传给受害者，而双方均无感知。
3. 防止HTTPS中间人攻击手段：
    * 使用有效的HTTPS证书：网站应当从受信任的证书发布结构获取并安装有效的SSL/TLS证书。证书包含正确的域名信息，且链接至一个可信的根证书。这样，当客户端与服务器建立连接时，能够验证证书连接及其签名来确认服务器的身份。
    * 严格证书验证：客户端必须实施严格的证书验证逻辑，检查证书的有效期、域名匹配性、链接完整性和CA信任度。如果证书不符合标准，客户端终止连接并警告。
    * 启用HTTP Strict Transport Security（HSTS），启用HSTS策略，通过HTTP响应头告知浏览器仅允许通过HTTPS与该网站通信，并在一定时间内强制所有对该域名的访问都使用HTTPS。这有助于防止降级攻击，确保用户始终通过加密通道访问网站。
    * 更新与管理信任存储：用户应定期更新操作系统和浏览器，确保其内置的CA根证书列表是最新的，且不含已知被撤销或不信任的证书。企业环境可以进一步精细化管理内部CA和新人策略，限制非官方或不可信的CA证书。
    * 教育用户识别安全警告：教育用户理解和重视浏览器或其他应用程序显示安全警告，特别是关于证书的提示。
    * 使用更高级的加密协议与算法：保持SSL/TLS协议版本及加密套件的更新，弃用已知存在漏洞的旧版本。使用强加密算法和足够的密钥长度，增强对中间人的攻击抵抗力；
    * 端到端加密与附加安全屋：对于敏感的数据交换，可以考虑采用端到端加密或应用级的安全协议，在HTTPS基础上提供额外的安全保障；


# 观察者模式的原理，及其应用
1. 观察者模式是一种行为设计模式，它定义了一种一对多的依赖关系，使得当每一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新；
2. 核心原理：
    * 主题接口与观察者接口：
        * 主题接口定义了添加、移除观察者以及通知所有观察者的方法
        * 观察者接口定义了一个更新方法，供主题调用以通知观察者状态变化
    * 主题类：
        * 实现主题接口，负责维护一个观察者列表
        * 提供方法让观察者注册自身和取消注册
        * 当主题状态发生变化时，调用观察者接口的更新方法遍历列表，通知所有已注册的观察者。
    * 观察者类：
        * 实现观察者接口，提供具体的更新逻辑
        * 在接收到主题的通知时，根据主题提供的新状态更新自身的状态或执行相应操作
    * 松耦合：
        * 主题只知道观察者实现了特定接口，无需了解观察者的具体实现细节
        * 观察者只知道关注的主题发生了变化，但不必关心变化如何发生的，也不直接依赖主题的内部状态；
3. 应用场景
    1. GUI应用程序：用户界面组件的状态变化需要触发其他组件的更新。
    2. 发布订阅系统：消息队列、事件总线等系统中，发布者发布消息时，所有订阅该主题的接收者都能收到通知并进行相应处理。
    3. 状态同步：对象的状态更新需要及时传播到多个相关对象，而这些对象的数量在运行时可能是动态变化的。
    4. MVC架构：模型作为主题，视图作为观察者。当模型数据发生变化时，自动通知关联的视图更新显示。
    5. 实时数据监测：如股票价格监控系统，当某只股票的价格变动时，所有关注该股票的用户终端应该能立即获得更新。
    6. 缓存失效通知：数据库或其他数据源的状态变化时，需要通知缓存系统刷新对应的缓存项，以保持数据一致性。
    7. 社交网络更新：用户可以订阅其他用户的话题更新，当被订阅对象有新动态时，系统自动推送给订阅者。
4. 总结：观察者模式适用于任何需要在对象之间建立一种灵活的、低耦合的依赖关系，使得一方的变化能够自动触发另一方的行为的情况。它促进了对象间的解耦，增强了系统的灵活性和可扩展性。

# 使用Object.defineProperty实现数据劫持的优缺点
1. 优点
    1. 数据代理：Object.defineProperty提供了对象属性的底层访问控制，可以用来创建”透明“的数据代理，即在访问和修改对象属性时，通过定义的getter和setter方法拦截这一行为，实现对数据读写的监控和控制；
    2. 响应式编程基础：在前端框架中，Object.defineProperty是实现响应式的核心技术之一。通过对数据对象的属性逐一进行定义，框架能够在数据变化时触发相应的视图更新，实现双向数据绑定；
    3. 细粒度控制：可以针对单个属性进行定制化的设置，比如只读属性、不可枚举属性、禁止删除属性等，这种细粒度的控制有助于构建复杂的数据模型和权限管理系统。
    4. 兼容性良好：Object.defineProperty早在ES5规范中引入，现代浏览器对其支持广泛，对于不需要支持非常老的浏览器项目来说，这是一个稳定可用技术
2. 缺点
    1. 递归处理繁琐：对于嵌套对象或数组，需要递归遍历所有层级的属性并定义其getter和setter，实现起来较为复杂，尤其是数组，需要额外处理索引属性和length属性，以及方法如push、pop等，以确保完全的数据响应。
    2. 性能开销：相比直接访问对象属性，通过getter和setter进行数据访问和修改会有一定的性能损耗，尤其是在大量数据和高频操作的场景下。尽管现代浏览器对这些原生方法进行优化，但仍然无法达到直接访问属性的性能水平；
    3. 无法直接监听数组变化：Object.defineProperty本身并不能监听数组元素的增删或索引变更操作，需要额外的逻辑来实现对数组变异方法的拦截；
    4. 初始化时需要深度遍历：响应式系统在初始化阶段就需要对整个数据树进行深度遍历，逐个定义属性的getter和setter，可能导致比较高的内存占用和较长初始化时间，特别是在大型应用中处理大量数据时；
    5. 无法动态添加新的属性：如果在运行时动态添加对象的新属性，除非显式再次调用Object.defineProperty为其定义getter和setter，否则这些新属性不会成为响应式的。这意味框架需要额外机制监测处理这类情况。

# import和require的区别
import和require都是用来在js中实现模块导入的功能，但它们基于不同的模块系统规范，有各自的特性和使用场景；区别如下：
1. 模块系统规范：
    * import：符合es6及以上版本的模块系统规范，也称为ESM，这是js语言标准的一部分，旨在为浏览器和服务器环境提供原生的模块支持；
    * require：基于COMMONJS规范，最初用于NODE环境，后来被其他许多工具用于浏览器环境。AMD是另一种类似COMMONJS规范，不过现在较少使用；
2. 加载时机：
    * import：静态加载，即在编译时确定模块的依赖关系，编译器根据import语句解析出模块的依赖图，并在运行时按需异步加载模块，这种特性使得编译器可以进行静态优化，如tree-shaking；
    * require：动态加载，即在运行时才加载模块，require是一个函数调用，可以在代码的任何位置动态决定加载哪个模块，因此无法在编译时进行静态优化。
3. 语法差异：
    * import：使用声明式语法，可以导入单个或多个导出成员，支持命名导入，默认导入，解构赋值等多种形式。
    * require：使用函数调用语法，返回的是一个对象或模块的默认导出。
4. 模块导出：
    * import：配合export关键字进行模块导出，支持命名导出、默认导出和重新导出。模块本身不是一个对象，而是通过export显示生命对外暴露出的内容；
    * require：使用module.export或exports对象导出模块内容。模块作为一个整体被视为一个对象，可以直接修改这两个对象来添加或修改导出的内容；
5. 适用环境：
    * import：逐渐成为浏览器和node环境的标准模块加载方式。现代浏览器原生支持import，node从把呢不能13.2.0开始支持esm
    * require：历史悠久，广泛用于nodejs生态系统，通过构建工具在浏览器环境中使用，nodejs在传统commonjs模块依然占据主导地位；
6. 执行上下文：
    * import：导入的模块会在其自身的作用域内执行，互不影响。顶级import语句会提升到到模块的顶部执行；
    * require：执行时会将模块内容合并到调用require的上下文，各模块之间共享全局作用域（除各自的作用域内变量）

# 怎么理解前端路由？
前端路由是指在web前端应用程序中，通过纯客户端的技术实现不同页面之间的导航或切换，而无需每次都向服务器发起完整页面的请求，它是单页面架构中的核心组成部分，允许用户在浏览过程中如同访问多页面程序一样，看到URL地址栏的变化，但实际并未触发页面的整体刷新，而是局部更新视图内容。前端路由的理解可以从以下几个关键点展开：
## 目的和价值
1. 用户体验优化：
    * 平滑过渡：前端路由通过ajax请求，DOM操作等技术实现数据更新和视图切换，避免传统多页面程序中页面刷新带来的闪屏、白屏现象，提升了页面过渡的流畅度和用户体验。
    * 快速响应：由于大部分数据交互和界面更新在客户端完成，减少了与服务器的往返通信，使得应用响应速度更快，尤其在网络状况不佳时更为明显；
2. 资源高效利用：
    * 减少服务器压力：前端路由降低了服务器端渲染的需求，很多情况下只需首次加载必要的HTML、CSS、JS资源，后续页面交互主要依赖客户端逻辑处理，减轻服务器负担；
    * 减少网络请求：在一个SPA中，公共资源只需加载一次，后续页面切换只需请求所需的数据即可，降低了总体宽带消耗；
3. SEO友好
    * 虽然前端路由主要用于SPA的无刷新导航；但对于搜索引擎优化有一定的挑战。现代前端路由解决方案已经能够较好解决这个问题，确保SPA也能产生易于爬取和索引的HTML内容；
## 核心技术原理
1. URL与视图映射：前端路由的核心是建立URL路径与应用内部组件之间的映射关系。当用户点击路径、输入URL或通过程序调用改变当前URL时，前端路由系统捕获URL变化，解析出对应的路由规则，进而加载并渲染对应的组件或资源；
2. 路由管理与路由表：通常有一个路由管理其器（Router）负责管理路由规则、解析URL、触发视图切换等任务。路由规则储存在路由表中，每个条目包含路由路径、对应的组件或渲染回调函数、可能的参数或查询条件等信息；
3. History API与路由模式
    * 现代浏览器提供了History API、允许js提供浏览器的历史记录栈，从而实现URL的更改而不触发页面刷新。前端路由通常使用History API的pushState、replaceState方法来改变URL，并兼通popstate事件以相应浏览器前进/后退按钮的操作。常见路由模式包括：
    * 哈希路由：理由URL中的哈希部分表示路由。更改哈希路由不会触发页面更新，早期spa常使用此方式；
    * HTML5 History API路由：直接操作URL路径，提供更友好的URL结构，需要服务器配置支持任何路由路径都返回同一个HTML入口文件；
4. 数据获取与懒加载：在视图切换过程中，前端路由可能触发对应组件的数据获取。一些路由库还支持路由级别的代码分割和懒加载，即按需加载对应路由所需的组件或模块，进一步优化首屏加载速度和资源利用率；
## 生命周期与钩子函数
1. 前端路由库通常提供一系列生命周期钩子函数，如beforeEnter、beforeRouteUpdate、afterEach等。允许开发者在路由切换特定时刻执行自定义逻辑，如权限校验、数据获取、滚动位置回复等；
## 配合后端与服务器配置
1. 在SPA中使用前端路由时，需要服务器配置支持所有未命中静态资源的请求都返回同一个入口文件HTML，以便浏览器前端路由接管后续导航。通常涉及Apache的.htaccess，nginx的location配置或使用服务器端框架提供的路由重定向规则；
