
# 导入样式时，使用link或@import有什么不同？
1. 语法和位置
    * link：这是一个HTML标签，直接在HTML文档的head部分声明，用于链接外部资源，如css文件；
    * @import：这是一个css语句，置于css文件内部，用于从当前样式表中导入其他样式表。
2. 加载顺序与性能
    * link：当浏览器解析HTML文档，遇到link标签会并行发起请求下载指定的css文件，与html文档的其余部分同步加载。这意味着样式表的加载不会阻塞html文档解析，有助于提高页面渲染速度；
    * @import：@import规则所在的css文件必须先被下载和解析，然后浏览器才会发现并处理@import指令，继而加载被导入的css文件。这种串行加载方式可能导致延迟渲染，特别是在@Import位于css文件底部或嵌套多层时，可能会增加首次渲染的等待时间；
3. 兼容性
    * link：标准html标签，具有广泛的浏览器支持，包括所有现代浏览器以及较老版本的浏览器；
    * @import：虽然是css2.1规范的一部分，但其在某些旧版浏览器中的支持可能有限或存在问题。在实际应用中，link优于@import；
4. 可操作性与动态性
    * link：作为html元素，link可以通过js动态添加、修改或删除，从而实现样式表的动态加载或切换；
    * @import：@import规则是静态的css语句，一旦css文件被加载，无法通过js直接干预其行为。若需动态调整样式，使用link更为灵活；
5. 从属差异与功能扩展性
    * link：不仅加载css，还可以用于连接其他类型的外部资源，如rss feeds、favicon图标、preload指示等，具有更强的功能扩展性和通用性；
    * @import：仅用于css样式表导入，功能单一；

# vue的初始化过程，new vue(option)都做了什么？
1. 实例初始化
    * 选项合并：传入的option选项对象被合并到vue实例的默认配置中。data、computed、methods、beforeCreate、created等；
2. 响应性系统设置
    * 数据代理：通过object.defineProperty或其他类似机制为data对象的所有属性设置getter和setter，实现数据的响应式。
    * 观察者：vue会对data对象及其嵌套对象进行递归遍历，将每个属性转换为响应式的观察者对象。同时，vue处理了数组的特殊方法，使其能够触发视图更新；
3. 模板编译：
    * 如果template选项或在el选项指定的元素内找到内联模板，vue会使用其模板编译器将模板字符串转换为可执行的渲染函数。这个过程包括词法分析、语法解析、优化、代码生成等步骤，最终生成一个能够根据数据生成dom结构的函数。
4. 挂载元素
    * 元素查询：如果提供了el选项，vue会查找对应的dom元素。如果没有提高，vue将会在后续的生命周期钩子中等待用户手动挂载；
    * 挂载组件：如果找到dom元素，vue开始挂载过程，清除元素内的原有内容，准备将新创建的vue实例渲染到该元素上。
5. 生命周期钩子调用
    * 完成上述初始化过程后，vue会适时调用对应的生命周期钩子。
6. 渲染与更新
    * 首次渲染：如果存在render函数获已经编译好的渲染函数，vue会使用这些函数结合当前的数据状态生成虚拟DOM，然后通过虚拟DOM diff算法与实际dom进行对比，最小化更新dom，完成首次渲染；
    * 响应式更新：此后，每当数据发生变化时，vue会重新执行渲染数据，根据新的数据状态生成新的虚拟dom，在进行diff并更新dom，确保视图与数据一致。

# js中如何处理大数计算问题？
* 当数值类型过大，超过了js所支持的最大安全整数范围（Number.MAX_SAFE_INTEGRE：约为9007199254740991），直接处理这类数值可能导致精度丢失，可以采取如下策略：
    1. 使用BigInt类型：es2020开始，js引入了原生的bigint类型，用于表示任意大小的整数，不受Number类型的最大安全整数限制。BigInt与Number类型互不兼容。但可以进行基本的算术运算，要处理后端返回的超大数值，可以将其转为BigInt，要确保后端返回的超大数值以字符串形式传输，并在客户端使用BigInt进行处理。如果后端返回的是JSON数据，确保在JSON解析前将数据转为字符串。（因为json不支持BigInt类型）；
    2. 使用第三方大数库：如果项目环境不支持BigInt或者需要更复杂的数学运算，可以使用第三方库：
        * big.js
        * decimal.js
        * bignumber.js
    这些库提供了类（Big、Decimal、BigNumber）来表示和操作大树，支持各自算术运算，舍入模式，精度控制等功能。使用时，将后端返回的超大数值字符串传输给库支持的构造函数创建相应对象，然后进行计算；
    3. 后端配合：如果可能，与后端协调，让后端在返回超大数值是进行适当处理：
        * 分段处理：对于特别大的数值，如果不需要一次性处理全部，可以让后端按序分段返回数据，客户端进行合并计算；
        * 转为字符串：客户端直接返回字符串表示，客户端需要时转为bigInt或使用大数库处理；
        * 专门提供API：对于复杂的大数值计算任务，可以由后端提供专门的api进行处理，客户端只需发送请求并接收结果；
    4. 数据格式约定：确保后端约定好数据传输格式，尤其是超大数值：
        * 统一以字符串形式传输：避免因json自动转换导致的精度丢失；
        * 明确数据类型：在API文档中明确指出哪些字段可能包含超大数值，以及期望的处理方式；

# 浏览器为什么对后端api接口返回的超大数值进行截断，导致精度丢失，只能使用字符串形式传输大数值？
1. 主要是由于js（在浏览器环境下）对数值类型（Number）的内在限制和json数据格式的标准规定所致；
    1. js number类型的限制：基于IEEE 754双精度浮点数标准，它可以表示整数范围大约为[-(2^53 - 1), 2^53 - 1]。超出这个给范围的整数在js中由于无法精确表示，会导致精度丢失。这是由于浮点数表示法的本质限制，而非浏览器特意截断；
    2. json标准格式：json要求数值类型的值必须符合ECMAScript规定的双精度浮点数标准。这意味着，如果后端以json格式返回超大数值时，如果直接使用数字形式，任何超出Number的类型安全整数范围的数值都会在json序列化的反序列过程中遭受精度损失。
    3. 截断现象：当浏览器收到API返回的json数据并对其解析其，json解析器按照json标准对文本字符串转换为js的数据类型，对于超大数值，由于json格式限制，他们会被解析为number类型，进而受到上述浮点数表示范围的约束。当数值超出范围，超出部分会被截断，导致数值精度丢失。实际上，这不是真正的截断，而是由于数值表示范围限制导致的近似值取舍。


# 一比特字符和两比特字符分别是什么？
1. 一比特字符：指在某个编码系统中，字符仅使用一个二进制来表示。由于一个二进制只能表示两种状态，因此在一比特字符系统中，理论上最多可以表示两种不同的字符。在实际应用中，单独使用一比特编码字符的情况相对罕见，因为这样的编码效率极低，通常只能在极简化的通信协议或特定的硬件接口中可以见到。
2. 二比特字符：指在某个编码系统中，某个字符使用两个二进制来表示。由于两个二进制可以组合成四种不同的状态，因此两比特字符系统理论上最多可以表示四种不同的字符。这一的编码方式相比一比特显著提高了信息密度，但仍然比较简单，适用于需要少量离散符号的场景；


# 前端中版本管理的理解？
1. 源代码版本管理
    1. 分支管理：创建特性分支、修复分支并进行并行开发，遵循一定的分支命名和合并规范；
    2. 提交记录：遵循信息提交规范，清晰记录每次改动的目的和内容，便于后期查阅和生成变更日志；
    3. 合并与冲突解决：使用pull request或merge request工作流，进行代码审查和冲突解决，确保代码质量并保持历史记录的清晰；
    4. 标签与版本发布：使用标签标记特定的提交作为正式版本，便于快速定位和回滚到特定版本；
2. 依赖管理
    1. package.json与lock文件：维护package.json定义项目依赖及其版本返回，package-lock.json或yarn.lock精确锁定版本信息，确保团队成员和持续集成环境构建出一致的依赖树；
    2. 版本策略：遵循语义化版本原则，合理指定依赖版本范围，平衡稳定性和特性引入；
    3. 更新和审计：定期运行npm update或yarn upgrade更新依赖，使用npm audit或yarn audit检查安全漏洞，确保依赖的安全性；
3. 静态资源版本控制
    1. 哈希内容：在构建过程中为静态资源文件添加基于内容的哈希值，确保每次内容变更时生成新的文件名，避免浏览器缓存过期资源；
    2. 公共路径：使用cdn托管静态资源，通过URL版本控制或查询参数来更新缓存更新；
4. 版本接口管理
    1. 版本标识：在请求头或URL路径中明确指定接口版本，以便服务器提供版本特定响应；
    2. 版本协商：客户端与服务器协商使用最新的兼容版本，活在发现新版本时提示用户更新前端应用；
    3. 向后兼容：在设计接口时考虑版本演进的向后兼容性，避免不兼容更改导致旧版本客户端失效。
5. 持续集成与部署
    1. 构建版本：根据特定分支或标签触发构建，生成带有版本信息的构建产物；
    2. 测试与质量保证：执行单元测试、集成测试、代码风格检查等，确保版本质量；
    3. 发布与回滚：将构建成功发布到不同环境，并支持快速回滚到已知的稳定版本；


# iframe安全如何理解？
1. 潜在威胁与攻击方式
    1. iframe注入：攻击者可以通过跨域脚本攻击将恶意iframe插入到目标网页中，可能导致用户信息泄漏，恶意重定向；
    2. 跨框架脚本攻击：结合iframe和恶意js脚本，攻击者可以在不同框架间操纵数据，窃取用户的敏感信息进行其他恶意操作；
    3. 点击劫持：通过透明或巧妙隐藏的iframe覆盖在网页的关键区域，诱导用户在不知情的情况下进行转账、输入密码或安装恶意软件；
    4. iframe网络钓鱼：社交平台或允许第三方内容嵌入的应用中，恶意iframe可能进行伪装成合法内容，欺骗用户输入凭据或进行其他不安全操作；
    5. 资源消耗与DoS攻击：恶意iframe可能加载大量资源或执行耗时脚本，导致服务器性能下降甚至崩溃，形成拒绝服务攻击；
2. 安全防护措施
    1. 源地址白名单：严格限制iframe的src属性，只允许加载经过审核的、可信来源的页面，可以通过服务器端配置或前端代码动态验证iframe源地址；
    2. sandbox：为iframe添加sandbox属性，启用一系列安全限制，如禁用脚本执行、禁止导航、禁止表单提交等，可以根据实际调整具体的限制策略；
    3. COntent Security Policy（CSP）：实施csp策略，限制浏览器加载的资源类型和来源，可以有效防止xss攻击，并听过frame-src或child-src指令控制允许嵌入的iframe源；
    4. X-Frame-Option：服务器返回的HTTP头部字段，指示浏览器是否允许页面在ifram中显示，设置为DENY或SAMEORIGIN可以防止页面被嵌入到不受新人的iframe中；
    5. 用户教育与视觉提示：对用户进行安全意识教育、使它们了解点击劫持等风险。同时，为嵌入的iframe提供明显的视觉边界或提示，帮助用户识别其独立于主页面的内容；
    6. 实时监测与响应：部署安全监测工具，监测潜在的iframe异常行为，如加载异常资源、执行可疑脚本等，及时发现并响应安全事件。
3. 应对绕过安全限制的技术
    * 了解iframe安全还包括知晓攻击者可能尝试绕过上述措施的方法，如利用浏览器漏洞、中间人攻击、社会工程学等。因此，应保持对新兴威胁的警觉，及时更新浏览器、应用补丁、采用最新的安全技术验证嵌入资源的完整性，并定期审查和强化安全策略；


# vue3中的tree shaking特性是什么，举例进行说明？
* vue3中的tree shaking特性利用es6模块的静态分析能力，在编译阶段自动剔除未被引用的代码，从而实现：
    1. 减少最终构建的包体积，加快引用加载速度
    2. 提高代码执行效率，因为运行时无需解析和执行未引用的代码；
    3. 保持项目结构清晰，鼓励模块化开发，同时避免了无意识的代码冗余；

# 如何中断Promise？
* 中断promise通常不是直接通过promise的api本身实现的，因为promise的设计理念是不可取消的，一旦一个promise被创建并开始执行，它会已知运行到完成，不受外部干预影响。然而，在某些场景下，特别是vue应用中涉及到异步操作时，我们可能希望有条件地中止某个正在运行的异步任务。近观不能直接中断Promise，但可以通过以下几个方式间接实现类似效果：
    1. 取消令牌：这是一种常见的异步控制模式，适用于需要支持取消的长运行或可复用的任务。基本思路是创建一个令牌对象，该对象有一个标志表明任务是否应该取消，以及一个用于通知所有相关方任务已被取消的方法。在异步操作的执行过程中，定期检查该令牌的状态，如果发现已请求取消，则提前结束任务。
    2. 使用AbortController（浏览器API）：在现代浏览器环境中，可以利用AbortController和ABortSignal API来实现Promise的取消。AbortController提供了一个可以主动触发信号的控制器，而AbortSignal则是这个触发信号的载体。支持AbortSignal的异步API会在接收到信号的abort事件时停止执行。
    3. 使用第三方库（Axios、RxJS等）：许多成熟的库都内置了取消操作的支持。
* 总之，虽然不能直接“中断”一个promise，但可以通过设计可取消的异步操作模式，使用支持取消的浏览器API或第三方库来达到类似效果。

# 什么是typescript映射文件？
* 通常指的是typescript编译过程中生成的源码映射文件，其扩展名为.map。源码映射文件并不是typescript特有概念，而是广泛应用于各种编译器或转译器中，用于编译后的代码与原始代码建立起对应关系；
* 在typescript开发过程中，编译器会将typescript代码编译为js，这个过程涉及类型擦除、语法转换、代码压缩等操作，使得生成的js代码与原始ts代码在结构、变量名、行号等各方面存在差异。源码映射文件就是为了在这些查一下，帮助开发者在调试时能够准确地将错误堆栈、断点调试信息映射回原始ts代码；
* 其作用主要包括：
    1. 调试体验：映射源文件可以在浏览器调试时，操作的是对应的ts源代码。
    2. 错误追踪：通过源映射，错误信息可以被正确定位到ts代码原始位置。
    3. 第三方工具支持：许多构建工具、测试框架、性能分析工具，支持源映射文件，能够正确处理编译后的代码，依据映射关系正确解析和展示原始ts代码相关的信息；
* 在开发环境或测试环境，通常会启用源代码映射功能获得良好的调试体验，而在生产环境下，出于性能和隐私考虑，不建议开启该功能；

