
# 请求是异步的为什么会阻塞？
* 正常情况下，异步请求不会阻塞主线程，而是允许程序继续执行其他任务，待请求完成后通过回调函数、promise、async/await 等机制处理响应结果。然而，在某些特定场景下，即使请求本身是异步的，也可能出现”阻塞“现象。以下是可能导致异步请求看似阻塞的一些原因：
    1. 同步模式下的异步操作：虽然现代浏览器的js http库默认使用异步模式，但在某些旧版本API中可能存在同步请求，如XHR的open方法接受第三个参数，可以指定请求是否为异步（默认true）。如果设置为false，则请求会同步执行，导致主线程阻塞直到请求完成；
    2. 回调函数中的长时间计算或阻塞操作：即使异步请求本身没有阻塞主线程，但如果在回调函数中执行了耗时的计算、大量的DOM操作或其他可能导致阻塞的操作，可能会给用户带来”阻塞“的感觉。虽然程序逻辑在继续，但UI更新和用户交互可能会变得卡顿或无响应。
    3. 并发请求过多导致网络带宽瓶颈：尽管单个异步任务不会阻塞主线程，但如果短时间内发起大量并发请求，可能会导致网络带宽达到极限，进而影响请求响应速度。这种情况下，尽管每个请求是异步的，但由于网络资源限制，整个数据加载变慢，给用户造成”阻塞“的体验；
    4. promise中的错误处理不当：在promise中，如果没有正确处理中间环节的错误，后续promise可能不会得到执行，使得程序”卡住“。
    5. 异步操作堆积导致事件循环阻塞：虽然单个异步不会阻塞主线程，但如果短时间内有大量异步操作等待执行，它们可能会堆积在事件循环的任务队列中，这些任务逐个执行时，如果每个任务都耗时较多，可能导致主线程长时间忙碌，无法及时响应其他任务和用户交互。

# 介绍一下网络的五层模型？
* 层模型，又称作TCP/IP五层协议栈或Internet五层协议模型，是计算机网络体系结构中的一种简化模型，用于描述数据在网络传输的基本过程。这个模型将复杂的网络通信任务分解为五个逻辑层次，每一层负责特定的功能，并通过接口与相邻层进行交互。以下是五层模型及其功能的详细介绍：
    1. 物理层
        * 功能
            1. 定义了数据在物理媒介上的传输具体方式。
            2. 规定了电信号的特征，如电压、电流、频率、脉冲宽度等。
            3. 包含了物理设备接口、电器特性、机械特性和过程特性等方面的标准。
        * 主要协议/设备
            1. 电气和物理接口标准
            2. 传输介质
            3. 信号编码方案
    2. 数据链路层（Data Link Layer）
        * 功能
            1. 提供相邻节点间的可靠数据传输服务，确保数据在物理层上无差错传输；
            2. 实现帧的封装与解封装，定义帧的格式，包括源地址、目的地址、校验码等字段；
            3. 提供链路管理功能，如错误检查、流量控制、链路接入控制等；
        * 主要协议/设备
            1. 以太网
            2. Wi-Fi
            3. PPP（Point-to-Point Protocol）
            4. SLIP（Serial Line Internet Protocol）
            5. MAC（Media Access Address）地址
    3. 网络层
        * 功能
            1. 负责将数据从源主机传输到目的主机，实现跨网络的寻址与路由选择；
            2. 提供逻辑地址分配与管理，实现不同网络间的数据转发；
            3. 实现拥塞控制、网络互联以及网络拓扑的发现与维护；
        * 主要协议/设备
            1. IP（Internet Protocol，包括IPV4和IPV6）
            2. ICMP（Internet Control Message Protocol）
            3. IGMP（Internet Group Management Protocol）
            4. ARP（Address Resolution Protocol）
            5. RARP（Reverse Address Resolution Protocol）
            6. 路由协议（如RIP、OSPF、EIGRP等）
    4. 传输层
        * 功能
            1. 向上层提供端到端的数据传输服务，确保数据可靠交付或不可靠交付；
            2. 实现流量控制、拥塞控制、多路复用与分用、连接管理功能；
            3. 提供数据分段与重组、顺序控制、错误检测与恢复等机制；
        * 主要协议
            1. TCP（Transmit Control Protocol）：面向连接、可靠传输、提供数据报服务）
            2. UDP（User Datagram Protocol）：面向无连接、不可靠传输、提供数据报服务）
    5. 应用层
        * 功能
            1. 提供用户与网络之间的接口，支持各种应用程序和服务；
            2. 定义了应用程序使用的协议与数据格式，实现用户进程之间的交互；
            3. 处理特定的应用程序任务，如文件传输、电子邮件、网页浏览、远程登录等；
        * 主要协议
            1. HTTP（Hypertext Transfer Protocol）
            2. HTTPS （HTTP Secure）
            3. FTP（File Transfer Protocol）
            4. SMTP（Simple Mail Transfer Protocol）
            5. DNS（Domain Name System）
            6. Telnet
            7. SSH（Secure Shell）
            8. TLS/SSL（Transport Layer Security/Secure Socket Layer）

# 在一个DOM上同时绑定两个点击事件：一个用于捕获、一个用于冒泡，事件会执行几次？先执行冒泡还是捕获？
* 当点击DOM时，这两个事件都会被触发，具体执行次数和顺序如下：
    1. 执行次数
        * 两次。当点击事件触发时，事件会先言责DOM树自上而下传播（捕获），然后自下而上返回（冒泡）。在这个过程中，分别触发了捕获阶段绑定的事件处理器和冒泡阶段绑定的事件处理器，因此共执行两次；
    2. 执行顺序
        * 先执行捕获，后执行冒泡。事件传播遵循“捕获在前，冒泡在后”的原则。当点击事件发生时，首先触发的是设置为捕获的事件处理器。接着，事件继续向DOM树根本传播（冒泡），在此过程中触发设置为冒泡的事件处理器。


# 如何获取HTML元素实际的样式值？
1. 使用js的window.getComputedStyle方法，这种方法返回了一个CSSStyleDeclaration对象，包好了元素的所有计算样式，包括继承自父元素、浏览器默认样式、内联样式、外部样式表以及任何通过js动态设置的样式。
2. 步骤如下：
    1. 获取HTML元素：使用适当的DOM查询方法获取所需的HTML元素；
    2. 调用getCOmputedStyle方法：对所选元素调用该方法，传入元素作为参数；
    3. 访问计算样式的属性：使用点表示法或方括号表示法访问CSSStyleDeclaration对象上的样式属性名称，已获取实际的样式值。
    4. 注意：
        1. getComputedStyle返回的样式值是标准化的格式，例如颜色可能是rgb、rgba、hsl、hsla或十六进制表示；
        2. 如果样式值通过css变量（var(--custom-vat)）设置的，getComputedStyle会返回计算后的最终值；
        3. 获取到的样式值是字符串类型，如果需要进行数学运算或比较，需要进一步转换。
    5. 兼容性：大部分浏览器支持该方法；对于不支持的浏览器，可以使用currentStyle属性（IE）作为替代方案。