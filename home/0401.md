# 协商缓存中，由Last-Modified，为什么出现ETag
1. 分别解决不同问题，但都旨在减少网络带宽消耗和提升性能，引入ETag的原因如下：
    1. 精确度更高：Last-Modified基于最后修改时间，精确到秒级。对于更新频率搞得资源来说，这种精确度不够，ETag基于内容生成的一个唯一标签，资源变化，ETag变化，可以准确反映资源的变化。
    2. 弱一致性校验：ETag支持强弱校验。强校验表示内容字节完全相同，弱校验则表示内容”实质上“相同，但在一些微小的、对客户端不重要的方面有所变化。为服务器提供更大的灵活控制缓存。
    3. 针对非文件资源，不存在Last-Modified，所以引入了ETag。
    4. 动态生产内容：对于服务器端动态生成的内容，即使内容改变，也可能因为时间戳不变而导致Last-Modified不变，而ETag根据内容生成新的标识符，可以处理此类场景。

# vue中的template模板引擎渲染过程步骤
1. 模板编译
    * vue初始化时，解析用户编写的template标签的HTML模板内容
    * 这个过程会将模板转换为抽象语法树，即把模板转为一种易于程序处理的结构化表达式。
2. 优化
    * AST创建完成后，编译器对静态节点进行优化，识别出运行中不会改变的静态内容。
    * 这可以提高渲染效率，后续过程中，vue可以跳过这些静态节点的不必要比较和操作。
3. 生成渲染函数
    * 根据AST和优化后结果，vue编译器生成对应的js渲染函数
    * 渲染函数是纯函数，接受组件实例上的上下文数据作为参数，并返回虚拟DOM树；
4. 数据绑定和观察
    * vue2使用Object.defineProperty、vue3使用Proxy实现数据绑定和观察
    * 当数据变化时，响应式系统追踪变化并通知相应的更新；
5. 虚拟DOM更新
    * 数据变化时，vue调用之前的渲染函数，重新生成虚拟DOM树；
    * 然后应用diff算法，比较新旧虚拟DOM树，找出最小的更新差异，并将其应用到实际DOM上。
6. DOM更新和渲染
    * 最终根据diff算法对比结果，只对真正由变动的部分执行DOM操作。

# Request Header 和 Response Header
1. Request Header
    * Authorization：提供客户端认证信息
    * User-Agent：客户端标识，包括软件版本、名称等细节
    * Accept：客户端可接受的内容类型
    * Accept-Language：客户端可接受的语言
    * Content-Type：请求主体的数据类型
    * Content-Length：请求主体的长度
    * Cookie：发送给服务器的cookie信息
    * If-Modified-Since / If-Unmodified-Since：服务器协商缓存相关的条件请求头，用于检查资源是否修改
    * Referer：请求来源地址
2. Response Header
    * Cache-Control：控制缓存行为，例如最大缓存时间等
    * Connection：指定客户端与服务端之间连接的管理，例如Keep-Alive表面连接可以被复用。
    * Content-Type：响应体的MIME类型。
    * Content-Length：响应体的长度。
    * ETag：资源的唯一标识，用于缓存验证和协商缓存。
    * location：指示客户端进一步发出GET请求获取资源的未知，用于重定向
    * Set-Cookie：设置服务器端发送的cookie信息
    * Server：服务器软件信息
    * Expired/Last-Modified：资源的过期时间/最后修改时间

# Nginx支持哪些负载均衡调度算法
1. 轮询：默认算法，请求按照顺序逐一分配到后端服务器列表中，具有平等获得机会。
2. 加权轮询：类似轮询，但每个服务器具备权重，权重高的服务器更频繁接收请求。
3. 最少连接数：将请求转发给当前活跃连接数最少的后端服务器。
4. IP哈希：根据客户端的IP地址进行哈希运算，根据运算结果分配服务器，可以确保来自同一客户端的请求总被分配到同一台服务器，用于持久会话连接。
5. 通用哈希：基于除IP外的其他请求特征进行哈希运算，实现基于这些特征的会话粘滞。
6. 一致性哈希：通过一致性哈希算法减少在添加或移除服务器时需要重新映射的请求比例，实现更好的扩展性和负载均衡。
7. URL哈希：类似于上述哈希方法，但根据请求的URL进行哈希运算，将请求分配到固定的服务器。
8. 第三方模块：试图公平分配请求到后端服务，考虑到每个服务器的响应时间和当前正在处理的请求数量。

# 什么是SameSite Cookie属性
SameSite cookie属性是一项增强Web安全性的措施，它可以防止跨站请求伪造（CSRF）攻击，并提供对cookies在跨站请求中的行为控制。这个属性可以被设置在HTTP响应头的set-cookie指令中，以控制浏览器在何种条件下发送这个cookie
1. SameSite=Lax：默认情况下，Lax模式会阻止在跨站请求中携带POST、PUT等非简单方法的请求中的cookie。而对于顶级导航或同站子框架加载情况，Lax模式下cookie会被发送。
2. SameSite=Strict：Strict模型下，他要求只有当请求来源于同一个站点（同一域名、同一协议和同一端口）时，才会发送cookie。这意味着任何跨站请求，即使是顶级导航，都不会写道SameSite=Strict的cookie。
3. SameSite=None：意味着cookie将在所有的跨站请求中发送，包括第三方上下文。然而设置none时，出于安全考虑，需要设置Secure属性，意味着cookie只能通过https加密连接发送。

# vue可以定义函数式组件
1. vue的函数式组件时一种没有实例和内部状态的组件，它们存粹是基于传入的props生成渲染结果。函数式组件专注UI的展示逻辑，而不管理内部任何状态和生命周期。
2. vue2中使用functional:true定义函数式组件，并提供render方法
```js
Vue.components('componentName', {
  functional: true,
  props: {
    title: String
  },
  render(h, context) {
    return h('div', {}, context.props.title)
  }
})
```
3. vue3中，使用composition api定义函数式组件
```js
export default defineComponent({
  props: {
    title: String,
  },
  setup(props) {
    return () => (
      <div>{props.title}</div>
    )
  }
})
```
4. 函数式组件没有状态和生命周期，在某些情况下比普通组件更轻量级，渲染更快。

# 浏览器为什么要请求并发数限制？
1. 保护服务器：不限制同一域名的请求数量，容易造成服务器压力过大，导致崩溃。
2. 防止网络拥塞：过多并发导致网络带宽资源紧张，无限制下降低整体网络效率和稳定性。
3. 优化用户体验：浏览器通过对并发数量限制，可以合理分配有限的网络资源，保证关键的资源如js、css、html优先加载完毕；
4. 遵循http规范：HTTP/1.1虽然没有明确规定浏览器必须限制并发数量，但实际浏览器实现中都对同一源的并发数做了限制。HTTP/2及后续版本引入多路复用机制，进一步改善了这一个问题，但依旧存在一定的流量控制策略；

# Vue的异步更新策略实现机制
1. 核心：利用事件循环机制确保DOM更新在下一个tick时发生，而不是立即同步更新。大致过程如下：
    * 数据变化侦测：当响应式数据发生变化时，vue的数据劫持检测到变化
    * 依赖收集：vue组件实例化过程中会进行依赖收集，跟踪组件的计算属性等数据
    * 队列和调度：当数据变化触发后，vue不会立即更新视图，而是将待更新组件放入队列中，等待异步更新。这个队列基于微任务，即在当前宏任务完成后，在下一个事件循环tick执行。
    * nextTick方法：this.$nextTick允许开发者在DOM更新完成之后执行回调函数。
    * 异步更新流程：在事件循环微任务阶段，vue会遍历队列中组件，逐个进行必要的试图更新。这样做的好处是可以批量处理多个状态变更，避免频繁重绘和回流，从而提高性能。

# Typescript中的泛型
* 泛型：一种静态语言提供的特性，允许开发者创建可重用的组件，同时保持类型安全。泛型主要思想是在不明确指定具体类型的情况下定义函数、接口或类，然后在使用它们的时候指定具体的类型参数。
* 作用：
    1. 类型安全：泛型允许编译器在编译期间进行类型检查，确保不同类型的数据在使用同一个组件时都能符合预期，减少运行时由于类型错误导致的问题；
    2. 代码复用：使用泛型可以创建高度灵活和可重用的组件，适用于多种数据类型。
    3. 抽象和约束：泛型允许定义具有类型约束的函数或类，可以限制传入的类型需满足某种条件，增强代码的抽象程度和表达力；
    4. 类型推理：使用泛型，编译器可以根据上下文推导出泛型的具体类型，减轻了手动指定类型的负担。


# state和props的区别
1. 来源和可控性
    * props：由父组件传入子组件，子组件无法修改传入的props，只能由父组件修改后引起子组件重新渲染；
    * state：由组件内部自己维护，可以在组件存在的生命周期期间随时更改引起组件的重新渲染；
2. 生命周期
    * props在组件的整个生命周期中时固定的，除非父组件重新渲染并将新的props传入子组件；
    * state可以在组件的任意时刻通过setState修改，并触发组件的渲染；
3. 用途：
    * props：用于子父组件通信；
    * state：用于组件内部数据维护；

