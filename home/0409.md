
# 使用symbol函数需要注意注意的点
1. 原始数据类型：symbol是js的第七种原始数据类型，这意味着Symbol值是不可变的，且每个symbol值是唯一的；
2. 唯一性：每次调用symbol函数都会创建新的、独一无二的symbol值，即使传入相同的描述字符串，也会生出不同的symbol实例；
3. 描述字符串：调用symbol函数时可以传入一个可选的字符串参数作为symbol的描述。描述字符串旨在提供人类可读的信息，用于调式或文档，但不影响symbol值的唯一性。访问描述字符串可以使用symbol.prototype.description；
4. 不可用做构造函数：symbol时原始数据类型，不能使用new关键字调用；
5. 不可枚举、不可复制：symbol值作为对象的属性时，他们默认是不可以枚举的（不会出现在for\in循环、Object.keys()，JOSN.stringify）此外，symbol属性也不能通过常规的赋值操作复制到另一个对象。
6. 全局注册与查找：使用symbol.for可以基于给定的键在全局Symbol注册表中查找或创建一个共享的symbol值。这样不同上下文中的同名Symbol可以引用同一值。对应的Symbol.keyFor可以获取给定SYmbol在全局注册表中键。
7. 作为对象属性：Symbol常用于定义的对象的私有属性或方法，防止与其他属性名冲突，增强对象属性的安全性。由于Symbol值是唯一的，因此即使两个对象使用相同的Symbol键，它们的属性也是完全独立的。
8. 与其他数据类型的交互：SYmbol值不能用于索引，也不参与正常的算数运算。它们可以作为对象的属性键，但在一些传统的js操作中可能需要特殊处理；

# Node的进程间是如何进行通信的？
* node中的进程间通信（IPC，Inter-Process-Communication）主要分为以下几种：
    1. Message Passing(消息传递)
        * nodejs内置了进程间通信的消息机制，尤其适用于通过child_process.fork()创建的子进程。父进程和子进程都可以通过以下方法进行通信：
            1. 父进程向子进程发送消息：父进程通过childProcess.send方法发送消息给指定的子进程，消息可以是任何可序列化的js值。
            2. 子进程向父进程发送消息：通过process.send方法向父进程发送消息，消息格式于父进程发送相同；
            3. 接收消息：无论是父进程还是子进程都可以通过监听message事件来接受对方的消息；
    2. Shared Memory（共享内存）：nodejs的子进程可以通过child_process.fork创建时指定stdio:'ipc'选项来共享内容，虽然nodejs本身并未直接提供共享内存API，但可以通过nidejs的c++扩展或nodejs绑定的第三方库来实现更底层的共享内存通信。这种方式适用于需要高效、低延迟的数据交换场景，但实现相对复杂，且需要处理同步、锁定等问题；
    3. Socket Communication（套接字通信）：利用nodejs的网络编程能力，进程间可以通过TCP或Unix Domain Sockets进行通信。可以使用net模块创建服务器和客户端，实现进程间的数据交换；套接字通信适用于更复杂的网络架构，比如跨主机间的进程间通信，或者需要支持多个客户端连接的场景；
    4. RPC（Remote Procedure Call，远程过程调用）：使用专门的RPC库，可以简化进程间的函数调用。通过定义接口和方法，进程间可以直接像调用本地函数一样调用远程进程的方法。RPC库通常会封装底层的通信细节，提供统一的API供开发者使用。

# WeakMap和WeakSet的键为什么只能使用对象？
* 两者涉及的初衷时为了在特定场景下解决内存管理问题，尤其是与对象生命周期相关的内存泄露问题。键要求为对象的主要原因如下：
    1. 弱引用的特性需求
        * WeakMap和WeakSet的核心特性在于它们对键的引用是弱引用，弱引用不会阻止垃圾回收机制对所引用的对象清理。第一个对象没有任何强引用指向它时，即使它仍然被weakmap或weakset引用，该对象也可以被垃圾回收器视为可回收垃圾并释放占用的内存；
        * 非对象键无法实现弱引用：在js中只有对象才能实现弱引用，基本数据类型和symbol值本身不是对象，不能直接作为弱引用的目标，这些类型的值作为键存储在weakmap或weakset中，会先包装对象的形式进行隐式转换，但这并不是真正弱引用，回阻止垃圾回收，因此，为了保持弱引用的语义，规定键必须为对象是必要的。
    2. 避免内存泄漏与高效内存管理
        * 强引用导致的内存泄露：常规的map和set对的键的引用是强引用，这意味着只要键值对存在于集合中，无论外部是否有其他引用。在某些情况下，这可能导致即使不再需要某个对象，但由于它被map或set无意中保留下来，造成内存泄漏；
        * 与对象生命周期同步：weakmap和weakset允许键为对象，且仅保持弱引用，这意味着当对象在程序的其他部分没有任何强引用时，即使它仍然是weakmap或weakset中的键，垃圾回收器也能正确将其回收。这样，集合所引用对象的生命周期保持同步，避免不必要的内存占用；
    3. 隐私保护与内部状态管理：
        * 私有属性存储：weakmap常用于以对象为键存储私有属性或关联数据，特别是对实现类的私有属性或实现组件间的内部状态共享时，由于weakmap不暴露其键列表，且仅对象可以作为键，这提供了天然的封装性和安全性。如果允许键非对象，可能会破坏这种设计意图，使得非预期的数据关联称为可能；
        * 避免意外访问：Weakset用于存储一组唯一的对象实例，用于跟踪哪些对象已经加入某个集合或需要特殊处理，而不希望这些对象因集合的存在而阻止其正常回收。同样，限制键为对象有助于防止误操作或意外关联；

* 综上所述：weakmap或weakset要求键只能为对象，这是出于弱引用、避免内存泄漏、以及提供一定的隐私保护和内部状态管理功能的需要；这一设计确保了它们能够有效服务于特定的应用场景，与常规的map或set形成互补。

# new操作符具体做了什么？
1. 创建一个对象
    * 使用new操作符调用一个构造函数时，js引擎首先在内存中创建一个全新的空对象
    * 这个新对象继承自构造函数prototype属性，即其原型链被链接到构造函数的原型链上，意味着新对象可以访问构造函数原型对象上定义的所有属性和方法；
2. 绑定构造函数上下文：
    * 构造函数被调用时，其内部的this关键字被绑到刚创建的新对象上，这使得构造函数内部可以通过this来引用和操作新对象，从而能够初始化对象的属性或定义实例的方法。
3. 执行构造函数
    * 构造函数体内的代码随后被执行，在此过程中，可以向新对象添加属性或调用方法。这些属性和方法直接附加到新创建的对象实例上。
4. 返回新对象
    * 如果构造函数显式返回一个对象（非null且非基本类型）那么new操作符会忽略新创建的对象，转而返回构造函数返回的对象作为整个new表达式的值。
    * 如果构造函数没有显式返回一个对象，或者返回的是非对象（包括undefined、基本数据类型或null）则new操作符会默认返回最初创建的新对象。
5. 总结：new操作符在js中扮演了构造器的角色，它负责创建一个新对象，将其与构造函数关联起来，执行构造函数以初始化对象状态，最后确保返回一个可用的实例对象。

# 下拉加载和上拉刷新的机制，并说明如何实现？
* 下拉加载和上拉刷新是移动端应用和网页中常见的交互方法，用于动态加载内容；
1. 下拉加载
    * 机制
        1. 用户在列表顶部向下拉动屏幕
        2. 拉动超过一定阈值，触发加载新内容的动画效果和提示信息
        3. 放手后，应用发送请求获取最新数据，更新列表内容，同时回复列表到初始位置
    * 实现
        1. 监听触摸事件
            * 使用监听touchstart、touchmove、touchend等触摸事件来追踪用户的手指在屏幕上的滑动行为；
            * 计算手指滑动的距离（touchmove事件中的event.touch[0].clientY减去touchstart事件中的初始坐标
        2. 判断触发条件
            * 当滑动距离超过预设阈值（如屏幕高度的一定比例），且当前出于列表顶部时，激活下拉加载状态；
            * 显示加载指示器并隐藏原有顶部内容
        3. 处理释放事件
            * 在touchend中，如果仍处于下拉加载状态，发起数据请求
            * 请求成功后，用新数据替换或加载到原列表数据源，更新视图，并隐藏加载指示器；
        4. 取消或回弹效果
            * 若用户在触发下拉加载后又向上滑动，可以设定一定的回弹动画，使列表恢复原位并取消加载状态；
2. 上拉加载
    * 机制
        1. 用户滚动列表达到接近底部时，继续向上滑动
        2. 达到触发阈值后，自动加载更多内容，无需明显拉动操作
        3. 新内容加载完成后，无缝添加到现有列表底部，保持滚动位置
    * 实现
        1. 监听滚动位置
            * 监听scroll事件，获取滚动容器的滚动位置
            * 计算滚动到底部的阈值
        2. 触发加载条件
            * 用户滚动接近阈值，启动加载更多逻辑
            * 可以设置一定的延迟避免频繁请求
        3. 发起数据请求
            * 发送请求获取下一份数据，通常带有页码或分页标识
            * 请求成功后，将新数据追加到现有列表数据源
        4. 更新视图
            * 使用框架提供的数据绑定功能或手动操作DOM，将数据渲染到列表底部
            * 保持滚动位置不变，让用户感觉内容自然延伸；
* 总结：下拉加载和上拉加载更多实现主要依赖于触摸事件监听、滚动位置检测以及数据请求与视图更新。
