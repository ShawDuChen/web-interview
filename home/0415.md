
# 渐进增强和优化降级有什么不同？
1. 渐进增强
    1. 设计理念：首先确保应用在所有浏览器设备上都能够提供最基本的可用性和功能性，然后在针对具体更高级特性和功能的浏览器设备进行功能扩展和视觉优化。它强调内优先，确保内容在任何环境下都能被访问；
    2. 实施方式：从最基本的html开始，使用语义化标记来承载内容，随后添加css保证内容的可读性和基本布局，最后，通过js为支持环境添加交互性、动效或高级功能。对于不支持的的浏览器或设备，它们只会看到或执行到其支持的部分，而不影响核心功能；
    3. 关注点：渐进增强注重向前兼容，环关注未来技术和设备的发展，确保随着浏览器特性和设备能力的增强，用户体验能够随之提升。它鼓励开发者持续改进和增强网站，同时保持对旧环境的良好支持。
2. 优雅降级
    1. 设计理念：一种开发策略，假设开发者首先构建了一个概念齐全且充分利用最新web技术的完整应用，然后通过各种手段确保在较旧或功能首先的浏览器中，应用能够以某种形式降级运行，尽管可能缺少某些高级特性或视觉效果；
    2. 实施方式：从功能完备开始、设计完整的应用。之后，使用特性检查、浏览器嗅探或条件标准等方式识别不支持的某些特性的浏览器，然后为这些环境提供备选方案或简化版功能，目的是在不支持高级特性的环境中，尽可能保留应用的主要功能，即使这意味着用户体验有所降级。
    3. 关注点：更侧重向后兼容，关注现有的主流浏览器和已知的旧版浏览器，确保在这些环境中能够运行，即使功能或外观打了折扣。它倾向于一次性构建完备应用，然后处理特定环境的兼容问题；

# postcss的作用？
* POSTCSS是一个js插件转换css的工具，其核心作用是：
    1. 支持未来css语法：postcss允许开发者使用尚未被广泛支持的css语法特性，通过相应的插件将其转化为大多数现代浏览器可以理解的现行标准css。这使得开发者可以提前采用新的css规范，而不必等待浏览器厂商全面支持。
    2. 编译效率高：postcss声称其处理速度比传统的预处理器块3-30倍。高效的编译有助于提升开发者的构建速度和工作效率，特别是在大型项目中。
    3. 丰富的插件生态系统：postcss的强大指出在于其丰富的插件系统，这些插件提供了各种各样的功能，如：
        1. 自动添加浏览器厂商前缀
        2. 代码压缩与优化
        3. 引入css模块化，限制作用域，避免全局样式冲突
        4. linting以确保风格一致性和常见错误
        5. grid系统生成
        6. 图像处理与内联
    4. 模块化与作用域控制：通过插件如css modules，postcss可以实现css的模块化，将作用域限制在单个组件内，避免全局命名空间的污染和样式冲突。
    5. 与其他工具集成：postcss通常与前端构建工具（webpack、gulp）或任务运行器无缝集成，作为构建流程的一部分自动化执行css转换。

# 介绍下pm2，pm2依据什么重启服务？
* 介绍：pm2是一个强大的nodejs应用程序进程管理工具，主要用于简化nodejs应用的部署，管理和维护。它提供了多种实用的功能，确保nodejs应用在生产环境中能够稳定、高效地允许，pm2的主要特点和功能包括：
    1. 进程管理
        * 零秒重载：pm2能够平滑重启应用，使得在线用户几乎能够无感知服务更新。当应用代码发生变更时需要重启服务，pm2会先启动新的子进程，待其准备好接收请求后再优雅终止旧进程，从而实现无缝更新。
        * 进程监控：持续监控应用程序的状态，一旦发生进程异常退出或无响应，pm2会自动重启它，确保服务的高可用性。
        * 进程持久化：即使系统重启，pm2也能确保托管的应用程序自动启动。
    2. 集群模式
        * 利用nodejs的cluster模块，pm2可以根据服务器CPU核心数自动创建多个工作进程，实现负载均衡。这些子进程共享同一端口，通过内部通信机制分配客户端请求，从而充分利用多核处理器的性能，提高应用的并发处理能力和整体性能。
    3. 日志管理
        * pm2集成了日志rotate功能，自动管理应用程序的输出日志，日志文件保存再~/.pm2/logs/目录下，可以根据需要配置日志级别，分割规则以及日志传输
    4. 命令行界面（CLI）
        * 提供一系列便捷的命令行接口，如pm2 start\pm2 list\pm2 logs\pm2 restart\pm2 stop等，用于启动、停止、列出进程、查看日志、以及执行重启操作。
    5. 配置文件支持
        * 支持使用JSON格式的配置文件（ecosystem.config.js）来定义和管理多个应用程序及其相关配置，便于批量操作和复杂部署场景
    6. 远程控制与监控
        * pm2可以通过内置的pm2 web命令开启一个web控制台，或者与keymetrics这样的远程监控平台集成，实现远程管理、监控应用状态、接收报警等功能；

* pm2根据以下情况触发服务器重启：
    1. 应用程序崩溃或非正常退出
        * 如果托管的nodejs应用因内部错误，未捕获的异常或其他原因意外终止，pm2会检测到进程状态变化，并立即按照预设的重启策略重新启动该进程。
    2. 用户主动操作：使用命令行工具手动触发重启
    3. 文件更改：当启用文件监控（如pm2 start app_name --watch）时，一旦指定的源代码或依赖文件发生变动，pm2会自动重启应用，以便改动生效。这对于开发环境的快速迭代尤为有用
    4. 定时任务：可以配置pm2按照预设的时间计划自动重启应用，例如定期进行维护性重启或在低峰时段更新版本；
    5. 资源阈值：pm2可以设置基于内存使用量的阈值。当应用程序占用的内存超过设定值时，pm2会判断为资源异常，并执行重启操作，防止因内存泄漏等问题导致的系统稳定性下降。

# 怎么禁止表单记住密码自动填充？
1. 使用autocomplette=“off/new-password”，以指示浏览器不应自动填充该字段。但是浏览器的支持性并不完全；
2. 添加隐藏的占位输入：针对不完全支持autocomplete属性的浏览器，可以添加一个隐藏的，带有正确name属性的密码输入占位符，让浏览器自动将填充的信息填入这个隐藏的输入而非实际的密码输入框；
3. 使用随机或伪随机的name和id属性：为密码输入框生成每次页面加载时不同的name和id属性，可以防止浏览器基于固定标识匹配已保存的凭据。
4. 用户教育与浏览器指导设置：告知用户如何再各自的浏览器中设置关闭自动填充功能。
5. 结论：综合运用以上方法可以有效减少或消除表单记住密码并自动填充的情况。请注意，由于浏览器行为可能随版本更新而改变，应定期检查并更新所采用的技术以适应最新的浏览器特性。

# 通过什么做到并发请求？
* 并发请求是指再同一时间段内同时发起多个网络请求，以实现更快的数据获取和处理速度，减少总体响应时间。以下是实现并发请求的一些常见技术和方法：
    1. 异步编程
        * 使用回调函数：在js等支持异步编程的环境，使用回调发起并发请求，每一个请求作为一个独立的任务，当请求完成时调用相应的回调函数处理响应数据，而不阻塞主线程。
        * Promise：使用Promise对象可以优雅地组织异步操作，通过then方法链式处理多个并发请求的结果。结合Promise.all方法，可以等待所有并发完成后进行下一步操作。
        * async/await：基于promise的异步变成语法糖，使得异步代码看起来像同步代码。
    2. 库与框架支持
        * axios：支持了对并发请求的内置支持。（废弃，推荐使用Promise）
        * Fetch API：浏览器原生的fetch支持并发请求。创建多个fetch实例并使用promise.all来等待所有请求完成。
        * 其他HTTP客户端库：如py的requests-future、java的AsyncHttpClient等，提供了并发请求的功能；
    3. 多线程或多进程
        * java多线程
        * Golang Goroutines
        * PHP多进程
    4. 事件驱动与非阻塞I/O
        * Nodejs
        * 异步I/P库
    5. 特定语言或框架的并发特性
        * Erlang/Elixir
        * Rust
    6. 操作系统级别的网络并发
        * Epoll、Kqueue、IOCP

# 前后端通信使用什么方案？

1. HTTP Restful API
    * 基于HTTP协议：最常见的前后端通信方式
    * 状态码与响应体：后端通过状态码标识请求状态，响应体表示请求结果；
    * 跨域支持：若前后端部署在不同域名下，需要配置CORS以允许跨域请求。
2. WebSocket
    * 双向实时通信：允许客户端和服务器端建立持久连接，实现实时数据推送。
    * 事件驱动：前后端通过监听发送和监听的消息事件进行通信；
3. Server-Sent Events（SSE）
    * 单向数据流：SSE是轻量级的浏览器与服务期间单向通信技术。前端创建EventSource对象连接到服务器的SSE EndPoint，服务器以UTF-8编码的文本数据流推送更新，前端监听指定事件接收数据。
    * 简单易用：适用于服务器端主动向客户端推送少量数据。
4. Ajax
    * 异步请求：ajax利用js在不刷新页面的情况下，通过XHR或fetch api向服务器发送异步请求，获取数据并局部更新网页内容。
    * 无刷新更新：适用于动态加载内容、表单验证、分页加载、数据过滤等场景，提供流畅的用户体验；
5. GraphQL
    * 查询语言与规范：GraphQL是一种用户API的查询语言，以及一种满足该查询的运行时。前端通过定义一次性的、灵活的查询来精确获取所需数据，后端返回匹配查询结构的json响应
    * 高效数据获取：减少冗余数据传输，支持层级深，复杂关系的查询，尤其适合数据驱动型应用；
6. gPRC
    * 二进制协议：gPRC基于HTTP/2协议，适用Protocol Buffer作为接口描述语言和序列化协议，提供高性能、跨语言的RPC服务
    * 强类型、高效：主要用于微服务架构、云原生环境，适合对性能要求较高、需要跨语言互操作的场景。
7. JSON-RPC
    * 轻量级RPC：一种简单、轻量级的远程过程调用规范，适用json作为数据交换格式。前端和后端通过约定好的方法名和参数结构进行请求和响应。
    * 跨语言、跨平台：适用于需要在多种语言和平台上实现简单远程调用的场景；
8. Webhooks
    * 被动通知：一种反向API调用机制，后端在特定事件发生时，主动向前端提供的URL发送post请求，传递相关数据。
    * 事件驱动：适用于订阅服务、支付通知、社交网络更新提醒等场景，后端触发事件，前端被动接收。
9. 轻量级封装库与框架
    * 高层封装：存在一些库或框架对HTTP请求进行高层封装，简化了前后端通信的代码复杂度，尤其适用于微应用等场景。

# 如果有1000个dom，需要更新其中的100dom，如何操作才能减少dom操作？
1. 批量更新
    * 一次性替换innerHTML：如果更新内容相对独立，可以现在js中构建一个新的html字符串，包含所有需要更新的100个dom元素的新内容，然后一次性替换目标容器的innerHTML，这将触发一次dom重回和回流，而非100次；
    * 使用documentFragment：对于复杂更新，可以使用DF来创建一个临时的、不在DOM树中的节点集合。然后在这个片段上完成所有DOM操作，完成后一次性插入到目标容器中，减少对dom直接操作。
2. diff算法和虚拟DOM
    * 使用库：提供基于虚拟DOM的高效更新机制。
    * 手动实现diff算法：可以自行实现或引入轻量级的diff算法库。
3. css类切换与属性操作
    * 使用css类：尽可能通过css类来改变元素样式而不是直接操作样式属性。类切换通常比直接修改样式属性更高效，且易于维护。
    * 属性操作：对于非样式属性的更新，使用setAttribute、removeAttribute或dataset属性进行批量或一次性操作，而非直接操作DOM元素的属性。
4. 事件委托：减少事件监听器数量：如果涉及事件监听器的添加或移除、考虑使用事件委托。通过将事件添加到父元素上，通过事件冒泡处理所有子元素的相关事件，避免为每个需要更新的元素单独绑定监听。
5. requestAnimationFrame
    * 优化重绘机制：如果更新过程设计到多次DOM操作，将它们封装在一个requestAnimationFrame回调函数中。这样浏览器会在下一次重绘前一次性应用所有更新，避免在每一帧中都进行不必要的重绘。

# JSON.stringfiy的一些特性？和遍历相比，哪个性能更高？
* JSON.stringify()：是一个js中用于将js对象或数组序列化为一个JSON字符串的方法。具有以下特性：
    1. 基础类型处理：布尔值、数字、字符串的包装对象在序列化过程中会自动转换为对应的原始值。
    2. 递归序列化：能够处理嵌套的对象和数组结构，将复杂的数据结构完整转化为json字符串
    3. 属性过滤：可以提供第二个参数，对对象的属性进行筛选或转换。该函数接收两个参数：键和值，返回值将作为序列化后的对应值，若返回undefined，属性被省略；
    4. 函数和不可枚举属性值的处理：函数以及Symbol类型的属性不会被序列化，未显示声明（如使用Object.defineProperty）且不可枚举的属性默认会被忽略；
    5. undefined和null的处理：单独转换undefined或null时，JSON.stringify返回undefined或null字符串。但在对象中，undefined属性会被省略，而null值会被保留；
    6. 自定义缩进：可以提供第三个参数space来控制输出的json字符串的缩进和空格。它可以是字符串或数组，也可以未null或未提供以得到紧凑格式输出。
* 性能和遍历的比较：
    1. JSON.stringify性能通常优于手动遍历：JSON.stringify经过优化的标准库函数，其内部实现通常利用了更高效的数据结构和算法来处理对象和数组的遍历、递归和字符串化。此外，由于是原生实现，其性能优于纯js编写的自定义序列化逻辑。
    2. 特殊情况下的性能差异：如果仅需对序列化对象的部分属性、对值进行复杂转换或处理非常规数据结构时，手动遍历可能更具备灵活性，但此时性能优势可能不明显。甚至可能因为实现不当导致性能劣于JSON.stringify。
    3. 性能瓶颈分析：关注性能，应先进行基准测试以确定实际应用中的瓶颈。在大多数常规场景下，JSON.stringify的性能通常不是问题，如果确实遇到性能瓶颈，应检查是否有大量的，不必要的序列化操作，或者是否存在大数据量的序列化需求。这时候可能需要考虑优化数据结构，减少序列化次数或使用更高效的数据交换格式。

# 什么是运营商劫持，有什么预防措施？
* 运营商劫持：也称为网络劫持或流量劫持，是指互联网服务提供商或中间节点网络在未经用户许可的情况下，擅自干预用户的网络通信过程，对用户的访问网站、应用程序或数据传输进行篡改、拦截或重定向的行为。这种劫持通常发生在数据从用户设备传输到目的地服务器，或从服务器返回至用户设备的过程中。
* 运营商劫持主要有以下几种表现形式：
    1. DNS劫持：当用户尝试访问某个网站时，ISP篡改正常的DNS解析过程，将目标网站的域名解析到非官方的IP地址上。这可能导致用户被重定向到错误的网站、广告页面，甚至是含有恶意软件的站点。
    2. HTTP内容注入：在HTTP明文传输下，ISP在用户请求的响应数据中插入额外的广告、追踪脚本或其他内容，影响用户界面和体验，同时带来安全风险。
    3. 透明代理：ISP设置透明代理服务器，对用户的网络流量进行中间人攻击、不仅能够查看和修改用户数据，还可以强制重定向到特定页面或插入广告。
    4. SSL/TLS解密：在某些国家和地区，isp可能会通过安装根整数的方式，对用户的加密流量进行解密、监控或篡改，严重侵犯用户隐私；
* 防护措施
    1. 使用可信的DNS服务器：更改设备或网络设置，使用第三方可靠的DNS服务器，以减少DNS劫持的风险，这些服务器通常具有更高的安全性和抗干扰能力；
    2. 启用HTTPS：确保访问的网站和服务均支持HTTPS，并始终使用HTTPS访问。
    3. HSTP（HTTP Strict Transport Security）：启用HSTP策略，指示浏览器始终通过HTTPS与服务器通信，即使用户在地址栏输入的是http连接，浏览器自动升级为https。有助于防止中间人降级攻击和部分DNS劫持。
    4. DNSSEC（DNS Security Extension）：对于DNS服务提供商，启用DNSSEC可以为DNS数据提供端到端的认证，确保DNS查询结果未被篡改。用户应选择支持DNSSEC解析的DNS服务器，以增加对DNS劫持的抗压力；
    5. 使用防劫持代码：对于开发者，可以集成防运营商劫持的代码或服务，监测并对抗内容注入行为。这些代码通常能识别异常的网络请求和响应，组织未经授权的第三方内容加载。
    6. 记录日志并监测异常：对于网络流量和服务器日志进行定期审查，及时发现异常访问模式或非预期的流量来源，有助于识别潜在的劫持行为。
    7. 投诉和法律途径

# npm和pnpm有什么区别？
1. 设计理念和性能优化
    * npm：最早的js包管理器，随nodejs分发，为nodejs社区提供了一种标准化的方式来发布、分享和管理模块。npm采用递归非确定性树形结构安装依赖，这意味着同一依赖的不同版本会被分别安装到项目的node_modules中，可能导致磁盘空间占用较大，尤其是对于大型项目或依赖层级较深的项目；
    * pnpm：pnpm专注于性能优化和磁盘空间利用率，它引入了内容寻址存储的概念，通过全局缓存的共享存储，当多个项目依赖相同的包时，这些包只在全局缓存中存储一份，而在项目的node_modules中创建指向缓存中包的链接，大大减少了磁盘占用，此外npm在安装依赖时采用了并行处理，进一步提升安装速度。
2. 存储机制与依赖管理
    * npm：在每个项目中创建完整的node_modules目录结构，其中包含了项目直接依赖及其所有子依赖的具体版本。这种模式确保了每个项目环境的隔离性，但也可能导致磁盘空间浪费，尤其是在多项目环境下重复安装相同依赖。
    * pnpm：采用精简的node_modules结构，直接依赖依然像npm那样存储在项目的node_modules中，但间接依赖仅保留一个指向全局缓存实际包文件的链接。这种“单包存储，多处链接“的方式极大节省了磁盘空间，并且由于链接的使用，更新依赖时只需要更新缓存中的包即可，提高更新效率；
3. 依赖树处理和版本冲突解决
    * npm：处理依赖时，遵循”最近依赖“原则，即项目中离依赖声明最近的版本将本优先使用。在解决版本冲突时，npm会尝试通过自动选择满足依赖关系的最高版本来解决。如果出现无法自动解决的冲突，npm提示用户手动干预。
    * pnpm：遵循”最近依赖“原则。由于其独特的链接机制，版本冲突会在全局缓存层面上更容易被识别和处理。pnpm在安装过程中会尝试解决版本冲突，并在必要时提示用户。版本选择策略与npm类似，倾向于选择最高版本以满足依赖关系；
4. 生态系统兼容性
    * npm：作为nodejs的默认包管理器，npm拥有最广泛的生态支持。几乎所有的nodejs项目和开发者都熟悉npm的工作方式，绝大多数开源项目也直接使用npm进行发布和管理，npm命令和工作流已被广泛接收和理解。
    * pnpm：pnpm在设计理念和性能上优化创新，但在生态系统兼容性上可能稍逊npm。大多数npm命令和功能在pnpm中有对应实现，但对于一些特定的npm插件或不常见的用法，可能需要额外适配或寻找等效的pnpm解决方案。不过，对于大多数常规项目，pnpm能够很好替代npm工作。

