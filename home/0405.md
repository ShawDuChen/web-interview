
# HTTP/2.0的多路复用和HTTP/1.1的长连接有什么区别？

* HTTP/2的多路复用和HTTP/1.1的长连接都是为了提高网络通信效率和性能而设计的机制，但它们在实现方式和效果上有显著区别

* HTTP/1.1长连接
    1. 特点和机制
        * 复用TCP连接：1.1引入了默认启用的长连接，允许通过一个TCP连接发送多个HTTP请求，在1.0中，每完成一次请求-相应就需要关闭连接。而1.1中，客户端和服务端可以在完成一次请求后保持继续连接，以供后续请求重用；
        * 串行处理：尽管长连接允许多个请求复用同一个TCP连接，但这些请求仍是按序发送和处理的，也就是说，即使多个请求同时发出，服务器在接收到第一个请求的相应之前，不会开始处理下一个请求。这种机制被称为”对头阻塞“；
        3. 管道化：为了缓解队头阻塞，1.1提供了可选的管道化功能，允许客户端在接收到前一个请求的相应之前就发送后续请求，然而，由于服务器仍然需要按序响应，如果前面的请求处理较慢，后面的请求仍会阻塞，而且管道化容易受到中间设备（如代理服务器）不支持或错误配置的影响，实践应用有限；
    2. 优点：
        1. 减少TCP连接建立的开销；
        2. 减少连接关闭时的延迟；
    3. 缺点：
        1. 队头阻塞：一个请求的处理速度慢会导致后续请求等待，无法充分利用带宽；
        2. 公平性与拥塞控制：由于所有请求共享一个连接，一个大文件下载可能会影响其他请求的响应速度；
        3. 头部阻塞：即使请求体可以并行传输，但头部仍然需要按序发送和解析；
* HTTP/2.0多路复用
    1. 特点和机制
        * 二进制分帧：HTTP/2将请求和响应分解为独立的帧，每个帧都有自己的标识符和流编号。这样，不同的请求及其响应可以在同一个TCP连接上交错发送，而无需等待前一个请求完全处理完毕；
        * 流：每个请求-响应对在逻辑上形成一个独立的流，流之间相互独立，可以并行、乱序发送和接收帧。每个流都有优先级、允许客户端和服务器根据业务需求调整资源分配；
        * 流控制：HTTP/2实现了流级别的流量控制，允许双方动态调整发送速率，以避免拥塞和数据丢失；
    2. 优点
        * 彻底消除队头阻塞：由于请求和响应以帧为单位交错发送，不再受单一请求处理速度的影响，真正实现了并发请求；
        * 优先级与依赖：每个流可以设置优先级和依赖关系，允许更高效地利用带宽，优先处理重要或用户感知明显的资源；
        * 头部压缩：HTTP/2引入了HPACK压缩算法，减少了头部信息在网路中的传输量；
    3. 缺点
        * 实现复杂性：二进制分帧和多路复用增加了协议的复杂性，对服务器和客户端的实现要求更高；
        * 兼容性问题：部分中间设备（如代理服务器或防火墙）可能不支持HTTP/2，需要升级或配置；
* 总结
    * HTTP/1.1的长连接通过复用单个连接减少连接开销，但其请求处理是串行的，容易头部阻塞；
    * HTTP/2的多路复用通过二进制分帧和多流机制彻底解决队头阻塞问题，实现了真正的并发请求，并提供了更精细的流量控制和头部压缩，大幅度提升了网络通信效率；

# 开发中的几种常用Content-Type
1. application/x-www-form-urlencoded
    * 用途：这是浏览器原生表单提交数据时默认使用的编码方式。当用户通过HTML表单提交数据（GET/POST）且没有显式设置enctype属性时，数据将以这种格式发送；
    * 结构：键值对以&分割，键与值之间以=分隔，且所有字符都经过URL编码；
    * 适用场景：简单文本数据的提交，不适用于包含非ASCII字符或二进制数据的场景；
2. multipart/form-data
    * 用途：用于上传文件或包含二进制数据的表单提交。当表单中包含<input type="file" />元素时，必须将enctype属性设置为multipart/form-data。
    * 结构：数据被分割为多个部分，每个部分都有自己的Content-Disposition和Content-Type头部，以及相应的数据体。各部分之间以特定的分隔符分隔。这种格式允许混合文本字段和文件数据一起发送；
    * 使用场景：文件上传，包含非ASCII字符或二进制数据的表单提交，如图片、文档、音频、视频等；
3. application/json
    * 用途：用于发送或接收的数据是JSON格式编码的。JSON是一种轻量级的数据提交格式，易于人阅读和机器解析；
    * 结构：数据以JSON对象的形式表示，包含键值对，键为字符串，值可以是各种JSON支持的数据类型（字符串，数值，布尔值，对象等）；
    * 适用场景：RESTful API中的大多数数据交换，尤其是需要传输结构化数据或复杂对象时，JSON被广泛支持，且易于解析和生成，称为web开发的标准数据格式之一；
4. text/plain
    * 用途：表示发送或接收的数据是纯文本，没有任何特殊格式或编码；
    * 结构：直接以人类可读的文本形式发送数据，不含任何特殊字符串或转义；
    * 适用场景：简单文本消息的传输，如日志输出、调试信息、简单的命令行交互等。不适用于需要结构化的数据或二进制内容；
5. application/xml或text/xml
    * 用途：表示发送或接收的数据是XML格式编码的。XML是一种标记语言，用于存储和传输结构化数据；
    * 结构：数据以xml文档的形式表示，包含元素、属性和文本节点，遵循严格的语法规则；
    * 适用场景：虽然JSON在现代化web开发中更为普遍，但在某些特定的领域或需要严格数据验证的情况下，XML仍有应用；
6. application/octet-stream
    * 用途：表示发送或接收的数据是未经过解释的原始二进制数据，这是一种通用类型，用于传输任意类型的二进制文件；
    * 结构：数据以字节流的形式传输，不包含任何特定的结构或字符编码信息；
    * 适用场景：下载或上传未知类型的二进制文件，或者需要在传输过程中不对数据进行任何解析或解释的场景；
7. 除以上类型，还有text/html, image/jpeg, video/mp4等。分别对应不同的媒体类型或数据格式。选择合适的content-type非常重要，因为有助于客户端和服务器正确地解析和处理数据。

# 微信小程序的生命周期
1. 全局生命周期（app.js中的App()构造函数中
    * onLaunch：小程序启动后，全局的App实例完成初始化并进入运行状态时触发。这个节点可以进行全局数据初始化，登录状态检查，网络请求预处理等工作；
2. 页面生命周期（单个页面的js文件中的Page()构造器中）
    * onLoad：页面加载时触发，此时页面对应的setData()方法可以被调用，用于设置初始化数据，通常在此处获取服务器端数据或从其他地方加载页面所需要的数据；
    * onShow：页面显示时触发，这不仅发生在首次打开页面，也包括从其他页面切回、从后台恢复到台前等情况。可用于更新页面状态、处理未完成的业务逻辑等；
    * onReady：页面初次渲染完成时触发，此时所有布局和样式均已计算完毕，整个页面可与用户进行交互，可以在这里执行界面元素的测量、动画操作或其他需要确保DOM已渲染完成的任务；
    * onHide：页面从前台切入后台时触发，当用户离开当前页面（如点击返回按钮、跳转到其他页面或关闭小程序）但未完全销毁页面时，会执行此函数，用于释放资源，暂停计时器或音乐播放等操作；
    * onUnload：页面销毁时触发，在用户彻底关闭页面或小程序退出时，页面实例将被销毁，此时执行清理工作，释放页面持有的资源；
3. 其他可能的声明周期函数
    * onPullDownRefresh：用户下拉刷新时触发。在页面中实现数据刷新逻辑。
    * onReachBottom：页面上拉触底时触发，用于实现列表滚动到底部加载更多数据的功能；
    * onShareAppMessage：用户点击右上角的分享按钮时触发，定义页面的转发交互及自定义分享内容；
    * onPageScroll：页面滚动过程中持续触发，用于监听用户滚动行为，获取滚动位置信息；
    * onResize：屏幕尺寸发生变化时触发，适配不同屏幕尺寸或横竖屏切换时的布局调整；

# uniapp的生命周期对应微信小程序的生命周期
1. 全局声明周期适配：
    * uniapp：使用vue的main.js作为入口，通常创建一个vue实例，并在其中挂载全局配置和插件。尽管uniapp提供了特有的全局配置和生命周期，但在跨平台开发时，vue的全局生命周期并不直接对应微信小程序的全局生命周期；
    * 微信小程序：在app.js中定义一个App构造器，其中包含onLaunch、onShow、onHide等，这些函数需要从Uniapp的全局配置或vue实例的生命周期钩子中迁移或重写，确保在小程序启动、显式、隐藏等关键时刻执行相应的业务逻辑；
2. 页面生命周期适配：
    * uniapp：页面遵循vue的组件化思想，使用export default {} 的形式定义页面对象，其中包括data、methods、computed、watch等属性以及beforeCreate、created、mounted、destroyed等生命周期钩子函数；
    * 微信小程序：在转为微信小程序时，uniapp自动生成于小程序兼容的页面结构，包括json、wxml、wxss和js文件，在js文件中，使用Page({})的形式定义页面对象，其中包括data、methodss等属性以及onLoad、onShow、onReady等；
    * 这意味需要将uniapp页面的vue生命周期钩子映射到相应的小程序生命周期函数上；例如：
        * created 或 beforeMount -> onLoad（初始化数据）
        * mounted -> onReady（界面渲染完成，可以进行交互）
        * beforeDestroy 或 destroyed -> onUnload（页面销毁）
    * 对于其他vue的声明周期钩子，如updated、activated、deactivated等，可能需要结合小程序的特定场景（如页面栈管理、路由切换等）以及uniapp提供的跨平台API（onBackPress、onNavigationBarButtonTap等）来模拟类似功能；
3. 事件处理和数据绑定：
    * uniapp：在vue中，事件处理通常使用v-model或@语法进行绑定，数据更新则通过v-bind或：语法进行动态绑定；
    * 微信小程序：在生成的小程序代码中，事件处理和数据绑定遵循小程序自身的WXML语法，如bindtap、catchtap用于绑定事件，data-前缀的属性用于数据传递；
4. 将uniapp转为小程序，主要关注点在于全局和页面的生命周期函数的迁移于适配；由于uniapp已经封装了跨平台的编译机制，大部分代码可以直接复用，确保关键的业务逻辑在正确的生命周期阶段得到执行。对于Uniapp提供的跨平台API和组件，通常能够无缝地在小程序环境中工作，无需额外调整，如果使用第三方库或组件，需要确保它针对小程序平台已经进行了适配或提供了相应的替代方案；

# unaipp的生命周期
* Uniapp的生命周期分为三个主要部分：应用生命周期、页面生命周期和组件生命周期；这些组件生命周期涵盖了应用程序从启动到关闭、页面从创建到销毁以及组件从初始化到卸载的过程；
1. 应用生命周期：适用于整个uniapp应用程序，通常在App.vue文件中定义和处理，这些生命周期函数只在App级别有效，无法在其他页面或组件中监听；
    1. onLaunch：应用程序启动时触发，通常仅在应用程序第一次启动时触发，在此阶段可以进行全局数据的初始化，用户登录状态检查，缓存数据读取，注册全局事件监听器等操作；
    2. onShow：应用程序进入前台（从后台切入前台）时触发，每次打开页面或从其他应用切回时都会触发，可以在此处更新应用状态、刷新数据或进行与应用展示相关的操作；
    3. onHide：应用程序进入后台时触发，在此阶段可以释放一些不需要再后台进行的资源、暂停定时任务或保存当前状态；
    3. onError：应用程序发生错误时触发，可以用来捕获和处理全局范围内的未捕获的js异常，以提高应用的健壮性和用户体验；
    4. onUniNViewMessage：监听来自nvue（原生视图）页面的消息，nvue页面使用原生渲染引擎，与普通页面存在通信需求时，可以通过此生命周期函数接收来自nvue的消息；
2. 页面生命周期：适用于每一个Uniapp中每一个单独的页面，通常在每个页面的*.vue文件中定义和处理；
    1. onLoad：页面加载时触发，此时页面对应的data已经初始化，可以在此处获取页面参数，请求远程数据，执行页面初始化逻辑等；
    2. onReady：页面初次渲染完成时触发，此时所有视图层已经渲染完成，页面DOM已经构建完成，可以进行DOM操作，引入第三方库，启动页面动画等；
    3. onShow/onHide：页面显示/隐藏时触发；
    4. onUnload：页面销毁时触发；
    5. 其他：
        * onPullDownRefresh：下拉刷新触发；
        * onReachBottom：页面上拉触底触发；
        * onShareAppMessage：分享按钮时触发；
        * onPageScroll：页面滚动时触发；
        * onResize：页面尺寸变化时触发；
3. 组件生命周期：和vue的组件生命周期一致
    * beforeCreate
    * created
    * beforeMount
    * mounted
    * beforeUpdate
    * updated
    * beforeUnmount
    * unmounted

# 微信小程序开发中的注意顶
1. 遵循微信小程序开发规范
    1. 遵循官方开发文档和设计指南，确保小程序在功能、界面、交互等符合要求
    2. 小程序尺寸单位（rpx）和布局规则，适配不同屏幕尺寸和分辨率
    3. 确保使用api、组件、权限等符合微信小程序的限制和规定，避免使用被禁止或不推荐的功能；
2. 性能优化
    1. 资源优化：压缩图片、合并css和js文件，使用cdn加速静态资源、较少网络请求和资源大小；
    2. 代码优化：良好的编程实践，避免冗余代码，减少嵌套，合理使用异步编程，提供代码执行效率；
    3. 数据管理：合理利用小程序提供的数据缓存机制，减少不必要的数据请求，提高数据加载速度；
    4. 页面渲染：合理使用组件懒加载、页面预加载、骨架屏；
3. 用户体验
    1. UI设计：保持界面简洁、清晰、符合设计风格，确保在多种尺寸视觉效果良好；
    2. 交互设计：提供直观、易于理解的用户交互，遵循移动端操作规范；
    3. 加载反馈：提供数据加载、网络请求等的加载提示等；
    4. 离线体验：考虑网络不稳定或无网络下的用户体验；
4. 功能实现和权限申请
    1. 功能集成：支付、登录、分享、客服、地理位置等服务，使用正确的API的SDK
    2. 权限申请：根据功能需求申请必要的用户授权，如用户信息、地理位置、蓝牙等，并告知使用目的，遵循隐私规范；
5. 审核与发布
    1. 内容合规：确保小程序内容合法、健康、不含违法内容；
    2. 提交审核：按照小程序规范提交审核，提供说明文档和测试账号等；
    3. 应对审核反馈：及时查看审核结果，针对未通过原因进行修正，并重新提交审核；
6. 测试和调试
    1. 多环境测试：在不同设备、操作系统版本、网络环境下进行全面测试，确保兼容性和稳定性；
    2. 使用开发者功能：熟练使用微信开发者工具进行实时预览、调试、性能分析、模拟器测试、快速定位解决问题；
    3. 自动化测试：有条件情况下，采用自动化测试工具对小程序进行回归测试、性能测试等；
7. 持续维护和更新
    1. 版本管理：版本控制，定期发布新版本，修复已知问题，添加新功能，以满足用户需求和市场变化；
    2. 数据分析：利用小程序提供的数据分析工具，监控用户行为、活跃度、转化率等指标；
    3. 用户反馈：建立有效的用户反馈机制，及时收集和处理用户意见和建议，提升满意度；

