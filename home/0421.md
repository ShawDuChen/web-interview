# JS为什么要区分微任务和宏任务？
* js是单线程语言，它通过事件循环机制来处理异步编程。为了更好协调和调度异步操作，js引入和宏任务和微任务。区分两种任务类型对异步控制流的执行顺序和浏览器环境下的渲染性能有着重要意义。
    1. 精细化的异步控制
        * 宏任务待变一些耗时较长或特定事件相关的异步操作，如setTimeout、用户交互事件、网络请求、IO操作的后果。这些任务之间相对独立，执行时机依赖于预定的时间间隔或外部事件的发生。
        * 微任务则包括Promise回调、MutationObserver回调等，他们通常涉及更短小、更紧急的操作，往往需要在当前执行上下文结束后尽快得到处理，例如更新数据状态、响应promise链的异步结果。
        * 区分宏任务、微任务能够使得js对不同优先级和性质的异步操作进行精细化管理，确保高优先级或依赖性强的任务能够在下一个事件循环迭代开始前及时完成；
    2. 保证执行顺序的可预测性
        * 主线程执行一个宏任务；
        * 在执行过程遇到微任务添加到微任务队列’
        * 当宏任务执行完毕，立即清空并执行所有入队的微任务；
        * 渲染进程此时有机会进行更新；
        * 从宏任务队列取出下一个宏任务，重复上述过程；
        * 这种区分确保了微任务总是在当前宏任务结束后的下一个事件循环迭代开始之前执行，从而为开发者提供了清晰的异步控制流顺序。有助于编写可预测、易于调试的代码，特别是在处理复杂的异步逻辑时。
    3. 优化渲染性能
        * 微任务会阻塞渲染进程，意味着在所有微任务执行完毕之前，浏览器无法进行页面重绘或回流。将某些操作安排为微任务，可以在不影响用户交互的情况下尽快完成必要的状态变更，然后统一进行渲染更新，避免不必要的之间渲染状态，提升页面性能；
        * 宏任务不会阻塞渲染，它们会在下一个事件循环迭代时机执行，给浏览器留出机会先处理其他可能影响用户体验的操作，如响应用户交互或执行动画帧。
    4. 跨平台一致性
        * 在nodejs环境中，虽然事件玄幻的具体实现与浏览器有所不同，但同样存在宏任务和微任务的概念。区分这两类任务有助于实现跨平台的异步编程模型一致性，使开发者能够编写既适用浏览器也适用nodejs的异步代码；

# app中常提到的webview指什么？
* 指的是移动端应用程序帐内嵌的一种浏览器组件。它允许开发者在原生应用程序的上下文中展示和交互网页内容，无需跳转到外部系统浏览器。
    1. 浏览器内核封装
        * webview实质上是对操作系统底层浏览器内核的一种封装。它提供了api供开发者在原生代码中创建、配置和操控这个嵌入式浏览器视图；
    2. 跨平台支持
        * Android：AndroidSDK提供了android.webkit.WebView类，开发者可以在Android布局XML文件中声明webview组件，或者在java/kotlin代码中动态创建。通过调用其方法，可以加载指定URL的网页，执行js代码，以及设置各种浏览行为和安全策略；
        * iOS：在iOS中，WKWebView或较旧的UIWebView类实现了类似功能。WKWebView基于webkit框架，提供了更好的性能，安全性以及与js的交互能力；
    3. 混合应用开发
        * webview是实现混合应用的技术之一。混合应用结合了原生应用的特性与web技术的优点。开发者可以利用webview加载本地html/css/js资源或远程网页，构建部分或全部应用界面。通过js与原生代码之间的桥梁，实现双向通信，让web内容能够调用原生功能，反之亦然；
    4. 自定义功能与控制：webview提供了丰富的接口供开发者自定义其行为；
        * WebChromeClient 或 WKUIDelegate：用于定制浏览器的用户界面元素，如处理地址栏、标题、加载进度、弹出窗口；
        * WebViewClient或WKNavigationDelegate：控制网页内容的加载过程，如错误处理、页面开始/完成加载通知、请求重定向；
        * 设置属性和权限：可以调整webview的诸多设置，如开启/禁用js、缓存策略、用户代码字符串、混合内容模式等。调试，设置适当的安全策略以防止恶意攻击；
    5. 性能和限制：虽然webview简化了原生应用中集成网页内容的过程，但也需要注意其性能特点和潜在限制：
        * 性能：相比于系统浏览器、webview可能存在渲染速度、js执行效率方面的差异，尤其是在处理复杂网页或大量交互时。不过，现代webview已经显著提升了性能表现；
        * 兼容性：由于webview使用的是特点版本的浏览器内核，其对web标准和api的支持可能与最新桌面或移动浏览器有所出入，需要关注目标设备上的实际表现；
        * 资源隔离：webview的网页通常运行在与主应用不同的沙箱环境中，内存、cpu等资源使用需要妥善管理，以防过度消耗导致应用卡顿或崩溃。

# useEffect和useLayoutEffect有什么区别？
1. 执行时机
    * useEffect异步执行：useEffect回调函数在所有DOM变化完成后，浏览器完成布局和绘制之后（即下一个事件循环的”渲染“阶段）执行。这意味着当useEffect中的代码运行时，用户已经能够看到更新后的界面；
    * useLayoutEffect同步执行：useLayoutEffect回调函数在所有DOM变化之后、浏览器进行布局和绘制之前（即当前事件循环的”提交“阶段）立即执行。在这个执行阶段执行的代码会阻塞浏览器更新屏幕，直到useLayoutEffect回调完成；
2. 应用场景
    * useEffect：非视觉相关副作用，适合处理与视觉无关的副作用，如订阅、解订阅外部数据源、设置定时器、发生AJAX请求、更新浏览器历史记录等；
    * useLayoutEffect：视觉效果相关副作用，适用于那些需要在DOM更后立即执行、且会影响布局或视觉外观的操作。例如，读取DOM尺寸、调整滚动位置、依赖于DOM布局的计算、立即修正布局问题等。
3. 对渲染性能的影响
    * useEffect：有利于性能，由于异步执行，不会阻塞浏览器进行下一帧的绘制，因此通常不会导致额外的帧率下降或卡顿；
    * useLayoutEffect：可能影响性能。同步执行可能导致额外的重排会重绘，如果useLayoutEffect内部执行了耗时操作，可能会阻塞浏览器更新屏幕，导致用户体验下降。
4. 何时选择使用
    * 默认选择useEffect：除非有明确的布局相关需求，通常应优先考虑使用useEffect，它能确保副作用在不影响渲染性能的前提下得到处理；
    * 必须时使用useLayoutEffect：当某个副作用必须在执行浏览器完成DOM更新并渲染给用户看到之前执行，才选择useLayoutEffect；
5. 模拟useEffect的行为
    * useLayoutEffect可以通过包裹在一个requestAnimationFrame回调中来模拟useEffect的异步行为；

# 为什么不建议使用数组下标index来作为key？
1. 性能开销
    * 虚拟DOM diff算法：react和vue等框架使用虚拟DOM技术，通过对比新旧虚拟DOM树来确定实际DOM需要进行哪些最小化更新。在对比列表元素时，key作为唯一标识符帮助框架识别元素的身份，而非仅依赖元素的位置。若使用index作为key，当列表元素顺序发生变化时，框架难以准确判断元素的身份，导致不必要的DOM重排和重绘，产生较大的性能开销；
2. 不必要的子组件重新渲染
    * 子组件状态丢失：当列表元素顺序改变时，使用index作为key可能导致子组件实例被错误复用或销毁。原本位于一个位置的子组件可能被移动到另一个位置，但由于key相同，子组件的状态可能无法正确保留，造成用户界面的不连贯或数据错误。
    * 无状态组件的浪费：对于无状态组件的纯展示组件，即使内容不变，也可能因为index作为key导致它们被误认为是新组件而重新渲染，增加了不必要的计算负担；
3. 可能导致内存泄漏
    * 未被清理的引用：当列表元素被移除时，若使用index作为key，对应的组件实例可能被正确地从内存中释放，因为它们的key仍存在于新的列表中。这可能导致内存泄漏，特别是在大型列表中反复添加、删除元素的情况下。
4. 违反”稳定性“原则
    * 稳定的keys提升diff效率：理想的key应该是稳定的、唯一的，即使元素位置改变，其key也应该保持不变。这样可以帮助框架更高效地识别夫复用现有DOM元素，减少不必要的DOM操作。而index作为key显然不满足这一要求，每当元素位置变动时，其key也随之变化，降低了diff算法的效率；
5. 不利于调试
    * 难以追踪问题：当列表渲染出现问题时，使用index作为key使得错误信息难以定位到具体的业务数据项。由于key只反映了元素在列表中的位置，而不体现其业务含义，调试时很难快速定位到对应的数据源，增加了排查问题的难度。
6. 不合符最佳实践
    * 官方文档与社区共识：react和vue的官方文档均明确建议使用具有唯一性和稳定性的值作为key，而非单纯依赖index。社区普遍认同这一最佳实践，认为这是编写高性能、易于维护列表渲染代码的重要原则。


# ESModule使用export default和export有什么区别？
1. 语法形式
```js
export default expression;
export { identifier }
```
2. 导出数量
    1. export default：只能用于导出一个默认值，该模块有一个默认导出；
    2. export：可以导出多个命名导出，每个导出都有一个明确的标识符；
3. 导入方式
    1. import myDefault from 'module-name';
    2. import { myNamed } from 'module-name';
4. 导入时的合并
    1. export default：不支持合并，每个模块只有一个默认导出；
    2. export：支持合并，可以将多个模块的命名导出合并到一个对象中。
5. 导入时的重命名
    1. export default：导入时可以自由指定名称，无需与到处是匹配；
    2. export：导入时必须使用与导出相同命名的标识符，可以使用as关键字重命名；
6. 简洁性与灵活性
    1. export default：提供了一种简洁的方式来导出模块的主要功能或默认行为，适合于导出模块的核心接口；
    2. export：更加灵活，允许导出多个独立值，每个值有其明确的标识符，便于组织和管理模块的多个组成部分。

# react中的portal是什么？
* Portal是一种将React子组件渲染到其父组件以外的DOM节点的技术。Portal允许开发者打破react组件树的常规渲染范围，将特定内容渲染到页面的任意位置，即使该位置位于react组件树的根节点之外。通过使用portal，可以确保这些内容在视觉呈现和层叠样式方面不受父组件布局的限制，实现更灵活的UI布局或交互效果；
* portal的工作原理
    1. 核心API是createPortal函数，该函数接收两个参数：
        1. child：一个React元素，字符串或片段，表示要渲染到目标位置的内容；
        2. contianer：一个DOM元素，指定portal内容应该注入到的DOM节点；
* portal的应用场景
    1. 模态对话框：使模态对话框能够覆盖在所有内容之上，不受父组件样式的影响；
    2. 工具提示：让工具提示能够跟随鼠标悬停的元素精确为，不受父组件布局约束；
    3. 悬浮卡片：类似于工具提示，使悬浮卡片能够出现在页面的任何位置，与触发元素保持关联；
    4. 加载指示器：将加载动画渲染到不影响主要内容的位置，如屏幕中央或角落；
    5. 全局组件：对于需要占据整个浏览器视口的组件，如全屏编辑器、幻灯片放映等；
* portal的优势
    1. 视觉层级分离：portal允许将特定UI元素渲染到独立的视觉层级，不受父组件样式或布局限制，确保其始终可见或具有预期的叠加效果；
    2. 无障碍性：通过正确使用portal，可以确保辅助技术正确识别和导航这些特殊布局的元素；
    3. 代码组织：尽管portal内容在dom结构上脱离了react组件树，但在代码层面仍然可以保持良好的封装性和模块化；
* 注意事项
    1. 生命周期与事件处理：portal内部组件的生命周期方法和事件处理逻辑将目标容器的上下文执行，开发者需要确保这些逻辑适用新的DOM位置；
    2. 清理工作：Portal组件卸载时，需要确保清理portal内容以及可能的副作用；

# 为什么部分请求参数，需要使用encodeURIComponent进行处理？
1. 在发送HTTP请求时，尤其是GET请求和表单提交等场景，请求参数通常作为查询字符串或请求体的一部分传递给服务器。为了确保参数的正确解析和传输，部分请求参数需要适用encodeURIComponent进行处理，主要原因如下：
    * 符合URI编码规范：encodeURIComponent是js提供的一个全局函数，用于对统一资源标识符的组成部分进行百分号编码。这种编码遵循RFC 3986标准，确保生成的字符串符合URI的格式要求。具体来说：
        1. 空格会被编码为%20
        2. 特殊字符会被编码为相应的百分号编码形式
        3. 非ASCII字符会被转换为UTF-8编码，然后编码为相应的百分号编码形式
    * 防止解析错误：未经编码的请求参数可能导致服务器端或中间件在解析URI时出现错误。例如：
        1. 空格可能导致参数边界模糊，影响参数解析；
        2. 特殊字符可能与URI的其他部分冲突，导致解析异常；
        3. 非ASCII字符如果没有正确编码，可能会被服务器识别为非法字符或导致乱码；
        4. 通过适用encodeURIComponent对参数进行编码，可以消除上述潜在问题，确保请求参数能够被服务器端正确识别和解析；
    * 避免安全风险
        1. 不恰当的请求参数可能引入安全风险。如跨站脚本攻击，攻击者可能尝试在参数中插入恶意脚本；
    * 保持一致性：许多现代web框架、库和API都期望对请求参数经过encodeURIComponent编码，遵循约定确保与其他系统的互操作性，避免因编码问题导致的对接失败；何时适用encodeURIComponent：
        1. GET请求查询字符串：对每个查询字符串的键和值进行单独编码；
        2. POST表单提交：对表单字段的名称和值进行编码；
        3. URL路径段：对路径中的动态部分进行编码，确保生成的URL符合规范；
        4. 构造URL时的其他部分：根据需要对特殊字符进行编码；

# sql注入导致的安全问题是什么？
1. 数据泄露
    * 敏感信息窃取：攻击者可以通过注入sql语句，查询、提取或联合查询数据库中的敏感信息，如用户密码、个人身份信息、财务数据、商业秘密等。
2. 权限提升
    * 绕过认证：攻击者可以通过注入sql命令修改或删除用户的登录凭证，或者直接伪造有效的登录会话，获得未经授权的账户访问权限；
    * 权限升级：攻击者可以利用注入漏洞更改角色权限、添加具有高级权限的新用户或直接提升现有账户权限，从而获得对数据库的完全控制；
3. 数据篡改
    * 修改、删除数据：攻击者可以注入sql命令来更改或删除数据库中的记录，破坏数据完整性，影响业务正常运行，甚至导致财务损失或声誉损害；
    * 植入恶意数据：攻击者可以向数据库插入虚假、误导性或恶意内容，影响数据可信度、误导用户或系统决策；
4. 系统瘫痪
    * 拒绝服务（DoS）攻击：攻击者可能利用注入漏洞执行大量消耗资源的查询，导致数据库服务负载过高，从而影响服务可用性，甚至引发服务中断；
    * 破坏数据库结构：攻击者可能通过注入命令删除表、索引、视图或其他数据库对象、严重破坏数据库架构，导致应用无法正常运行；
5. 服务器控制
    * 操作系统命令执行：在某些情况下，如果数据库配置允许执行操作系统命令，攻击者可能利用注入漏洞执行操作系统命令。进一步渗透到服务器系统层面；
    * 跳板攻击：攻击者利用sql注入漏洞作为切入点，进一步探索网络环境，寻找其他安全弱点，进行横向移动，扩大攻击面；
6. 合规性问题
    * 法规遵从性受损：由于数据泄漏、未经授权访问等问题，可能导致企业违反数据保护法规，面临监管罚款，法律诉讼及品牌形象受损；
7. 业务逻辑漏洞利用
    * 绕过业务规则：攻击者可能通过注入sql指令操纵查询结果，绕过正常的业务逻辑验证，如免费购物、修改交易状态，解锁受限功能等；
8. 社会工程学攻击
    * 获取信任信息：攻击者可以通过获取的敏感信息实施社会工程学攻击，如冒充内部员工、欺骗客户、发起针对性钓鱼攻击等。

# 项目中是否使用过Cluster，说一下你的理解？
* Cluster是nodejs内置的一个模块，用于创建和管理进程集群，以充分利用多核CPU资源，提供服务器端应用程序的性能、可靠性和可伸缩性；
    1. Cluster的基本原理
        * 主进程（Master）：Cluster模块启动一个主进程，负责创建和管理多个工作进程；
        * 工作进程（Worker）：主进程根据CPU核心数或其他策略创建多个工作进程。每个进程都是独立的nodejs实例，运行相同的代码（通常指同一个入口文件），监听同一端口（通过主进程转发）；
        * 负载均衡：主进程通过内建的负载均衡机制，将接收到的客户端连接均匀分配给各个工作进程。nodejs默认使用轮询策略，也可以自定义负载均衡算法；
        * 消息通信：主进程和工作进程之间通过process.send和cluster.on()进行跨进程的消息通信，实现协作与状态同步。
    2. 项目使用，在构建高并发、高性能的后端服务时，尤其是处理大量短链接的请求的场景下，可以采用Cluster模块来实现进程级别的水平扩展和故障隔离；具体做法如下：
        * 初始化cluster：在服务的主入口文件中，检测当前环境是否支持cluster，然后，使用cluster.setupMaster方法设置必要的选项，并调用clsuter.fork创建与CPU核心数相等的工作进程。
        * 负载均衡：依赖Cluster模块提供的默认轮询策略，将客户端请求均匀分配到各个工作进程帐。
        * 工作进程管理：监听cluster.on()事件，当某个进行依赖退出时，自动重新fork一个新的工作进程以维持特定的进程数，同时，通过process.on在工作进程中处理自主进程的消息；
        * 共享资源与状态同步：如果项目中需要在工作进程间共享的数据或状态，可以借用第三方库实现进程间的缓存共享，或者使用消息通信机制进行状态同步；
        * 日志与监控：为每个工作进程的日志添加进程ID前缀，便于区分和追踪问题。结合日志聚合工具和监控系统收集各工作进程的性能指标和错误信息。
    3. 使用Cluster的优点
        * 提高资源利用率：利用多核CPU，通过多个工作进程并行处理请求，显著提高服务器吞吐量和响应速度；
        * 故障隔离：单个工作进程崩溃不会影响其他进程，主进程可以迅速重启故障进程，保证服务整体的高可用性；
        * 平滑扩展：只需调整工作进程数即可实现水平扩展，无需改动代码，集合容器化和orchestration工具，可以实现动态扩缩容；
        * 代码复用：工作进程运行的是同一份代码，开发和部署流程简便，无需为分布式系统引入额外复杂性；
    4. 注意事项
        * 避免全局状态：由于工作进程是互相独立的，应避免在代码中使用全局变量或直接修改模块级状态。是否可能导致数据不一致或竟态条件；
        * 直接IO操作：虽然cluster可以提高cpu密集型人物的处理能力，但对于阻塞的同步IO操作，多进程并不能带来显著性能提升。这类场景更适合使用异步编程模型，连接池，数据库分片等技术优化；
        * 内存占用：每个工作进程都会占用一定的内存资源。在内存有限的环境中，需要权衡工作进程数量和内存消耗，避免过度消耗内存导致系统性能下降；

# Node接口转发有无做什么优化？
* 在是nodejs进行接口转发时，可以针对不同的场景和需求实施多种策略提提升转发效率，降低延迟，增强系统稳定性并减少资源消耗。以下是常见的优化策略：
1. 连接池管理
    * 对于后端服务的交互，使用连接池来复用TCP连接，减少建立和关闭连接的开销，提高请求处理速度；
2. 请求缓存
    * 对于一些不会频繁变动且结果可缓存的接口请求，可以在nodejs中间层实现请求结果缓存。当收到相同请求时，先检查缓存是否存在有效结果，如有则直接返回，避免重复转发和计算；
    * 可以使用内存缓存（node-cache）或分布式缓存来存储缓存数据，根据数据大小、有效期、命中率等因素选择合适的缓存策略和驱逐算法；
3. 请求合并与批处理
    * 如果客户端存在大量相似或重复的小请求，可以在nodejs中间层合并这些请求为单个或少数几个请求发送到后端，减少网络交互次数，提高总体性能；
    * 对于异步任务或定期执行的任务，可以采用批次方式，积累一定数量的请求后再一次性转发，减轻后端压力，降低网络波动单次请求的影响；
4. 异步非阻塞处理
    * 利用nodejs的异步非阻塞特性，确保接口转发过程中尽可能减少阻塞操作。使用回调、promise、async/await等方式编写非阻塞代码，确保在等待后端响应期间可以处理其他请求；
5. 错误处理与重试机制
    * 实施完善的错误策略，对转发过程中可能出现的各种错误进行捕获并适当反馈给客户端。
    * 设计合理的重试机制，对暂时性故障的请求自动进行有限次数的重试，提高系统容错性和可用性；
6. 性能监控与分析
    * 安装性能监控工具或使用nodejs原生的性能分析模块，收集接口转发的性能数据，包括请求响应时间，成功率，错误率，cpu和内存使用情况；
    * 分析监控数据，找出性能瓶颈和异常行为，为优化策略提供依据；
7. 负载均衡与服务发现
    * 当后端服务器有多台实例时，nodejs中间层可以实现客户端请求到后端服务实例的负载均衡，通过轮询，哈希，权重等策略分散请求，避免单点过载；
    * 结合服务注册与发现机制，动态更新后端服务实例列表，确保中间层总是能够正确转发到可用的服务实例；
8. 代码优化与模块化、
    * 对转发逻辑进行代码优化，去除不必要的计算和冗余操作，提高代码执行效率；
    * 将转发逻辑封装成模块或服务，便于测试、维护和独立扩展，同时有利于代码复用和团队协作；
9. 协议压缩与数据优化
    * 对于体积较大的请求或响应速度，考虑启用HTTP压缩，减少网络传输的数据量；
    * 根据业务需求，对请求和响应数据进行适当优化，去除不必要的字段，使用更紧凑的数据格式
10. 服务器配置与调优
    * 根据nodejs应用特点，调整服务器的系统参数，优化内核设置以适应高并发场景；
    * 对nodejs本身进行调优，如设--max-old-space-size以管理内存使用，启用--inspect进行远程调试等；

# 扫描二维码登录网页是什么原理，前后端是如何联系的？
1. 前端二维码
    * 前端在用户点击“扫码登录”后，向后端发送请求，生成一个用于登录的唯一标识和可能的附加信息；
    * 后端接收到请求后，生成所需数据，并将其编码为一个二维码图像，这通常涉及使用二维码生产库将数据转为二维码格式。
    * 前端接收后端返回的二维码图像数，将其展示在网页上供用户扫描；
2. 用户扫描二维码
    * 用户使用移动设备上的二维码扫描应用扫描网页上的二维码；
    * 扫描应用解析二维码中的数据，并将解析结果（即唯一标识符和附加信息）传递给相应的移动端应用程序。
3. 移动端验证和授权
    * 移动端应用程序接收到扫描结果后，通常会进行以下操作：
        * 校验数据的有效性
        * 请求用户确认授权登录
    * 用户确认授权后，移动端应用程序将用户身份信息与扫描到的唯一标识符打包，发送到后端进行验证；
4. 后端验证与状态同步
    * 后端接收到移动端发送的验证请求后，执行以下操作：
        1. 验证唯一标识符的有效性，确保其先生成的二维码对应；
        2. 根据用户身份信息进行验证，确认用户在移动端应用的登录态是有效的
        3. 通过验证后，后端在服务器端记录用户的登录状态，关联到对应的网页对话；
5. 前端接收登录状态
    * 前端生成二维码后，通常会开启一个长轮询，websocket连接，server-sent-events流定期轮询机制，监听后端关于登录状态的变化；
    * 当后端验证移动端发来的用户信息成功记录登录状态后，通过上述实时通信渠道通知前端；
    * 前端接收到登录成功后，关闭二维码显示与监听机制，将用户重定向到登陆后界面或直接显示已登录状态，完成扫描流程；

# 在js中，如何实现函数缓存？函数缓存有哪些应用场景？
* 函数缓存是一种优化策略，通过将函数的计算结果存储起来，当相同的输入再次出现时，直接返回之前计算好的结果，而不是出现执行函数。这种技术在计算机科学中称为“memorization”。在js中，可以通过以下几种方式实现函数缓存
    1. 使用对象作为缓存容器：最简单的就是利用一个对象作为缓存的键值对存储，将函数调用函数时，先检查缓存中是否存在对应的键，存在则直接返回缓存的值，不存在则执行并更新缓存。
    ```js
    function cachedFunction(arg) {
        const cache = {};
        function computeValue(input) {
            return input * input
        }
        function wrapper(input) {
            if (cache.hasOwnProperty(input)) {
                return cache[input]
            } else {
                const result = computeValue(input);
                cache[input] = result;
                return result;
            }
        }
        return wrapper(arg);
    }
    ```
    2. 使用Map数据结构：在现代浏览器和nodejs环境中，可以利用Map数据结构来替代对象作为缓存容器，因为它允许任何类型的值作为键，而不仅仅是字符串或SYmbol，这对于处理复杂类型的参数的函数尤为有用；
    ```js
    function cachedFunction(arg) {
        const cache = new Map();
        function computeValue(input) {
            return input * input
        }
        function wrapper(input) {
            if (cache.has(input)) {
                return cache.get(input)
            } else {
                const result = computeValue(input);
                cache.set(input, result);
                return result;
            }
        }
        return wrapper(arg)
    }
    ```
    3. 使用第三方库或装饰器模式：对于复杂的场景，可以考虑使用专门支持函数缓存的第三方库（lodash的memorize函数），它们通常提供了更丰富的选项，如自定义缓存大小限制，比较函数等。另外，还可以采用装饰器模式来透明地为现有函数添加缓存功能；
    4. 使用weakmap和闭包（针对对象实例）：如果函数的参数是对象实例，希望仅针对同一实例的相同属性值进行缓存，可以使用weakmap结合闭包实现。这一既能避免内存泄漏，又能确保不同实例间的缓存隔离；
    ```js
    function cachedFunction(arg) {
        const cache = new WeakMap();
        function computeValue(input) {
            return input.value * input.value;
        }
        return function wrapper() {
            if (!cache.has(arg)) {
                const result = computeValue(arg);
                cache.set(obj, result);
            }
            return cache.get(obj);
        }
    }
    ```
* 函数缓存适用于以下几种情况：
    1. 计算成本高昂且结果确定性较强的函数：当某个函数计算过程耗时较长，并且对于相同的输入始终产生相同的结果时，使用函数缓存可以明显提高程序性能，避免不必要的重复计算。
    2. 递归算法：在处理具有重叠子问题的递归算法中，函数缓存可以避免重复计算已经解决过的子问题，从而极大地降低时间复杂度；
    3. 频繁查询的数据：当应用程序频繁查询一些相对静态的数据，而获取这些数据的过程涉及一定的开销，通过函数缓存也可以一次性获取并长期保存结果，提升应用响应速度。
    4. 图形渲染于计算几何：在图形学和计算几何领域，一些基本行政的属性可能需要多次计算。函数缓存可以确保对同一形状的重复计算只需进行一次，提高渲染效率；
    5. API请求结果：对于Web服务客户端，向服务器发送相同的API请求并接收相同的响应时，通过函数缓存可以避免不必要的网络通信，减少带宽消耗和延迟。

# DOM常见的操作有哪些？
1. 获取DOM元素
    * getElementById
    * getElementsByClassName
    * getElementsByTagName
    * querySelector
    * querySelectorAll
2. 创建DOM元素
    * createElement：元素节点
    * createTextNode：文本节点
3. 插入DOM元素
    * appendChild
    * insertBefore
    * insertAfter
4. 删除节点
    * removeChild
    * remove
5. 更新/获取/移除DOM节点属性
    * setAttribute
    * getAttribute
    * removeAttribute
6. 替换节点
    * replaceChild
7. 复制DOM节点
    * cloneNode
8. 遍历DOM节点
    * childNodes
    * parentNode
9. 文本节点操作
    * nodeValue：设置或获取文本节点的为本内容
10. HTML属性与样式操作
    * innerHTML
    * style

# 函数式编程的见解及其利弊？
* 函数式编程是一种编程范式，强调以函数为中心，通过纯函数、不可变数据、高阶函数、柯里化、函数组合、递归来构建程序。
* 函数式编程的见解
    1. 纯粹性：纯函数是函数式编程的核心概念之一。纯函数只依赖于其输入参数，且不产生副作用。这意味着相同的输入总是得到相同的输出，且不会修改外部状态或外部环境。纯函数使得代码更易于推理、测试和并行化。
    2. 不可变性：函数式编程倡导使用不可变数据结构，即一旦创建后就不能被修改，数据变更通过创建新对象来表示，而非直接修改原有对象。不可变性简化了并发编程，减少了意外的副作用，并促进了代码复用和优化。
    3. 声明式编程：函数式编程倾向于采用声明式风格，关注“做什么”而非“怎么做”。程序通过组合和变换函数来表达计算逻辑，而非显式地控制流程。声明式编程使得代码更简洁、易于理解，且更易于利用编译器和运行时进行优化。
    4. 高阶函数：高阶函数是接受函数作为参数或返回函数的函数。它们提供了强大的抽象机制，使得代码更加模块和通用。常见的高阶函数如map、filter、reduce等，能够简洁表达列表操作和数据转换。
    5. 函数组合：函数组合是将多个函数连接在一起，形成一个新的函数，其效果相当于依次应用每个函数。函数组合鼓励将复杂的逻辑拆解为一系列简单、可复用的小函数，增强了代码的可读性和可维护性。
    6. 递归：递归是函数式编程中处理重复或循环逻辑的重要手段。通过定义函数自身调用的方式来解决问题，递归使得代码更符合人类思维习惯，并且在某些情况下比迭代更为直观。
* 函数式编程的利弊
    1. 利
        * 易于推理于调试：纯函数和不可变性使得代码行为更可预测，减少了意外副作用，简化了调试过程。由于输出仅取决于输入，独立于程序上下文进行单元测试；
        * 更好的并发和并行性：纯函数无副作用的特性以及对不可变数据的偏好，使得函数式代码天然适合并发与并行执行。无需担心共享状态带来的竟态条件和同步问题，有利于充分利用多核处理器资源；
        * 易于重构与代码复用：函数式编程鼓励小而纯的函数，这些函数往往职责单一、接口清晰、易于复用和替换。通过高阶函数和函数组合，可以灵活构造复杂的逻辑，且不影响底层函数的实现；
        * 利于编译器优化：声明式编程风格和纯函数性质使得编译器和运行时可以进行更神层次的优化，如自动并行化、惰性求值、常量折叠等，提高程序运行效率；
    2. 弊
        * 学习曲线陡峭：函数式编程的概念、思维模式与传统的命令式编程有所不同，初学者可能需要花费更多时间理解和掌握。特别是对于习惯于面向对象编程和命令式控制流的开发者，转变思维方式可能颇具挑战；
        * 不适合所有场景：并非所有问题都自然适合函数式编程解决方案。某些任务可能需要频繁修改状态或依赖副作用，强行采用函数式编程可能导致代码过于复杂或效率低下；
        * 性能问题：某些情况下，处理大型数据，函数式编程可能导致过多的内存分配和额外的函数调用开销。虽然可以通过各种手段优化缓解，但有时仍需权衡性能与代码简洁性；
        * 工具链与生态系统支持：尽管近年函数式编程语言和库的发展迅速，但在某些领域，如游戏开发、嵌入式开发等，函数式编程的工具链和支持可能不如命令式或面向对象成熟。

# 什么是空间复杂度、时间复杂度？
## 空间复杂度
* 空间复杂度指执行一个算法过程中所使用的额外内存空间的大小，通常以该空间大小与输入数据规模之间的关系来表示。包括
    1. 输入数据所占的空间：这是解决问题必需的，不计入算法的空间复杂度；
    2. 辅助变量所占空间：算法在执行过程中为了存放之间结果或某种数据结构所分配的额外内存；
    3. 递归调用栈占用的空间：对于递归算法，还需要额外考虑递归调用的深度，尤其是在没有尾递归优化的情况下；
    4. 空间复杂度用大O符号表示，记为Sn=O(fn)，其中fn是一个关于n的函数，表示随着输入规模n的增加，算法所需额外空间的增长趋势。
## 时间复杂度
* 时间复杂度衡量的是算法执行过程中所需的基本操作次数与输入数据过膜之间的关系。它反映了算法执行时间随输入规模的变化趋势，而非实际执行的具体时间，因为实际时间还受到硬件性能，系统负载等因素影响；
    1. 基本操作次数：选择算法种最具代表性的基本操作作为计数单位，统计最坏情况、最好去情况及平均情况下，算法执行这些基本操作的次数；
    2. 渐进时间复杂度：由于实际计算具体操作可能较为复杂，通常采用渐进分析的方法，关注当n足够大时，操作次数的增长趋势。用大O符号表示，如Tn=O(gn)，其中gn是一个关于n的函数，表示随着n增大，算法所需时间的增长速率；
    3. 常见的时间复杂度包括
        1. 常数阶：O(1)，无论输入规模如何变化，算法执行时间不变；
        2. 对数阶：O(logn)，算法时间随输入规模增长缓慢，如二分查找；
        3. 线性阶：O(n)，时间随输入规模成比例增长，如遍历数组；
        4. 平方阶：O(n^2)，时间随输入规模平方增长，如冒泡排序；
        5. 指数阶：O(2^n)，时间随输入规模指数增长，如完全穷举搜索。

# react的事件代理机制和原生事件绑定混用有哪些问题？
1. 事件处理顺序混乱：合成事件优先级问题，React的事件处理是在捕获阶段触发，而原生事件默认是在冒泡阶段触发的。若同时使用，可能导致事件处理顺序不符合预取。特别是在有父子组件嵌套的情况下，合成事件和原生事件的触发时机可能交错，不易控制；
2. 事件冒泡与阻止冒泡的冲突：在原生事件处理函数中调用event.stopPropagation会阻止事件继续向上冒泡；这可能导致react的合成事件无法触发，这是因为react的事件系统依赖于冒泡至顶层元素后通过事件代理进行处理。阻止冒泡可能会切断react合成事件的链路，使得同级或祖先级组件中的合成事件监听器无法接收到相应的事件；
3. 事件系统不一致性
    * 编程模型和API差异：react的事件处理函数遵循不同的编程约定，如自动绑定this上下文，采用驼峰命名、返回false不再阻止默认行为等。混用两种事件绑定方式会使代码风格不一致，增加维护难度；
    * 状态管理与生命周期差异：react合成事件与组件的状态管理和生命周期紧密关联，如setState方法在合成事件处理器种能触发组件重新渲染。原生事件则无法直接利用这些react特性和最佳实践，可能导致状态更新和ui刷新逻辑混乱；
4. 性能与内存影响
    * 额外的事件监听器：每个混用原生事件绑定的元素都会增加一个独立的事件监听器，这不仅可能导致内存开销增加，还可能打破react通过事件代理实现的事件处理优化，降低整体性能；
    * 内存泄漏风险：原生事件绑定如果没有正确移除，可能导致内存泄漏。而react种，合成事件的管理是自动化的，与组件的生命周期同步，减少了手动管理的复杂性和出错可能性；
5. 跨浏览器兼容性：react的合成事件在底层已经对不同浏览器的事件处理差异进行了标准化处理。直接使用原生事件绑定需要开发者自行处理这些差异，增加了代码复杂性和潜在的兼容性问题。

# 对于受控组件和非受控组件的理解，分别在什么场景下使用？
## 受控组件

1. 理解：受控组件是react中用于处理表单输入元素的一种模式，这种模式下，表单元素的值由react的state直接控制。每当用户在表单元素中进行交互，组件通过相应的事件处理器捕获变化，并更新组件的state。表单元素的value或checked属性直接绑定到state中的相应值，确保视图与状态始终保持一致。只有当组件重新渲染时，表单元素的值才会发生变化，这意味着react组件完全控制了表单数据的流向，称为受控；
2. 使用场景
    1. 需要即时响应用户输入：需要实时验证用户输入或根据输入实时更新相关界面时，受控组件能够确保在每次输入发生变化时立即触发业务逻辑；
    2. 需要精确控制表单数据：在涉及复杂表单逻辑、多步表单，条件可见的表单字段或动态生成的表单场景中，受控组件便于集中管理和追踪表单状态，确保提交表单时数据的一致性和完整性；
    3. 集成状态管理库：使用redux、mobx等状态管理库时，受控组件便于将于表单状态纳入全局状态管理，简化状态流转和组件间通信；
    4. 跨字段联动：当多个表单字段之间存在依赖关系，一个字段的值变化会影响其他字段的可用性、默认值或验证规则时，受控组件有助于实现字段间的联动逻辑；
## 非受控组件
1. 理解：非受控组件则是react另一种处理表单输入的方式，此时表单元素的值不由react组件的state直接控制。组件不再通过state来跟踪输入值，而是使用原生HTML属性设置初始值，之后表单元素內部自行维护其状态。如需访问表单元素的当前值，通常通过ref来获取DOM节点并读取其value或checked属性；
2. 使用场景：非受控组件在以下场景中更为合适、
    1. 简单、临时或动态生成的表单：对于无需复杂验证逻辑、不需要即时响应用户输入，或者表单字段数量不确定、动态生成的情况，非受控组件可以简化代码，避免为每个表单字段都创建对应的state；
    2. 性能敏感场景：当表单字段众多，且大部分字段在大多数时候不需要react关注其值的变化时，非受控组件可以减少不必要的state更新和组件渲染，提高性能；
    3. 与非react库或插件集合：在某些不依赖react状态管理库的第三方表单库、富文本编辑器或其他UI组件集成时，非受控组件能够更好地适应这些库的原生API和工作方式；
    4. 大型或遗留项目改造：在对已有大型项目进行react化改造，或是对接遗留系统时，非受控组件可以作为过渡方案，逐步引入react组件，降低迁移复杂度；

# vue如何监听插槽的变化？
* vue监听插槽变化的场景通常涉及到父组件需要直到子组件通过插槽传递的内容何时发生了变动。由于vue本身并没有直接提供对插槽内容发生变化的原生监听机制，因此需要实现这一目标，需要采取一些变通方法。以下是几种常见的策略：
    1. 使用自定义事件（$emit）
        * 原理：让子组件在插槽内容发生变化时触发一个自定义事件，通知父组件内容变更；
        * 步骤：
            1. 子组件中，当插槽内容发生状态变更时，调用this.$emit
            2. 父组件在使用子组件时，监听这个定义的事件；
            3. 在父组件的methods定义处理方法，处理插槽内容变化后的逻辑；
    2. 使用v-bind动态传递数据
        * 原理：如果插槽内容是基于某个数据项动态生成的，可以将数据项作为props从父组件传递给子组件。这样，当数据项在父组件中发生变化时，子组件会自动重新渲染，同时触发插槽内容的更新。父组件可以通过监听自身数据项的变化来间接感知插槽内容的变化；
        * 步骤：
            1. 将决定插槽内容的数据项作为props传入子组件；
            2. 在子组件中，使用v-bind或:prop将数据向与插槽模板绑定；
            3. 在父组件中，当slotdata发生变化时，会触发子组件重新渲染。父组件可以通过watch或computed来监听slotData4的变化，执行相应逻辑；
    3. 使用provide/inject或状态管理库
        * 原理：如果插槽内容的变化需要跨越多个层级的组件进行通信，可以借助provide/inject或状态管理库来共享状态。当状态改变时，所有依赖该状态的组件都会重新渲染；
        * 步骤：
            1. 使用provide/inject
                * 在父组件中使用provide暴露状态；
            2. 在子组件中使用inject接收状态，并在插槽模板中使用；
            3. 当slotState在父组件中发生变化时，会触发子组件重新渲染；
            4. 使用vuex：
                * 在vuex store中定义相关状态和mutations；
            5. 父组件通过mapMutations或直接调用commit方法更新状态；
            6. 子组件通过mapState或computed获取状态，并在插槽中使用。
    4. 使用MutationObserver（极端情况，不推荐）
        * 原理：在极少数情况下，如果插槽内容发生变化难以通过上述方法捕获，可以考虑使用浏览器MutationObserver API直接监听子组件DOM的变化。但这是一种非常规且低效的做法，容易导致代码复杂且易出错，一般不推荐；
        * 步骤：
            1. 在父组件创建MuatationObserver实例，监听子组件根节点的DOM变化；
            2. 在beforeDestroy或unMounted钩子中停止观察；

# img标签的srcset属性的作用？
* srcset是一种用于优化网页图像加载和显示的技术，它允许开发者为同一张图片提供多个版本，并根据用户的设备条件自动选择最合适的图片源进行加载。srcset属性的主要作用体现在以下几个方面：
    1. 响应式图像加载：srcset属性使图片能够响应不同设备的特性，特别是屏幕像素密度和视口大小。当用户使用高分辨率显示屏时，secset可以直到更高分辨率的图片版本，确保图像在高DPR设备上呈现更清晰的细节，而低分辨率设备则加载适合其屏幕的较小图片，节省带宽。这有助于提供一致且高质量的视觉体验，同时避免为了高分辨率设备加载过大的图像而导致的加载速度慢和数据浪费；
    2. 自适应布局：除了根据设备像素比选择图片，srcset还可以配合sizes属性根据浏览器视口宽度选择合适的图片。当页面布局具有响应式涉及，即图片的尺寸会随着视口宽度变化时，sizes属性定义了在不同视口宽度下图片的展示尺寸。浏览器根据当前视口大小，sizes指示的尺寸以及srcset提供的候选图片列表，选取最符合当前条件的图片源进行加载；
    3. 性能优化：通过提供多种分辨率或尺寸的图片源，srcset有助于提升网页性能。浏览器可以根据用户的设备条件选择最轻量级的图片，减少网络传输量，从而加快网页加载速度，特别是对于移动端设备和网络条件较差的用户。这有助于提供用户体验，同时有利于搜索引擎排名，因为网站性能是现代SEO评价体现中重要因素之一。
    4. 代码简洁与可维护性：相比于使用js动态切换图片源或编写复杂的媒体查询来实现类似的效果，srset属性提供了声明式的解决方案，使得图像响应式处理更加直观、简洁且易于维护。开发者只需在srcset属性列出不同版本的图片及对应条件即可，浏览器会自动处理选择和加载过程，无需额外脚本干预；
    5. 未来兼容性：srcset是W3C标准一部分，得到了现代浏览器的良好支持。使用srcset有利于确保网页在未来设备和技术发展时仍能提供良好的图像体验，无需频繁修改代码以适应新的环境；

# 说说DOCTYPE标签有什么用？
* DOCTYPE（Document Type Declaration，文档类型声明）标签是位于HTML文档起始处的一个特殊声明标签，用于告知浏览器应当使用何种文档类型来解析和渲染当前文档。DOCTYPE标签在web开发中扮演重要角色，其具体作用包括：
    1. 确定文档模式（Rendering Mode）：DOCTYPE声明直接影响浏览器对文档的解析方式，即”标准模式“还是”混杂模式“来渲染页面：
        1. 标准模式：当DOCTYPE声明有效且指定了一个已知的、符合标准的DTD是，浏览器将以遵循W3C标准的方式来解析和渲染页面。在这种模式下，浏览器遵循最新或指定版本的HTML和CSS规范，确保页面表现的一致性和可预测性；
        2. 混杂模式：当DOCTYPE声明缺失、错误或指向一个未知的DTD时，浏览器会退回到”混杂模式“，模仿早期浏览器的非标准行为来解析和渲染页面。混杂模式是为了兼容那些为遵循规范的老网站，它可能会放宽对HTML语法的检查，以及对CSS样式的解释，从而导致某些样式规则的处理方式与标准模式不同；
    2. 启用特定功能与特性：正确的DOCTYPE声明能够确保浏览器启用特定的HTML版本的所有功能和特性。例如，在HTML5中，DOCTYPE声明有助于浏览器识别并支持新的元素、属性和API。缺少DOCTYPE声明或使用了错误的DTD可能导致某些现代特性无法被识别或正确处理；
    3. 辅助验证工具：DOCTYPE声明不仅指导浏览器解析，还帮助HTML验证工具识别文档应遵循的规范。当使用验证工具检查HTML文档时，DOCTYPE声明能让工具明确文档类型，从而依据相应的DTD进行严格的语法检查，帮助开发中发现并修复潜在的代码错误或不规范的地方；
    4. 影响js引擎行为：在某些情况下，DOCTYPE声明也可能影响js引擎对文档对象模型（DOM）的理解和处理方式。例如，某些js库或框架可能依赖于特定的文档模式来确保其功能正常工作。此外，DOCTYPE声明可能间接影响到js与css互相作用的部分，比如在某些css hack或特定条件下，js可能需要根据文档模式调整其操作方式；
    5. 促进互操作与向前兼容：DOCTYPE声明有助于确保不同浏览器之间的互操作性，即在各种浏览器环境下，网页都能以相似的方式呈现。此外，使用标准DOCTYPE有助于未来的浏览器更好地理解现有文档，即使随着HTML标准的发展，也能在一定程度上向前兼容已存在的内容；

# Express中Router的作用？
* Express内的一个核心组件，它负责定义、组织和处理应用程序中的路由请求。
    1. 模块化路由管理：Router允许开发者将路由相关的中间件和处理函数组织成独立的模块。这样可以避免在主应用文件中堆积大量的路由定义，提高代码的可读性、可维护性和可重用性。每个router实例可以视为一个小型的路由处理器，负责处理特定范围内或特定主题的路由请求；
    2. 组织中间件：router提供了与app对象类似的中间件注册方法，如use、get、post等，用于注册针对特定路由路径的中间件。这些中间件可以进行身份呢验证、权限检查、参数解析、数据预处理等工作，为后续的路哟处理函数提供干净、格式化的输入。如果router级别组织中间件，可以更好封装和复用通用逻辑，确保代码结构清晰；
    3. 定义路由规则与处理函数：router允许定义HTTP方法与URL路径的映射关系，并关联响应的处理函数。处理函数负责处理与该路由匹配的请求，生成响应内容。这种结构化的路由定义方式使得应用程序的行为与URL结构紧密关联，便于开发、测试和文档编写；
    4. 嵌套路由：router可以嵌套，形成层次化的路由结构。子router可以挂载到父router上，形成更复杂的路由树。嵌套路由使得大型应用种的路由配置更加有序，同时也便于按功能或模块划分代码，实现更细粒度的中间件隔离和路由处理；
    5. 便于代码拆分与团队协作：使用router可以将路由相关的代码拆分为单独的模块文件，每个文件专注于某一领域的路由定义。这种拆分方式有利于多人协作开发，每个团队成员可以专注于特定模块的路由实现，而不必担心干扰到整个应用的路由配置；
    6. 灵活挂载与重用：router实例可以挂载到express应用的任意位置，也可以在多个地方重复使用。这使得router成为一种可移植、可组合的组件，尤其是在微服务架构或需要动态添加路由的场景种非常有用；


# 简述vuex的数据传递流程？
1. 初始化store：创建一个vuex Store实例，定义其内部状态、改变状态的方法、异步操作以及可计算状态的衍生数据；
2. 组件获取状态：在vue组件中，通过this.$store.state或mapState辅助函数访问Store的全局状态。mapState可以将Store的状态映射为局部计算属性，便于在模板中使用；
3. 触发状态变更：当组件需要改变时，不能直接修改store中的state。而是通过触发一个action来发起状态变更请求。action是一个异步操作，通常包含业务逻辑，如调用api、处理副作用等。在action中，通过dispatch方法调用相应的action函数；
4. 提交状态变更：action内部会调用commit方法，传递一个mutation类型和需要更改的数据。commit会触发store中对应的mutation函数，后者负责直接修改state；
5. 定义mutation：mutation函数是唯一能直接修改state的地方，它们是纯函数，接受当前状态作为参数，并返回新的状态。这样可以确保状态变更的同步、可跟踪和可测试；
6. 响应状态变化：一旦state发生变化，所有依赖该状态的组件会自动重新渲染，以反映最新的状态值；
7. 使用getters：如果需要对store中的状态进行计算或过滤，可以定义getter函数。getter接受state作为参数，返回经过处理后的状态。

# 如何保存页面的当前状态？
1. 使用浏览器存储（localStorage/sessionStorage）：将页面数据序列化后保存到storage中，这两个API都提供了在浏览器端持久化存储数据的能力，区别在于localStorage数据长期存储，除非手动清除，而sessionStorage仅在当前会话期间有效；
    * 步骤：
        1. 页面状态变更时，使用JSON.stringify()将数据序列化，然后保存到storage中；
        2. 页面记载时，使用getItem并JSON.parse()将数据反序列化；
2. 借助路由参数与路由状态：在vue router的单页面应用中，可以利用路由参数和路由状态来携带页面状态信息。这样，用户通过URL访问页面时，可以直接从路由信息中恢复状态；
    * 步骤
        1. 在路由跳转时，将状态数据附加到路由对象上，作为查询参数或路由元信息；
        2. 页面加载时，通过$route获取相关数据，还原页面状态；
3. 使用History API（pushState/replaceState）：对于需要保存页面滚动位置或其他URL无关状态的情况可以结合history api来实现无刷新状态更新和恢复；
    * 步骤
        1. 状态变更时，使用pushState等方法更新浏览器历史记录的状态对象，其中包含当前页面状态；
        2. 在window.onpopstate事件处理器中，当用户点击浏览器后退/前进按钮或调用back时，可以从事件对象的event.state属性获取之前保存的状态，进而恢复页面状态；
4. 服务器端状态管理（RESTFUL API + Vuex）：对于涉及服务器端数据的状态，可以结合状态管理库与restful api实现状态持久化；
    * 步骤
        1. 在状态变更时，通过发送ajax请求将数据保存到服务端；
        2. 页面加载时，先从服务器获取初始状态数据，然后用这些数据初始化vuex
5. 第三方库辅助：一些第三方库可以帮助简化状态保存与恢复的过程。

# 如何从html元素继承box-sizing？
1. box-sizing：用于定义一个元素的盒模型，即决定元素的尺寸时基于内容区域还是包含边框和内填充在内的整个框。要让一个元素从其父元素继承box-sizing的设置，遵循以下原则：默认情况下，所有HTML元素都会继承父元素的box-sizing属性值；这是因为box-sizing是一个常规的css属性，遵循css的层叠和继承规则。如果父元素显式设置box-sizing属性，其所有子元素都将继承该设置。因此无需特殊操作都能实现从父元素到子元素的box-sizing继承。
2. 特殊情况：大部分情况下都会继承，但需要注意：
    1. 如果某个子元素通过内联样式、行内样式块或外部样式明确设置了box-sizing属性，则它不再继承父元素的设置，而使用自身声明的值；
    2. 虽然所有元素默认继承box-sizing，但在实际项目中，为了确保元素都遵循统一的盒模型计算方式，通常会在css reset或normalize阶段，直接在html或*上设置box-sizing:border-box。这样做可以强制整个文档范围内所有元素采用相同的盒模型，避免因默认盒模型差异带来的布局问题；
