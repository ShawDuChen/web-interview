
# JS中的bind、call、apply的区别？
* 三个方法都是js中函数对象的内置方法，用于改变函数调用时的上下文，它们之间的主要区别在于参数传递方式、执行时机以及返回值的不同；
1. 参数传递方式：
    * call：接收两个或更多参数，第一个参数是this的上下文，后面的参数是直接传递给目标函数的参数列表，可以是任意数量；
    * apply：接收两个参数，第一个参数是this的上下文，第二个参数是数组，数组中的元素作为单独的参数传递给目标函数；
    * bind：接收两个或更多参数，第一个参数是要作为this的上下位，其余参数作为预绑定参数，这些参数会被插入到新生成的函数的参数列表开头，当新函数调用时，这些预绑定参数将先于传入的新参数被传递给目标函数；
2. 执行实际：
    * call和apply：立即调用目标函数并返回结果；它们主要用于立即执行函数，同时改变上下文；
    * bind：不会立即调用，而是返回一个新的函数，这个新函数的this值被绑定到一个新的函数，同时带有预绑定的参数，新函数可以在任何时候被调用，调用时将以绑定的上下文和参数执行目标函数；
3. 返回值
    * call和apply：直接执行函数，返回目标函数的返回值；
    * bind：返回新函数（绑定函数）这个新函数保持原始函数的行为，但是具有固定的this值和预绑定参数。调用这个新函数才执行原函数，并返回原函数的返回值；

# vue-router中的hash模式和history模式的区别？
1. URL结构
    1. hash模式：URL中包含#符号，路由地址紧跟在#后面，这种模式下，路由变化实际上是对URL中哈希部分的修改，由于哈希改变不会触发页面请求，浏览器不会像服务器发送新的HTTP请求；
    2. history模式：URL中不含#符号，路由路径直接反映在URL的路径部分，看起来像传统的多页面URL；这种模式下，路由变化表现为正常URL路径变化，用户角度看更直观和美观；
2. 浏览器历史记录交互
    1. hash模式：利用浏览器对哈希变化的监听（window.onhashchange），vue-router可以捕获到哈希变化并作出相应的路由切换，由于哈希变化不会改变页面，因此前进、后退等浏览器历史记录操作可以被vue-router无缝接管，实现页面间的无刷新跳转；
    2. history模式：利用HTML5 history API（pushState、replaceState、popState事件），vue-router可以在不触发页面刷新的情况下改变浏览器的URL并监听变化，同样实现了页面间的无刷新跳转，在history模式下，浏览器的前进、后退按钮以及地址栏回退/前进操作也能与路由状态保持同步；
3. 服务器配置需求：
    1. hash模式：由于哈希变化不会触发服务器请求，因此在服务器无需特殊配置，任何未命中路由的静态资源都会默认返回同一个HTML入口文件（根组件）。vue-router在客户端负责解析哈希并渲染相应的路由组件；
    2. history模式：由于history模式的URL看起来像是服务器上的一个真实路径，当用户直接访问这样的URL或刷新页面时，服务器需要能够正确响应，为了做到这一点，通常需要在服务器端进行配置，使其能够在所有非静态资源请求重定向到同一个HTML入口文件。这样，即使用户访问某个路由路径，服务器也能正确返回HTML文件，然后由客户端vue-router负责呈现对应的路由组件；


# 浏览器发送URL带中文乱码参数问题？如何解决？
* 出现中文乱码，主要是由于编码和解码方式不一致导致，为了解决这个问题，可以从以下几个方面入手：
1. 正确编码参数：使用js的内置函数encodeURIComponent()对参数进行编码；
2. 统一编码格式：确保服务器端解析URL时使用的字符编码于客户端发送时使用的编码一致，通常，使用UTF-8作为统一的编码格式，因为这是通用的字符集。在服务端配置中，确保HTTP响应头的content-type包含正确的字符集声明，如content-type: application/json; charset=utf-8；
3. 检查服务器配置：对于Apache、nginx等服务器的web应用，确保服务器配置正确处理带有中文参数的URL。
4. 数据库层面：如果URL参数最终要写入数据库，确保数据库连接和表的字符集和设置了UTF-8编码，避免数据存储或检索时出现乱码；
5. 前端后一致：前后端在处理URL参数是应保持相同的编码和解码方式；
6. 测试与排查：在解决乱码问题后，进行全面的测试，包括各种浏览器、操作系统和网络环境、确保在所有条件下都能够正确处理中文参数。如果仍出现乱码，检查整个请求响应链，确定问题出现在哪个环境，并针对性设置或代码处理；

# 浏览器出现丢帧的原因是什么？
1. 硬件加速功能问题
    * 硬件支持不足：如果计算机显卡性能较低或不支持现代web标准的硬件加速特性，可能导致浏览器在渲染复杂页面时无法有效利用GPU，从而丢帧；
    * 硬件加速功能未启用或故障：某些浏览器允许用户手动开启或关闭硬件加速功能，如果该功能被禁用或启用状态下出现问题，可能导致渲染效率低，引发丢帧现象；
2. 浏览器资源被占用过高
    * 多标签页或扩展程序：同时打开大量标签页或安装了过多消耗系统资源浏览器插件/扩展程序，可能导致浏览器内存、CPU占用过高，影响其正常渲染和更新页面的能力，进而引发丢帧；
    * 浏览器内部冲突：在同一台计算机运行多个版本浏览器实例，可能存在资源竞争问题，导致性能下降和丢帧；
3. 网络连接问题
    * 网络延迟或丢包：网络连接不稳定，存在高延迟或频繁丢包时，浏览器在加速或更新网页资源时可能会遇到阻碍，导致页面渲染不完整或不及时，造成视觉上的丢帧；
    * 带宽限制：对于包含大量高清媒体或大媒体数据量交互的应用，如果用户的网络带宽不足以快速传输所需数据，浏览器在等待数据到达的过程中可能出现卡帧；
4. 浏览器内核和网页代码兼容性问题
    * 过时的浏览器版本：使用已不再维护或对最新web技术支持不足的浏览器版本，可能导致某些网页元素无法正确高效渲染，引起丢帧；
    * 复杂的js或css：网页中可能引起复杂的js脚本或css样式可能导致浏览器解析和执行负担加重，尤其是在没有允许优化的情况下，可能引发渲染性能下降；
5. 操作系统及驱动因素
    * 操作系统性能瓶颈：操作系统本身的性能问题，系统更新不及时，后台允许的其他应用程序占用过多资源，都可能间接影响浏览器的性能表现；
    * 驱动程序问题：显卡驱动，声卡驱动，网卡驱动等设备驱动程序过时，不兼容或存在bug，可能导致浏览器无法充分利用硬件性能，或者引发其他与图形、音频、网络相关的故障，间接导致丢帧；
6. 特定网站或应用的优化不足
    * 网页设计与实现问题：个别网站可能存在编解码不良、资源加载策略不合理，动画效果实现不当等问题，即使在高性能设备和良好网络环境下也可能出现丢帧现象；

# HOC是什么？相比mixins有什么优势？
1. HOC指高阶组件，是React中一种复用组件逻辑的高级技术，它本质上是一个函数，接收一个react组件作为参数，并返回一个新的增强版的react组件，这个新的组件可以包裹原组件、添加额外的props、状态管理、生命周期方法或其他功能，而无需修改原组件的代码，HOC并不属于React的核心，而是利用react的组合性质自然而然派生出的一种设计模式；
2. mixins是react早期用于实现组件间代码复用中的一种机制，允许将可共享的行为封装到一个模块中，然后再多个组件中混入这些行为，然而，随着react的发展，特别是引入基于类的组件和更强大的状态管理工具后，mixins逐渐暴露出一些问题并被官方弃用；
3. 优势主要如下：
    1. 降低耦合：
        * HOC通过props影响内层组件：HOC将增强的功能以props的形式注入到被包裹的组件中，使得内层组件只需要关注如何响应这些props的变化，而不必直接处理HOC提供的逻辑细节。这种方式保持了组件间的松散耦合，因为内层组件不需要知道这些功能是如何实现的，只需对接统一的接口；
        * mixins直接修改组件的状态和方法：Mixins则会直接向组件添加状态变量和方法，导致组件内部混杂了来自多个mixins的逻辑，这增加了不同mixins之间以及mixins与组件自身逻辑之间的耦合度，可能导致难以预料的副作用和冲突；
    2. 层次结构清晰
        * HOC具有天然的层级结构：HOC的使用形式明确展示了组件的嵌套关系，新组建包裹原组件，形成清晰的层次结构，这种结构易于理解和调试，因为可以通过查看组件树直观地识别哪些功能是HOC添加的；
        * mixins缺乏直观的组织结构：使用mixins的组件内部混合了多个来源的行为，代码组织不够直观，阅读和维护这样的组件时，需要深入理解各个mixins的作用及其与组件主体逻辑的交互，理解了认知负担；
    3. 避免命名冲突和优先级问题
        * HOC通过props隔离命名空间，由于HOC通过props传递功能，每个功能都有其特定的prop名称，从而避免与内层组件自身的state或props名冲突，同时，由于react组件自身的props具有较高的优先级，可以轻松覆盖HOC传递的默认值，提供了灵活的定制化能力；
        * mixins易引发命名冲突和优先级混乱：当多个mixins定义了同名的状态变量或方法是，会产生命名冲突，此外，由于mixins的合并规则，有时难以确定某个方法和状态的最终来源和执行顺序，增加了复杂性和不确定性；
    4. 支持React的生命周期方法
        * HOC可以封装和增强生命周期方法：HOC作为一个完整的组件，可以自由定义和使用React的生命周期方法，如componentDidMount、componentDidUpdate等，仪便在适当的时候执行额外的操作，如数据获取、订阅事件等；
        * Mixins与类组件的生命周期方法配合复杂：虽然mixins可以定义生命周期相关的方法，但在类组件中使用时，需要手动调用mixins中的对应方法，且难以处理多个mixins中同名生命周期方法的调用顺序；
    5. 与现代React生态集成更好
        * HOC与React Hooks、Context API等新特性配合顺畅：HOC可以无缝与React的新特性结合使用，如HOOKS（useEffect、useMemo）用于管理副作用和性能优化，ContextAPI用于跨层级状态传递等，进一步提升代码组织和复用能力；
        * Mixins与React新特性的兼容性问题：随着React的发展，mixins与react hooks等新特性的结合变得困难甚至不可能，因为它们基于不同的编程模块，官方也不再推荐在新项目中使用；
