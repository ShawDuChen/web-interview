
# 1像素问题，怎么解决？
* 指在网页开发中，特别是在跨浏览器或跨设备环境下，某些元素的1像素边框或线条在实际渲染时可能会出现模糊、不对齐或显式不一致的现象。这个问题源于以下几个原因：
    1. 设备像素比差异：高分辨率屏幕的DPR大于1，意味着一个css像素对应多个物理像素，当为元素设置固定宽度的1像素边框时，在搞DPR设备上，浏览器可能无法精确将其映射到物理像素上，导致边框看起来模糊；
    2. 浏览器渲染差异：不同的浏览器对css规范的实现可能存在细微差异，特别是在处理班像素边框渲染时，可能导致最终显示效果不一致；
    3. 抗锯齿算法：为了提高视觉效果，浏览器通常对图像边缘进行抗锯齿处理，早某些情况下，这可能导致1像素线条变得模糊，尤其是在不同背景色交界处；
* 解决方案通常有如下方法：
    1. 使用图标代替边框或细线
        * 优点：确保所有设备的一致性
        * 缺点：增加了额外的http请求开销，当颜色多时，维护不灵活；
    2. 使用css3 transform scale()
        * 原理：通过将元素的尺寸缩小一半，然后利用css边框创建一个2像素的边框，浏览器在渲染时会对缩放的元素进行像素精确计算，因此原本的2像素经过0.5倍处理，实际表现为1物理像素，从而解决了模糊问题。
    3. 使用css border-image：通过创建一个包含1像素边框的图像，并使用border-image属性将其应用于元素，这样可以确保边框始终清晰，同时避免额外的http请求，这种方法需要一定的图像处理技巧，但能提高精细的控制；
    4. 使用box-shadow替代边框：对于某些场景，可以利用box-shadow属性来模拟边框，因为阴影不受抗锯齿影响，可以精确呈现为1像素宽；
    5. 使用css calc()和媒体查询适应DPR：根据设备DPR动态调整边框宽度，确保其始终对应一个物理像素，这种方法需要结合媒体查询来判断DPR；
    6. 综合考虑性能、易用性和跨浏览器兼容性，通常推荐使用transform: scale或box-shadow解决方案，因为它们简单高效，对于大多数场景能得到良好的支持。

# 如何理解静态资源完整性校验？
* 静态资源完整性校验是一种保障网页安全的技术手段，主要确保从第三方源加载的静态资源在传输过程中未被篡改；需要注意以下几个关键的：
    1. 安全威胁背景：互联网环境下，静态资源通常通过URL直接引用，意味着在传输过程中，可能面临以下风险：
        * 中间人攻击：攻击者通过网络嗅探、注入恶意代码或篡改传输数据，对静态资源进行篡改，注入恶臭脚本或破坏原有功能；
        * 第三方源不可信：即使通常可靠的第三方服务也可能因安全漏洞、配置错误或管理疏忽等原因导致静态资源被非法修改；
    2. 哈希值计算：静态资源完整性校验采用哈希值加密算法计算资源内容的唯一指纹；这个值是对资源内容的数学摘要，任何微小改动都会导致哈希值发生巨大变化。计算如下：
        * 开发者：在发布静态资源时，对资源文件内容进行哈希计算，得到对应的哈希值；
        * 用户端：浏览器在加载资源时，对下载的资源内容重新计算哈希值；
    3. SRI属性嵌入：开发者将计算得到的哈希值以BASE64编码形式附加到HTML标签中引入静态资源部分，通过integrity属性明确指定。
    4. 浏览器验证过程：浏览器加载带有integrity属性的资源时，执行以下步骤：
        1. 下载资源：从指定URL获取静态资源；
        2. 计算哈希：使用指定的哈希算法对下载的内容计算哈希值；
        3. 对比校验：将计算得到的哈希值与integrity属性中提供的哈希值进行对比，如果二者完全匹配，则认为资源未被篡改，允许正常执行，否则，浏览器拒绝加载资源，保护页面免受恶意代码的影响；
    5. 浏览器支持与局限性：静态资源完整性加载依赖浏览器支持；对于不支持SRI的老旧或非主流浏览器，上述安全措施无效；
    6. 优缺点和适用场景？
        * 优点：
            1. 增强安全性：有效防止中间人攻击篡改静态资源；
            2. 透明性：无需改变资源加载流程，对用户透明
        * 缺点：
            1. 配置复杂度：需要为每个静态资源计算哈希值并更新URL引用；
            2. 兼容性问题：对不支持SRI的浏览器无效；
            3. 更新管理：每次内容改变，需要重新计算哈希值并更新引用；
    7. 使用场景：对从第三方来源加载重要或敏感的静态资源，如第三方库、CDN托管的js和css文件，web字体等；


# vue2为什么要求组件模板只能有一个根元素，而vue3支持多根元素？
1. vue2
    * 原因：主要与vue2采用的虚拟DOM更新机制以及diff算法有关。
        1. 虚拟DOM的单根树形结构：vue2将组件模板编译成渲染函数，该函数返回一个虚拟DOM树，在vue2中，这个虚拟DOM树被设计为单根树形结构，即每个组件的渲染结果对应一个单一的根节点。这样涉及简化了虚拟DOM的构建和管理，确保了每个组件输出的结构清晰，易于理解；
        2. Diff算法的实现与效率：vue2使用基于树的diff算法来比较新旧虚拟DOM之间的差异，以便找出最小化DOM操作集进行高效更新。diff算法在遍历过程中假设每个组件对应一个单一的根节点。如果允许多个根节点，diff算法的复杂度将会显著增加，因为它需要处理兄弟节点的插入、删除、移动等多种情况，这不仅使算法变得复杂，也可能降低更新性能；
        3. 维护性和解耦：从组件涉及角度看，一个组件只能包含一个根元素有助于保持组件职责单一，提高代码可读性和可维护性。如果有多个根元素，通常意味着这些元素之间可能存在较高的耦合性。将它们合并到一个父元素下或拆分成独立的子组件，有助于遵循”单一职责原则“，使得组件逻辑更加清晰，有助于未来的维护和迭代；
2. vue3
    * fragment（片段）概念的引入：vue3引入了fragment概念，它是一个抽象的节点，允许组件模板返回多个根元素而不必包裹在一个实际的HTML元素中，当vue3编译器遇到多根节点组件时，会自动创建一个fragment节点作为这些根元素的共同父节点，在虚拟DOM节点层面，这个Fragment节点不会对应到真实的DOM元素，从而避免额外的DOM层级；
    * Diff算法优化：vue3在内部对diff算法进行了相应的调整，使其能够正确处理包含Fragment的组件，当算法检测到一个Fragment节点时，他会直接遍历其子节点，而无需关心实际的DOM插入位置，因为fragment本身并不会插入到DOM中，这种改动使得vue3的diff算法能够适应多根元素的场景，而不会显著增加复杂度或牺牲性能；

# 使用setTimeout模拟实现setInterval？
1. 避免累积执行：setInterval的一个常见问题时，如果定时器回调函数的执行时间超过设定的间隔时间，那么在前一次回调尚未完成时，下一次定时器可能已经出发了，而导致回调函数排队等待执行，形成“累积执行“的现象。当这种情况持续发生时，多个回调可能会在短时间内连续执行，违背了预期的定时间隔，甚至可能导致应用性能下降或行为异常。
2. 异常处理：如果setInterval的回调函数中发生了未捕获的异常，尽管异常被抛出，定时器仍然会按照原定间隔继续触发回调。这可能导致错误不断重复且难以控制。而使用setTimeout模拟时，可以在每次执行回调之前检查是否应该继续执行，或者在回调内部捕获并处理异常，从而更好控制定时任务的行为。
3. 精细控制：使用setTimeout模拟可以更精细控制定时任务的执行逻辑。例如，可以根据特定条件动态调整下次执行的延后时间，或者在满足某个条件后停止后续定时执行。使用setInterval难以实现。
4. 兼容性和一致性：在某些老旧或不稳定的环境中，setInterval的精确性可能无法得到保证。使用setTimeout模拟则可以提供一种更为可靠且一致的定时执行机制，尤其是在需要严格控制定时行为的应用场景；
```js
// 模拟
function customSetInterval(fn, delayInterval) {
    let intervalId = null;
    const wrapperFn = () => {
        fn();
        intervalId = setTimeout(wrapperFn, delayInterval);
    }
    intervalId = setTimeout(wrapperFn, delayInterval);
    return intervalId;
}
```
## 实现步骤
1. 定义一个名为customSetInterval的函数，接收fn和delay时间
2. 创建内部函数wrapperFn，负责实际执行函数回调并重新调度自身
3. 在wrapperFn内部，首先检查是否应该继续执行定时任务。这可以基于任何自定义逻辑，如应用程序的状态、错误状态等。
4. 若应继续执行，调用fn，然后用setTimeout安排wrapperFn在delay毫秒后执行，形成递归调用；
5. 如果不应继续执行，清除定时器以停止后续调用
6. 在customSetInterval函数外部，首次调用setTimeout以延迟delay毫秒后启动定时任务；
7. 返回intervalId，以便调用者可以通过clearTimeout来手动停止定时任务，模拟clearInterval的功能；

# 解决vue打包vendor过大问题？
1. 使用webpack-bundle-analyzer分析包大小，针对包体的分布情况，选择性进行优化
2. 代码分割和懒加载
    * 动态导入（异步组件）：对于非首屏必须加载的组件或库，使用动态导入实现按序加载
    * SplitChunksPlugin：配置SplitChunksPlugin，将公共模块提取到单独的chunk中。设置合理的minSize、minChunks等；
3. 优化第三方库的引入
    * 使用CDN：将大型或频繁更新的第三方库移到CDN，减轻主包负担，利用浏览器提交缓存加载速度。
    * TreeShaking：确保项目和依赖库支持es6，并启用webpack的treeshaking功能，移除未使用代码；
    * DLL Plugin：对于不稳定的第三方库，可以使用DLLPLugin和DLLReferencePlugin预先打包成单独的DLL文件，避免每次项目构建重复打包；
4. 压缩和优化：
    * 启用压缩：确保生产环境配置中启用了terser-webpack-plugin，对输出的js文件进行压缩；
    * 压缩图片和字体：使用合适的loader对静态资源进行压缩和转码；

## 优化webpack打包vue项目的时间
1. 合理配置loader和plugin
    * 限制loader处理范围：通过include、exclude或test属性精确匹配文件类型，避免不必要的loader应用；
    * 优化loader配置：如babel-loader缓存、css-loader的模块化和压缩选项等；
2. 启用多进程/多线程编译：使用thread-loader、happypack或parallel-webpack等工具，将耗时的loader任务分配到多个子进程中并行处理，提高构建速度；
3. 缓存构建结果：利用webpack的持久化缓存功能，在多次构建之间复用已编译过的模块，避免不必要的重复工作；
4. 使用更高效的Source Map：开发阶段可选cheap-module-source-map或eval-source-map以加快构建速度；生产阶段使用source-map或hidden-source-map即可；
5. 优化构建目标：根据目标环境选择合适的target选项，避免未不需要兼容的旧浏览器生成额外代码；
6. 升级依赖：确保webpack、vue及其他相关工具链的版本是最新的，利用新版本的性能提升和bug修复；

