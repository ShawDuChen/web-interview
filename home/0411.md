
# 尾递归的原理及其应用？
1. 原理：
    * 递归算法的一种特殊形式，其核心原理在于优化递归调用时的栈空间消耗；常规递归在每次函数调用时都会在调用栈上创建一个新的栈帧没用于存储局部遍历、返回地址等信息。当递归深度较大时，可能会导致栈溢出错误
    * 尾递归的特点在于递归调用出现在函数的最后，且递归调用的结果直接作为该函数的返回值，无需再进行其他操作。这种情况下，编译器或解释器可以进行如下优化
    1. 栈帧复用：由于尾递归函数时最后一步只是单纯的递归调用，并无其他操作，编译器可以识别这种模式，无需为新的递归调用创建新的栈帧，而是重用当前栈帧。这意味在递归过程中，尽管函数多次调用，但只占用一个固定的栈空间；
    2. 状态转移：在递归调用之前，尾递归函数通常会将所有必要状态合并到参数列表中传递给下次递归调用，这样就无需在栈上保留这些状态。这样做的好处是避免了栈深度的增长，使得递归调用可以在有限的栈空间内无限进行下去；
2. 应用：适用于哪些可以通过递归来解决问题，但常规递归可能导致栈溢出的情况；
    1. 数值计算：如计算阶乘、斐波那契数列、大数乘法，高精度除法等数学问题。通过合理设计尾递归函数，可以避免因递归深度过大而导致栈溢出错误。
    2. 树形结构遍历：如深度优先搜索、解析树、编译器语法分析等。在递归遍历树节点时，通过调整递归函数使其满足尾递归条件，可以有效节省栈空间；
    3. 图算法：如拓扑排序、深度优先标记等。尾递归可以用于处理有向无环图中的节点关系，避免在处理大规模图时栈空间不足；
    4. 递归数据结构操作：如处理递归定义的数据结构，如列表的折叠、展开、map、filter等操作，可以使用尾递归实现高效且内存友好的版本；
    5. 函数式编程：在函数式编程语言中，尾递归被视为一种基本的编程范式，许多语言特性和库函数都围绕尾递归设计。函数式编程鼓励使用递归而非循环来解决问题，尾递归优化使得这种风格的代码能够在不影响效率的前提下保持简洁和易于理解。

# ES6对字符串类型做的常用升级优化
1. 模板字符串：使用反引号创建，允许在字符串中嵌入表达式，极大地简化了字符串拼接和格式化，其特点包括：
    * 嵌入表达式：通过`${expr}`语法可以在字符串任意插入有效的js表达式，表达式的结果会自动转换为字符串并插入到对应位置；
    * 多行字符串：目标字符串可以自然跨越多行，无需使用转义字符或字符串拼接。换行符会被包含在最终的字符串中，使得多行文本的创建更加直观。
2. 字符串重复方法repeat：repeat方法返回一个新字符串，该字符串由原字符串重复指定次数生成。接受一个整数参数，表示重复次数；
3. 字符串包含、开始和结束判断方法：
    * includes：判断字符串是否包含指定子字符串，返回布尔值；
    * startsWith：检查字符串是否以指定的子字符串开头，返回布尔值
    * endsWith：检查字符串是否以指定的子字符串结尾，返回布尔值
4. 字符串编码与解码方法
    * codePointAt：返回指定位置的字符的Unicode代码点；
    * fromCodePoint：接受一系列Unicode代码点，返回对应的的字符串
    * normalize：规范化字符串，以便统一比较含有组合字符或等价字符的不同表示形式；
5. 字符串检索或替换方法增强：
    * padStart、padEnd
    * trimStart、trimEnd
    * matchAll：返回一个迭代器，生成所有匹配正则表达式的捕获组详情；
6. Unicode支持：包括正确处理代理对和引入新的正则表达式标志，以正确匹配和处理Unicode字符。

# 微前端中应用隔离是怎么实现的？
* 应用隔离主要指在同一个主应用容器中集成多个独立开发、部署的子应用时，确保各个自应用之间在数据、逻辑、视图、状态等方面互不影响。实现应用隔离通常涉及以下几个方面：
    1. 视图隔离
        * DOM隔离：通过在主应用中为每个子应用分配独立的DOM容器，子应用的内容渲染在这个特定的容器内，防止其样式和行为影响到主应用或其他子应用的DOM结构；
        * 样式隔离：使用css module、命名约定、css-in-js、shadow dom等技术，确保子应用的样式只作用于其自身的DOM范围，避免样式冲突。也可以使用css隔离属性isolation：isolate；来启用层叠上下文隔离；
    2. 脚本隔离
        * 沙箱环境：通过沙箱机制，为每个子应用创建独立的运行环境，防止子应用的脚本直接访问或修改主应用或其他子应用的全局变量，DOM，事件监听；
        * API封装：提供一套标准化的接口，让子应用通过这些接口与主应用进行通信（生命周期、数据交换、事件广播）而不是直接操作全局状态或DOM；
    3. 状态隔离隔离
        * 独立状态管理库：每个子应用使用各自的独立状态管理库（Redux、vuex、mobx等）确保状态数据不直接共享，而是通过主应用提供的通信机制进行交互；
        * 全局状态中心：对于需要共享的状态，可以设立一个全局状态中心，通过发布订阅模式或特定API让子应用以受控方式访问和共享状态；
    4. 路由隔离
        * 独立的路由配置：每个子应用拥有独立的路由配置和路由处理逻辑，主应用负责协调各子应用的路由切换，确保URL变化时正确的子应用被激活和渲染；
        * 路由参数传递：主应用在切换子应用时，可通过URL查询参数或特定的路由事件传递参数给子应用，子应用根据这些参数进行初始化或数据加载；
    5. 生命周期管理
        * 子应用生命周期钩子：微前端架构通常提供生命周期钩子，子应用在这些钩子中指向加载、挂载、卸载等操作，确保资源正确加载和释放，避免内存泄漏或状态残留；
    6. 错误处理与边界保护
        * 异常捕获与隔离：在子应用的执行上下文中捕获未处理的异常，防止一个子应用的错误影响到整个主应用或其他子应用的稳定性，可以提供专门的错误上报机制，便于监控和调试；
        * 资源访问控制：通过CSP等机制限制子应用对某些敏感资源的访问，增强安全性；

# 前端常用的设计模式有哪些？
1. 单例模式
    * 包装一个类仅有一个实例，并提供一个全局访问点。在前端开发中，常用于创建哪些只有一个实例的对象，如应用程序级别的事件总线，状态管理库的store、全局配置对象等。
    * 实现方式：使用闭包、静态私有实例，es6的symbol或weakmap等技术防止多次实例化；
2. 观察者模式（发布订阅模式）
    * 定义对象的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新；
    * 在前端开发中广泛应用于事件驱动编程，数据绑定，状态管理，websocket消息推送等场景；
3. 工厂模式
    * 提供创建对象的接口，隐藏具体的创建逻辑，使客户端不必知道对象是如何创建及组织的。
    * 常用于组件的实例化、模块的动态加载，不同环境中的创建不同类型的对象等场景。例如，基于用户代理创建不同实现的ajax请求对象。
4. 建造者模式
    * 将某一个复杂对象的构建过程与它的表示相分离，使得相同的构建过程可以创建不同的表示；
    * 在前端开发中，适用于构建复杂的UI组件或配置对象，通过逐步设置属性或步骤来创建所需对象，如echart图标的配置过程；
5. 装饰着模式
    * 动态给对象添加额外的责任或行为，通过包装原有对象，保持接口一致，增加功能的同时不影响其他对象。
    * 常用于增强或修改组件功能，如按钮添加loading、为元素添加额外样式或事件处理器，而无需修改组件源码；
6. 代理模式
    * 为其他对象提供一种代理以控制对这个对象的访问。代理对象和目标对象具有相同的接口，客户端可以透明地通过代理对象访问目标对象。
    * 应用场景包括：延迟加载、权限控制、数据预处理、虚拟DOM等；
7. 适配器模式
    * 将一个类的接口转为客户期望的另一个接口，使得原本不兼容的类可以一起工作；
    * 对接不同库、框架、API的接口，如将遗留代码与新项目整合，或是统一处理不同数据源返回的数据格式。
8. 策略模式
    * 定义一系列算法，将每个算法封装起来，并使它们可以互相替换，策略模式让算法的变化独立于使用它的客户；
    * 适用于实现可切换的业务逻辑，动画效果，表单验证规则等，如根据用户偏好或设备能力选择合适的图片压缩策略，排序算法等。
9. 命名模式
    * 将请求封装为一个对象，使得使用命令对象的请求，记录请求，撤销请求，重做请求，队列请求等操作变得容易；
    * 常用于实现操作的历史记录，回滚事务处理，异步请求排队等场景；

# vuex和单纯的全局对象有什么区别？
1. 响应式状态存储：
    * vuex采用vuejs的响应式系统，其内部状态时响应式的。当store中的状态发生变化时，依赖这些状态的vue组件会自动、高效这些更新视图。这使得状态变化能够立即反映在界面中，无需手动更新；
    * 单纯的全局对象不具备响应式特性，如果组件直接依赖一个全局对象的属性，状态变化后不会触发组件的重新渲染，需要手动更新相关组件，这不仅增加了开发负担，还可能导致状态和视图不一致；
2. 集中式状态管理
    * vuex提供了一个集中化的状态管理模式，所有的应用状态都被统一存放于store中，形成了一个”单一可信源“。这种集中式使得状态变更，访问控制，状态跟踪等工作变得更加有序和可控；
    * 全局对象虽然也能在全局范围内访问，但它缺乏对状态管理的组织和约束。随着应用规模扩大，全局对象可能导致状态分散，难以追踪和维护，容易引发全局变量污染等问题；
3. 状态变更可控性
    * vuex强制通过mutation来修改状态。mutations是纯函数，且必须在store内部定义，提供了统一的地方来跟踪和记录所有状态变更。这种集中式的变更机制有利于代码审查，调试和测试，也有利于实现诸如时间旅行，状态快照等功能；
    * 使用全局对象时，任何地方都可以直接修改其属性，状态变更过程难以追踪和控制。这种随意性可能导致难以预料的副作用和难以调试的问题；
4. 异步操作和actions
    * vuex提供actions来处理异步操作。Action可以包含异步逻辑，并听过mutation来间接更新状态。这种分离关注点的设计有助于代码组织和理解，同时action还可以处理事务，处理错误和状态过度等复杂情况；
    * 全局对象通常无法直接支持这种结构化的异步操作管理。在没有vuex的情况下，异步状态更新通常分散在各个组件内，难以实现统一的错误处理，中间件等高级特性；
5. Getters for derived state
    * vuex提供getters计算派生状态，getters可以视为基于store中已有状态计算得出的新store的计算属性，能够被组件轻松消费，并且是响应式的。
    * 全局对象若要实现类似的功能，通常需要在各个组件内自行计算，导致代码重复和计算逻辑分散。而且使用全局状态的派生对象不会自动响应底层代码的变化。
6. 模块化与组织结构
    * vuex支持模块化，允许将大型应用的store分割为多个小的，松散耦合的模块，每个模块都有自己的state、mutations、actions和getters，有助于大规模应用的状态管理保持清晰和可维护。
    * 全局对象在应对复杂应用时，其内部接口可能变得庞大且混乱，缺乏良好的组织方式来应对状态的细分和模块化需求；
7. 工具支持和生态
    * vuex提供了丰富的工具支持，vuex devtools插件，可以实时查看和调试store中的状态，mutations记录，action调用等。
    * 全局对象虽然可以直接在浏览器开发者工具中查看和修改，但缺乏针对状态管理特性的专业调试工具支持。

# 如何使用css禁止移动端页面的左右滑动手势？
1. 使用overflow-x：hidden属性：通过将html和body标签的overflow-x：hidden可以确保内容超出视口宽度时，浏览器不会显示水平滚动条，同时用户也无法通过任何方式（包括滑动手势）进行水平滚动。这种方式适用于大多数现代移动端浏览器；
2. 利用touch-action属性：touch-action属性用于定义元素上允许的触控行为。将它设置为pan-y表示只允许垂直方向的滑动手势。这有助于确保用户在移动端浏览器上的滑动仅触发垂直滚动，而不引起页面的左右平移；注意，touch-action兼容性存在问题，对于一些老旧或者非标准的移动端浏览器，可能需要其他方面考虑兼容性问题；
3. 这对特定容器禁止滑动：如果你只想禁止某个特定容器内的左右滑动手势，可以适用overflow-y和touch-action样式；
4. 处理滚动穿透问题：当在移动端弹出一个覆盖全屏的层并禁止底层滚动时，可能会遇到滚动穿透问题，即虽然底层页面看似无法滚动，但实际上滑动事件传递给了底层元素。可以在弹出层激活时为hmtml、body添加额外样式；
5. 总结：适用overflow-y和touch-action；

# 什么是JSX？
1. 一种在js中适用的类似XML/HTML语法来声明react元素的语法扩展。尽管它的外观和html类似，但实际上是一种在js中嵌入的、具有特定语法规则的表达式，能在编译时转为纯粹的js对象。
2. 核心点：
    1. 语法糖：jsx是React.createElement的语法糖。编写jsx代码，会在构建过程中转换成React.createElement的调用；
    2. 嵌入式js表达式：jsx中，可以使用花括号包裹js表达式，它们会求值并插入到最终生成的元素树中。
    3. 条件渲染和循环：由于jsx是嵌入在js中的，所以可以方便利用js控制流语句来实现条件渲染和列表渲染；
    4. 组件化：jsx可以创建原生html标签外，还可以用来定义和使用React组件。组件时react应用程序的基本模块，它们是可重用的，独立的UI片段，拥有自己的状态和行为。在jsx中，自定义组件以大写字母开头的标签出现；
    5. 语义和可访问性：使用jsx时应遵循良好的html语义和可访问性实践。

# vue中对mixins的理解？
1. mixins是一种实现组件间代码复用的重要机制，它允许开发者将一组可复用的功能封装在一个单独的js对象中，并可以在多个vue组件中轻松使用这些功能。通过使用mixins，可以避免多个组件的重复编写相同逻辑，提高代码的简洁性和可维护性。
2. 特性和作用
    1. 封装可复用功能：mixins主要用于封装一组通用的、与视图无关的逻辑。如数据处理、计算属性、方法、生命周期钩子、指令等。这些功能可以是数据获取、状态管理、事件处理、工具函数等任何在多个组件中可能需要共享的部分。
    2. 组件选项合并：当一个组件使用mixins时，mixins对象中的所有选项会被深度合并到该组件自身的选项中，这意味mixin提供的属性和方法会称为组件自身的一部分，可以直接在组件模板或逻辑中访问组件本地属性一样使用；
        * 数据合并：若mixins和组件中存在同名的数据属性，它们会被合并作为对象的属性添加到组件的data中。注意，如果存在同名属性，组件自身的属性会覆盖mixins的同名属性；
        * 生命周期钩子合并：如果mixins和组件存在同名生命周期钩子，他们都会被调用，mixins的钩子函数会在组件自身钩子函数之前执行；
        3. 方法，计算属性，watch合并：同名方法、计算属性和侦听器也会被合并，组件可以直接访问到mixin中提供的这些功能，如果有冲突，组件自身的定义优先级更高，会覆盖mixin中的同名项；
3. 组合与扩展：一个组件可以使用多个mixin是，它们之间选项也会按照同样的规则进行合并，这种设计允许开发者灵活组合多个mixins，形成复用的可复用模块，以满足不同场景的需求；
4. 注意事项：
    1. 命名冲突：由于mixin与组件选项的合并策略，应当谨慎处理可能导致命名冲突的情况，建议在编写mixins遵循良好的命名约定，避免使用过于通用的名称，并在文档中清晰说明提供的功能；
    2. 依赖管理：如果mixin依赖于外部库，全局变量或其他非局部状态，确保使用它的组件具有正确的环境和依赖。在大型项目中，可能需要通过模块系统或依赖注入来管理这些关系；
    3. 调试与追踪：由于mixin中的逻辑可能在多个组件复用，当出现问题时，定位错误来源可能会变得复杂。良好的日志记录，代码结构以及使用vue devtool可以帮助进行调试；


# react和vue中，为什么推荐给组件设置唯一的key？
1. 一般在渲染列表时，推荐为组件或元素设置唯一的key，原因如下：
    1. 提升虚拟DOM diff效率：react和vue都采用虚拟dom来高效更新实际dom，当组件状态引发重新渲染时，他们会被新旧虚拟dom树进行差异比较来确定哪些部分需要实际更新到真实dom上，通过比较key，框架能快速识别出列表中的元素是否发生了以下变化：
        1. 新增：列表中有key未在旧列表中出现的元素；
        2. 删除：旧列表中有key未在新列表中出现的元素；
        3. 移动：key相同但位置不同的元素；
    如果没有key，框架只能通过元素的位置进行比较，这会导致不必要的元素重新渲染和dom操作；例如，当列表中元素顺序发送改变时，即使元素内容并未变动，框架也可能误判为所有元素都需要重新插入。有了key，框架可以准确识别元素的身份，只对真正变化的部分进行最小化dom更新，显著提高diff和渲染性能；
    2. 保持组件状态与dom节点关联：组件可能包含内部状态或与第三方库的绑定，为组件设置key可以确保在列表更新时，具有相同key的组件实例得以保留，其内部状态和第三方库绑定得以维持，避免状态丢失或意外行为。如果没有key，当列表元素重新排序时，原有的组件实例可能会被错误地复用到新位置，导致状态混乱。
    3. 避免不必要的子组件重新渲染：当父组件状态引起重新渲染时，子组件默认也会重新渲染。但如果子组件使用了React.memo或vue.runtime.esm-bunlder.js中的defineComponent()进行优化，具有唯一key的子组件在内容未变时，可以避免不必要的重新渲染，因为框架可以通过key快速判断组件内容未变，从而跳过渲染；
    4. 遵循最佳实践和框架预期：设置key时react和vue官方推荐的最佳实践。在没有明确key时，框架通常会发出警告提示，强调重要性。遵循规范可以编写高效、易于维护的代码。

# await到底在保护什么？
* await关键字在js的异步编程中使用，尤其是在使用async/await语法时，它们用于等待promise或者其他有then方法对象的完成或失败，具体来说，await在等到以下内容：
    1. promise的解决：当await用于等待一个promise对象时，他会暂停所在async函数的执行，并等待该promise解决为其返回结果。一旦promise被解决，await表达式的值就是promise的解决值。
    2. promise的拒绝：如果promise被拒绝，即异步操作遇到错误或异常，await会使async函数抛出一个异常，这个异常可以在try/catch块中捕获并处理，或者向上冒泡至调用栈中的其他异常处理器。
    3. 其他具有then方法的对象：await不仅可以等待promise，也可以等待任何具有then方法的对象，这意味着如果你的有一个遵循promise/a+规范的对象，await也能正确处理。
* 总之，await关键字在js异步编程中用于暂停async函数的执行，等的爱promise对象或其他具有then方法的对象的解决，并获取其结果。如果promise被拒绝，await会使async函数抛出一个异常，可以被捕获并处理，这种方式极大简化了异步代码的编写，使其看起来更接近同步代码，增强了代码可读性和可维护性。
