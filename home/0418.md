# 实现单点登录的原理？
1. 中心化身份认证服务
    * 认证中心：SSO系统的核心组件是独立的认证中心，它负责集中处理用户的登录请求、验证用户身份以及颁发授权凭证。所有SSO服务的应用系统都与该认证中心建立信任关系，不再自行处理用户登录。
2. 用户身份验证
    * 用户交互：用户访问任何一个受SSO保护的子系统时，如果尚未登录，都会被重定向到认证中心提供的统一登陆界面；
    * 凭证提交：用户在登陆界面输入其凭据，并提交至认证中心。
    * 身份验证：认证中心通过对比存储的用户数据验证用户提交的凭证是否有效。验证成功后，认为用户已通过身份验证。
3. 授权与会话管理
    * 令牌发放：认证中心验证用户身份后，生成一个代表用户已授权的令牌。这个令牌通常包含用户的身份信息、授权声明、过期时间等数据，常见的格式有JWT、SAML断言等。
    * 会话管理：认证中心创建并维护全局会话，记录用户已登录状态。同时，将令牌传递给用户浏览器（通过HTTP响应中的Set-Cookie头部或URL重定向参数）
4. 应用系统间信任与协作
    * 令牌传递：用户浏览器持有令牌后，访问其他子系统时，会自动携带该令牌。子系统接收到请求后，识别出令牌的存在。
    * 令牌验证“子系统向认证中心验证令牌的有效性。这通常通过查询认证中心提供的接口完成，或者利用数字签名等机制直接验证令牌的完整性与合法性；
    * 局部会话创建：子系统确认令牌后，基于令牌中的信息创建或关联局部会话，允许用户无须重新登录即可访问子系统的受保护资源。
5. 单点登出
    * 登出请求：用户在任何一个子系统发出登出请求时，该子系统应通知认证中心撤销用户的全局会话，并清除相关令牌；
    * 会话注销：认证中心接收到登出请求后，注销全局会话，更新相关状态以确保所有子系统后续无法再验证该令牌的有效性；
    * 子系统响应：子系统清除自身的局部会话，并可能重定向用户回到认证中心的登出确认页面或其他指定位置。

# 解释一下什么是JWT？
* JWT（JSON Web Token）是一种开放标准，用于在网络应用环境中以JOSN格式安全地传输信息，它被设计为紧凑、包含且易于再不同平台间传递的令牌，常用于实现用户身份验证和授权。JWT的基本特征和工作流程如下：
    1. 结构：jWT由三部分组成，它们之间用.分隔：
        * 头部：描述了使用JWT类型以及所使用的加密算法。例如
        ```json
        {
          "alg": "HS256",
          "typ": "JWT"
        }
        ```
        这部分内容通常会被base64url编码形成JWT的第一部分。
        * 载荷（payload）：包含实际要传递的数据声明。声明可以是标准的或自定义的。例如：
        ```json
        {
          "sub": "",
          "name": "",
          "iat": "",
          "exp": "",
          "role": ""
        }
        ```
        载荷同样会被base64url编码，成为JWT的第二部分；
        * 签名：通过对签名两部分使用指定的加密算法和一个密钥进行计算，确保jwt内容的完整性和防止被篡改。签名过程确保只有拥有密钥实体才能生成有效的jwt，接收方则可通过同样的方法验证jwt的来源及内容未被改动。
    2. 工作流程：
        * 生成：服务器在用户成功登陆后，根据用户身份和授权信息生成jwt。具体步骤包括构建头部和载荷，然后使用密钥对这两部分进行签名，生成完整的jwt字符串。
        * 传输：jwt通常通过http头部的authorization字段以Bearer模式发送给客户端，或者嵌入到王爷的cookie中。由于其紧凑的特性，jwt可以在俩、post参数中轻松传递，适合跨域场景。
        * 验证：客户端在后续请求中附带jwt，服务器接收到后，首先检查签名的有效性，然后解析载荷以验证其内容（如检查过期时间，检查发行者等）。验证通过后，服务器确认用户身份并据此实施授权决策，允许访问相应的资源或执行操作。
    3. 优势与应用场景
        * 无状态：服务器无需在内存或数据库中存储会话状态，仅根据jwt即可做出认证或授权决策。这有利于水平扩展和集群部署；
        * 跨域：jwt不受同源策略限制，能够在多个域名、子域名或不同端口间的应用间共享用户身份信息，非常适合实现单点登录；
        * 安全性：通过数字签名和可选的加密，jwt能够保障数据在传输过程中的完整性和真实性。使用HTTPS可以进一步增强通信安全。
        * 自包含：JWT携带了必要的用户信息和授权声明，使得服务端可以直接使用这些信息进行业务逻辑处理，无需额外查询数据库。    

# addEventListener在removeEventListener中会不会造成内存泄漏？
* 不会，addEventListener本身并不会直接导致内存泄漏，相反，它是在DOM元素上注册一个事件处理器，以便当特定事件发生时能够触发相应的回调函数。内存泄漏通常发生在以下几种情况：
    * 事件处理器未被正确移除：如果在不再需要某个事件处理器时，没有通过removeEventListener方法将其从对应的DOM元素上移除，即使该元素及其关联的回调函数已不再使用，它们仍可能留在内存中，无法被垃圾回收机制释放，从而导致内存泄漏；
    * 时间处理器持有强引用：如果事件处理器回调函数内部或其他闭包环境中存在大对象、集合或其他资源的强引用，且这些引用在事件处理器执行完毕后本应被释放，但由于未移除事件处理器而导致持续存在，也会形成内存泄漏；
    * 循环引用：当事件处理器回调函数引用了外部作用域的对象，同时这个对象本身又反过来引用了DOM元素或事件处理器本身，可能会形成循环引用，阻止垃圾回收正确清理相关内存。
* 避免内存泄漏的策略：为了避免因addEventListener和removeEventListener不当造成的内存泄漏，可以采取以下措施：
    * 确保成对使用：在添加事件监听器的地方，应该有对应的逻辑来移除它。通常在组件的生命周期合适的阶段执行。
    * 使用正确的参数：移除事件监听器时，必须传入与添加时相同的参数：相同的事件类型、处理函数。否则无法正确移除；
    * 管理作用域和引用：避免在事件处理器内部创建长期存在的引用或循环引用。如果必须保留对大型数据结构或外部对象的引用，确保在处理器执行完毕后能够移除这些引用；
    * 使用函数绑定或箭头函数：如果事件处理器是类方法或需要访问组件上下文，使用bind方法创建绑定实例的版本，或者直接使用箭头函数以确保正确的this上下文。这样在移除监听器时，只需要处理绑定后的函数即可，无需担心this变化导致的移除失败。
    * 利用现代框架提供的生命周期钩子：在React、Vue等，可以利用如componentDidMount或mounted等处理；

# 事件冒泡和事件捕获？
## 事件冒泡
* 指的是当一个事件在DOM元素上触发时，该事件会首先在触发事件的最内层元素上执行，然后逐级向父元素传播，直到到达文档根节点。这种机制模拟了物理事件中气泡从水底升至水面的过程。
* 事件冒泡过程：
    1. 事件触发：用户在界面珊瑚的某个元素上执行了操作；
    2. 目标阶段：事件首先在触发事件的元素上触发，执行其绑定的事件处理器。
    3. 冒泡阶段：事件从目标元素开始，沿着DOM树向上逐级传播，依次触发每祖先元素上绑定的相同类型的处理器，直到根节点；
## 事件捕获
* 一种与冒泡相反的事件传播机制。当一个事件触发时，事件首先从根元素开始向下传播，结果各个祖先元素，直到达到触发事件的目标元素。这张机制允许更高级别的元素优先接收并处理事件。
* 事件捕获过程：
    1. 事件触发：用户在页面上的某个元素执行了操作；
    2. 捕获阶段：事件从文档根节点开始，沿着dom树向下传播，依次触发每个祖先元素上绑定的相同事件类型的捕获处理器，但不包括目标元素本身。
    3. 目标阶段：事件达到触发事件的元素，执行其绑定的事件处理器；
    4. 捕获阶段：事件按照事件冒泡的方式继续向上传播（可选，却决于是否取消冒泡或有无处理器捕获事件）
## addEventListener（type, handler, bubbles）
* bubbles: true -> 使用冒泡；false -> 使用捕获
* 同时使用捕获和冒泡；
    * 现代浏览器支持同时使用捕获和冒泡。这意味着同一事件可以在捕获阶段触发一次处理，然后再冒泡阶段再次触发处理器。这种设计为开发者提供了更大的灵活性，可以根据需求在不同阶段处理事件。
* 总结：事件冒泡从元素向外传播，捕获从外向元素传播事件。这两种机制共同构成了DOM事件的完整传播模型，使得事件可以在整个元素树中得到恰当的处理。在实际开发中，根据需求选择合适的事件处理阶段，有助于构建高效且易于维护的事件处理逻辑。

# isNaN和Number.isNaN的区别？
1. isNaN：全局函数，一个早期就存在于js中的全局方法，用于检查给定的值是否可以被解析为非数字，其行为特点是：
    * 类型转换：isNaN在检查过程中会先尝试将传入的参数转换为数字。这意味任何不能被成功转换为数值的值（null、undefined、空字符串、非数字字符串、对象等）都会返回true；
2. Number.isNaN：静态方法，在ES6引入的更为严格和准确的NaN检测方法，隶属于Number构造函数，其行为特点是：
    * 严格比较：Number.isNaN不会对传入的参数进行类型转换，而是直接检查其原始值是否严格等于NaN。只有当参数值本身就是NaN时，该方法才会返回true；
3. 对比总结
     * 行为差异：isNaN会尝试将参数转为数字后，在进行判断，可能导致非NaN值误判为true，而Number.isNaN则仅对原始值与NaN进行严格相等比较，不会进行类型转换，因此结果更准确；
     * 使用场景：由于isNaN的宽松性质可能导致意外的结果，一般推荐在需要精确判断NaN值时使用Number.isNaN，而在旧版浏览器或兼容性要求高时，继续使用isNaN，并结合其他类型检查手段确保准确性。

# nginx是什么？
* 一种开源的、高性能的HTTP和反向代理服务器，同时提供IMAP/POP3/SMTP服务。Nginx以轻量级、稳定、高效和低资源消耗的特定而广受欢迎。nginx在BSD-like协议下发行，适用于多种操作系统，包括linux、Unix、macOS和windows；
* 主要功能和特性
    1. 高性能与高并发处理：以出色的并发处理能力著称，能够在有限的硬件资源下支持大量的并发连接。通过高效的事件驱动和异步非阻塞模型，nginx能够轻松对应高负载缓解，支持高达数万乃至十万的并发连接；
    2. 反向代理：作为方向代理服务器，可以将客户端请求转发到一组应用服务器上，实现负载均衡、缓存管理、请求路由、安全隔离等功能。通过配置规则，nginx可以透明分发请求到多个后端服务器，可根据需要调整分发策略；
    3. 静态内容服务：nginx擅长快速、高效地提供静态文件服务内容，如HTML、css、js、图片、视频等。它内置缓存机制，可以减少对后端服务器的请求压力，提升用户访问速度。
    4. HTTP服务器：nginx可以作为独立的HTTP服务器，用于托管动态或静态网站内容，支持多种HTTP方法、HTTP/1.x、HTTP/2以及SSL/TLS加密，能够处理常见的HTTP头部、状态码和重定向；
    5. 负载均衡：nginx内置多种负载均衡算法、可以将客户端请求均匀分不到多个后端服务器，提供系统的可用性和扩展性。
    6. 缓存加速：作为缓存服务器，对常用或不常变的资源进行临时缓存，减少对后端应用的请求次数，显著提高网站性能。缓存控制可以通过配置文件灵活设置，支持缓存过期，条件缓存，缓存清除等机制。
    7. 安全与防护：nginx提供了丰富的安全功能，如支持SSL/TLS加密、基础的访问控制、DDoS防御、限速、URL重写、防盗链等，有助于保护服务器免受攻击和滥用。
    8. 模块化架构：nginx采用模块化设计，拥有众多可选的第三方模块，可以根据需要扩展功能。
* 应用场景
    1. web服务器：部署静态网站、博客、电商平台；
    2. 应用程序反向代理：为java、python、nodejs等后端服务器提供负载均衡、缓存、请求过滤等服务。
    3. API网关：作为微服务架构中的统一入口，实现请求路由、认证、限流、日志记录功能；
    4. CDN边缘服务器：作为内容分发网络的一部分，缓存并发分发静态资源；
    5. 邮件代理：通过支持IMAP/POP3/SMTP协议，实现邮件服务器的代理和转发。
